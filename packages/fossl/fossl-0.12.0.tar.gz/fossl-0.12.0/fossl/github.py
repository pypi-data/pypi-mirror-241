
import atexit
from dataclasses import dataclass, field
from datetime import date, datetime
from pathlib import Path
import textwrap
from typing import Any, Dict, List

import requests

from . import toml


__all__ = ['get_license_data', 'get_license_details',
           'GitHubApiRateLimitExceeded',
           'LicenseNotFoundError',]


TIMEOUT = 2

# Uses GitHub's REST API to obtain Open Source license information
# See https://developer.github.com/v3/licenses/
_URL = "https://api.github.com/licenses"
_URL_RATE_LIMIT = "https://api.github.com/rate_limit"


class Cache:
    def __init__(self):
        self._dirty = False
        self.licenses = {}
        self.file_path = Path.home() / '.config' / 'fossl.toml'
        toml_data = self.load()
        if toml_data:
            self.last_updated = toml_data.get('last-update')
            for key in toml_data.get('license-cache'):
                self.licenses[key] = toml_data['license-cache'][key]

    def get(self, key: str) -> Dict[str, Any]:
        return self.licenses.get(key)

    def set(self, key: str, obj: Dict[str, Any]) -> None:
        self.licenses[key] = obj
        self._dirty = True

    def load(self) -> Dict[str, Any]:
        if not self.file_path.exists():
            return None
        toml_data = toml.load(self.file_path)
        last_update = date.fromisoformat(toml_data.get('last-update'))
        days_since = date.today() - last_update
        if days_since.days > 90:
            toml_data = None
        return toml_data

    def dump(self) -> None:
        if not self._dirty:
            return
        toml_data = {
            'last-update': date.isoformat(date.today()),
            'license-cache': self.licenses,
        }
        toml_text = toml.dumps(toml_data)
        if not self.file_path.parent.exists():
            self.file_path.parent.mkdir()
        with open(self.file_path, 'w', encoding='utf-8') as fp:
            header = '''
                # This file is generated by fossl. DO NOT edit it.
                #
                # It caches the supported FOSS licenses here in order to
                # optimize the tool's performance.
                #
                # fossl will automatically update this file if it is older
                # than 1 year.
            '''
            fp.write(f'{textwrap.dedent(header)}\n')
            fp.write(toml_text)
            fp.write('\n')


class GitHubApiRateLimitExceeded(Exception):
    '''Exception to be raised when the GitHub REST API has been accessed
       too often i.e. the rate limit has been exceeded. The exception
       informs at which time the rate limit will be reset.'''
    def __init__(self, rate_info):
        super().__init__()
        datm = datetime.fromtimestamp(rate_info['reset'])
        self.reset_at = datm.strftime('at %H:%M:%S on %Y-%m-%d')
        self.remaining = rate_info['remaining']
        self.limit = rate_info['limit']
        self.used = rate_info['used']
        self.message = ('The GitHub REST API rate limit has been exceeded. '
                       f'It will be reset {self.reset_at}.')   # noqa: E128

    def __str__(self):
        return self.message


class LicenseNotFoundError(ValueError):
    '''An exception raised when information on an unknown license is
       requested.'''
    def __init__(self, spdx_id):
        '''Constructor'''
        super().__init__(f'Unkown license {spdx_id}')
        self.spdx_id = spdx_id


@dataclass
class LicenseInfo:
    key: str = ''
    name: str = ''
    node_id: str = ''
    spdx_id: str = ''
    url: str = ''
    html_url: str = ''
    description: str = ''
    implementation: str = ''
    permissions: List[str] = field(default_factory=List)
    conditions: List[str] = field(default_factory=List)
    limitations: List[str] = field(default_factory=List)
    body: str = ''
    featured: bool = False

    def __init__(self, data: Dict[str, Any]):
        for key, val in data.items():
            setattr(self, key, val)


def check_api_rate_exceeded():
    '''
    Tests whether the API rate limit was exceeded or not.
    :raises: GitHubApiRateLimitExceeded
    '''
    response = requests.get(_URL_RATE_LIMIT, timeout=TIMEOUT)
    # To see the full response enter
    # curl \
    #   -H "Accept: application/vnd.github.v3+json" \
    #   https://api.github.com/rate_limit
    core = response.json()['resources']['core']
    if core['remaining'] == 0:
        raise GitHubApiRateLimitExceeded(core)


def cached(decorated_function):
    def decorator(*args, **kwargs):
        '''
        :raises: GitHubApiRateLimitExceeded
        '''
        if not cache.licenses:
            response = requests.get(_URL, timeout=TIMEOUT)
            if response.status_code == 403:
                check_api_rate_exceeded()
            for license in response.json():
                cache.set(license['key'], license)
        return decorated_function(*args, **kwargs)
    return decorator


@cached
def get_license_data() -> List[LicenseInfo]:
    return [LicenseInfo(lic) for lic in cache.licenses.values()]


@cached
def get_license_details(spdx_id: str) -> LicenseInfo:
    '''
    :raises: LicenseNotFoundError
    :raises: GitHubApiRateLimitExceeded
    '''
    spdx_id = spdx_id.lower()
    if not spdx_id in [key for key in cache.licenses]:
        raise LicenseNotFoundError(spdx_id)
    license = cache.get(spdx_id)
    if not license.get('html_url'):
        response = requests.get(_URL + f'/{spdx_id}', timeout=TIMEOUT)
        if response.status_code == 404:
            raise LicenseNotFoundError(spdx_id)
        if response.status_code == 403:
            check_api_rate_exceeded()
        license = response.json()
        cache.set(license['key'], license)
    return LicenseInfo(license)


# ---

cache = Cache()

atexit.register(cache.dump)
