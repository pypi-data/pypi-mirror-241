import warnings
try :
  import pycwt as wavelet
except :
  warnings.warn ('pywct is not installed, wavelet functions will not be available.')
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors, ticker
from scipy.optimize import least_squares
import plato_msap4_demonstrator as msap4

'''
Wavelet analysis function, implemented
through PyWCT.
'''

def compute_wps (s, dt, periods=None, nbins=500,
                 normalise=True, mother=None) :
    '''
    Compute Wavelet Power Spectrum (WPS), Global Wavelet Power
    Spectrum (GWPS) and corresponding cone of influence (COI) from
    input time series.
    
    Parameters
    ----------
    
    s : ndarray
      time series to analyse
      
    dt : float
      sampling of the time series (in s)
      
    periods : ndarray
      Periods on which to compute the WPS. 
      Optional, if not given, WPS will be computed for
      periods ranging from 0.1 to 50 day. Must be
      given in days.
      
    nbins : int
      number of bins to consider if the periods vector
      is generated by the function. 

    normalise : bool 
      if set to ``True``, the computed GWPS will be 
      normalised by the maximum value. Optional,
      default ``True``.
 
    mother : object
      mother wavelet to consider. Optional, if set
      to ``None``, ``pycwt.Morlet (6)`` will be used.
     
    Returns
    -------
    tuple
      Tuple with WPS periods (in day), WPS, GWPS and COI. 
    '''
    if periods is None :
        periods = np.linspace (0.1, 50, 500)
    freqs = 1 / (periods*86400)
    if mother is None :
      mother = wavelet.Morlet(6)
    wave, scales, freqs, coi, fft, fftfreqs = wavelet.cwt(s, dt, 
                                                          freqs=freqs, wavelet=mother)
    wps = (np.abs(wave)) ** 2
    # Liu et al. 2007 normalisation
    wps[periods!=0] /= scales[periods!=0, None]
    coi_grid, periods_grid = np.meshgrid (coi, periods)
    gwps = np.copy (wps)
    gwps[periods_grid>coi_grid] = 0
    gwps = np.sum (gwps, axis=1)
    if normalise :
      gwps = gwps / np.amax (gwps) 
    coi = coi / 86400
    
    return periods, wps, gwps, coi

def find_prot_gwps (periods, gwps) :
  '''
  Return rotation period obtained 
  from GWPS (in current implementation,
  simply return the maximum).
  '''
  index = np.argmax (gwps)
  prot = periods[index]
  return prot

def fun_residual (param, x, y) :
  return np.abs (y - msap4.gauss (x, param[0], param[1], param[2])) 

def fit_gaussian (periods, ps, p_init, reduce_interval=True) :
  '''
  Perform a least-square fit with a Gaussian profile.
  '''
  a0 = np.amax (ps)
  param0 = np.array ([a0,
                     p_init,
                     0.1*p_init])
  bounds = (np.array([0.5*a0,
                     0.99*p_init,
                     0]),
            np.array ([4*a0,
                      1.01*p_init,
                      10*p_init])
             )
  if reduce_interval :
    mask = (periods>0.75*p_init)&(periods<1.25*p_init)
  else :
    mask = np.full (periods.size, True)
  result = least_squares(fun_residual, param0,
                         args=(periods[mask], ps[mask]), bounds=bounds)

  model = msap4.gauss (periods, result.x[0], result.x[1], result.x[2])
  return result.x, model, result.status

def compute_prot_err_gaussian_fit (periods, ps,
                                   n_profile=5, threshold=0.1,
                                   verbose=False) :
  '''
  Fit a series of gaussian profiles on a power 
  spectrum (GWPS or CS) and use it to extract 
  the rotation period estimate and corresponding error.
 
  Returns
  -------
  tuple
    The rotation period, its uncertainty and the parameters
    fitted for the ``n_profile`` profiles.
  '''
  param = np.full ((n_profile, 3), -1.)
  p_init = find_prot_gwps (periods, ps)
  # Ensuring that even if fitting does not work
  # we will get a prot value.
  param[0,1] = p_init
  max_init = np.amax (ps)
  ii = 0
  while ii < n_profile and np.amax (ps) > threshold*max_init :
    fitted_param, model, status = fit_gaussian (periods, ps, p_init)
    if verbose :
      print ('Fitted profile {}, param obtained:{}, status: {}'.format (ii, fitted_param, status))
    if status < 1 :
      break 
    ps = ps - model
    p_init = find_prot_gwps (periods, ps)
    param[ii,:] = fitted_param
    ii += 1 
  
  param = param[param[:,1]!=-1,:]
  prot, E_p = param[0,1], param[0,2]
  return prot, E_p, param

def plot_wps (t, periods, wps, gwps, coi,
              cmap='jet', shading='gouraud',
              color_coi='black', ylogscale=False,
              ax1=None, ax2=None, lw=1, normscale='log',
              vmin=None, vmax=None, filename=None, dpi=300,
              param_gauss=None, show_kepler_quarters=False,
              tref=0, figsize=(14, 8), show_contour=True,
              cmap_contour='cividis', levels=None) :
    '''
    Plot output from compute_wps. 
    '''

    if vmax is None :
      vmax = np.amax (wps)
    if normscale=='linear':
      if vmin is None :
        vmin = 0.
      norm = colors.Normalize(vmin=vmin, vmax=vmax) 
    if normscale=='log' :
      if vmin is None :
        vmin = 1e-4*np.amax (wps)
      norm = colors.LogNorm(vmin=vmin, vmax=vmax)

    if ax1 is None or ax2 is None :
      gs_kw = dict(width_ratios=[3, 1])
      fig, axs = plt.subplots (1, 2, figsize=figsize, gridspec_kw=gs_kw)
    else :
      fig = None 
      axs = (ax1, ax2)

    axs[0].pcolormesh (t, periods, wps, cmap=cmap,
                       shading=shading, norm=norm,
                       rasterized=True)

    if show_contour :
      if normscale=='log' :
        locator = ticker.LogLocator(base=10, subs=(1., 5.),
                                    )
      else :
        locator = ticker.MaxNLocator()
      if levels is not None :
        vmin_contour = levels[0]
      else :
        vmin_contour = vmin
      axs[0].contour (t, periods, wps, 
                      linestyles='-', cmap=cmap_contour,
                      vmin=vmin_contour, locator=locator, levels=levels, 
                      )

    axs[0].fill_between (t, np.minimum (coi, np.amax(periods)), 
                         np.maximum (coi, np.amax(periods)),
                         alpha=0.3, hatch='x', 
                         color=color_coi)


    axs[1].plot (gwps, periods, 
                 color='black', lw=lw)

    if param_gauss is not None :
      n_gauss = param_gauss.shape[0] 
      model = np.zeros (periods.size)
      for ii in range (n_gauss) :
        if param_gauss[ii,0]!=-1 : #checking a fit has been performed
          model += msap4.gauss (periods, *param_gauss[ii,:])
      axs[1].plot (model, periods, color='blue', lw=lw)

    axs[0].set_xlabel ('Time (day)')
    axs[0].set_ylabel ('Period (day)')
    axs[1].set_xlabel ('GWPS')

    if ylogscale :
      axs[0].set_yscale ('log')
      axs[1].set_yscale ('log')
      for ax in axs :
          ax.set_ylim (max (0.1, np.amin (periods)), np.amax(periods))
    else :
      for ax in axs :
          ax.set_ylim (np.amin (periods), np.amax(periods))

    if show_kepler_quarters :
      start, _ = msap4.get_kepler_quarters ()
      axs[0].vlines(start - tref, np.amin (periods), np.amax (periods), 
                colors='grey', linestyles='--', zorder=10)

    axs[0].set_xlim (t[0], t[-1])


    if filename is not None :
      plt.savefig (filename, dpi=dpi)
    
    return fig
