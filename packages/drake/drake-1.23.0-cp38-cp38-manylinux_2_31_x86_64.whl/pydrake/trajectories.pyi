from typing import Any, ClassVar, List, Optional, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common
import pydrake.common.eigen_geometry
import pydrake.math
import pydrake.polynomial
import pydrake.symbolic
import scipy.sparse
BezierCurve_: pydrake.common.cpp_template.TemplateClass
BsplineTrajectory_: pydrake.common.cpp_template.TemplateClass
CompositeTrajectory_: pydrake.common.cpp_template.TemplateClass
PathParameterizedTrajectory_: pydrake.common.cpp_template.TemplateClass
PiecewisePolynomial_: pydrake.common.cpp_template.TemplateClass
PiecewisePose_: pydrake.common.cpp_template.TemplateClass
PiecewiseQuaternionSlerp_: pydrake.common.cpp_template.TemplateClass
PiecewiseTrajectory_: pydrake.common.cpp_template.TemplateClass
StackedTrajectory_: pydrake.common.cpp_template.TemplateClass
Trajectory_: pydrake.common.cpp_template.TemplateClass

class BezierCurve(Trajectory):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, start_time: float, end_time: float, control_points: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def AsLinearInControlPoints(self, derivative_order: int = ...) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    @overload
    def AsLinearInControlPoints(self, n) -> Any: ...
    def BernsteinBasis(self, i: int, time: float, order: Optional[int] = ...) -> float: ...
    def ElevateOrder(self) -> None: ...
    def GetExpression(self, time: pydrake.symbolic.Variable = ...) -> numpy.ndarray[object[m,1]]: ...
    def control_points(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def order(self) -> int: ...
    def __copy__(self) -> BezierCurve: ...
    def __deepcopy__(self, arg0: dict) -> BezierCurve: ...

class BezierCurve_𝓣AutoDiffXd𝓤(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, start_time: float, end_time: float, control_points: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def AsLinearInControlPoints(self, derivative_order: int = ...) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    @overload
    def AsLinearInControlPoints(self, n) -> Any: ...
    def BernsteinBasis(self, i: int, time: pydrake.autodiffutils.AutoDiffXd, order: Optional[int] = ...) -> pydrake.autodiffutils.AutoDiffXd: ...
    def ElevateOrder(self) -> None: ...
    def GetExpression(self, time: pydrake.symbolic.Variable = ...) -> numpy.ndarray[object[m,1]]: ...
    def control_points(self) -> numpy.ndarray[object[m,n]]: ...
    def order(self) -> int: ...
    def __copy__(self) -> BezierCurve_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BezierCurve_𝓣AutoDiffXd𝓤: ...

class BezierCurve_𝓣Expression𝓤(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, start_time: float, end_time: float, control_points: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def AsLinearInControlPoints(self, derivative_order: int = ...) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    @overload
    def AsLinearInControlPoints(self, n) -> Any: ...
    def BernsteinBasis(self, i: int, time: pydrake.symbolic.Expression, order: Optional[int] = ...) -> pydrake.symbolic.Expression: ...
    def ElevateOrder(self) -> None: ...
    def GetExpression(self, time: pydrake.symbolic.Variable = ...) -> numpy.ndarray[object[m,1]]: ...
    def control_points(self) -> numpy.ndarray[object[m,n]]: ...
    def order(self) -> int: ...
    def __copy__(self) -> BezierCurve_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BezierCurve_𝓣Expression𝓤: ...

class BsplineTrajectory(Trajectory):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis, control_points: List[List[float]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis, control_points: List[numpy.ndarray[numpy.float64[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory: ...
    def CopyHead(self, n: int) -> BsplineTrajectory: ...
    def FinalValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InsertKnots(self, additional_knots: List[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis: ...
    def control_points(self) -> List[numpy.ndarray[numpy.float64[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis,List[numpy.ndarray[numpy.float64[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis,List[numpy.ndarray[numpy.float64[m,n]]]]) -> None: ...

class BsplineTrajectory_𝓣AutoDiffXd𝓤(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤, control_points: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class BsplineTrajectory_𝓣Expression𝓤(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣Expression𝓤, control_points: List[List[pydrake.symbolic.Expression]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣Expression𝓤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.symbolic.Expression]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_𝓣Expression𝓤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_𝓣Expression𝓤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_𝓣Expression𝓤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class CompositeTrajectory(PiecewiseTrajectory):
    def __init__(self, segments: List[Trajectory]) -> None: ...
    def segment(self, segment_index: int) -> Trajectory: ...
    def __copy__(self) -> CompositeTrajectory: ...
    def __deepcopy__(self, arg0: dict) -> CompositeTrajectory: ...

class CompositeTrajectory_𝓣AutoDiffXd𝓤(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, segments: List[Trajectory_𝓣AutoDiffXd𝓤]) -> None: ...
    def segment(self, segment_index: int) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> CompositeTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CompositeTrajectory_𝓣AutoDiffXd𝓤: ...

class CompositeTrajectory_𝓣Expression𝓤(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, segments: List[Trajectory_𝓣Expression𝓤]) -> None: ...
    def segment(self, segment_index: int) -> Trajectory_𝓣Expression𝓤: ...
    def __copy__(self) -> CompositeTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CompositeTrajectory_𝓣Expression𝓤: ...

class PathParameterizedTrajectory(Trajectory):
    def __init__(self, path: Trajectory, time_scaling: Trajectory) -> None: ...
    def Clone(self) -> Trajectory: ...
    def path(self) -> Trajectory: ...
    def time_scaling(self) -> Trajectory: ...
    def __copy__(self) -> PathParameterizedTrajectory: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory: ...

class PathParameterizedTrajectory_𝓣AutoDiffXd𝓤(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_𝓣AutoDiffXd𝓤, time_scaling: Trajectory_𝓣AutoDiffXd𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def path(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def time_scaling(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PathParameterizedTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_𝓣AutoDiffXd𝓤: ...

class PathParameterizedTrajectory_𝓣Expression𝓤(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_𝓣Expression𝓤, time_scaling: Trajectory_𝓣Expression𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def path(self) -> Trajectory_𝓣Expression𝓤: ...
    def time_scaling(self) -> Trajectory_𝓣Expression𝓤: ...
    def __copy__(self) -> PathParameterizedTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_𝓣Expression𝓤: ...

class PiecewisePolynomial(PiecewiseTrajectory):
    __fields__: ClassVar[tuple] = ...  # read-only
    _breaks: Any
    _polynomials: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[float]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial], arg1: List[float]) -> None: ...
    def AppendCubicHermiteSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial: ...
    def Clone(self) -> Trajectory: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial) -> None: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[float], samples: List[List[float]], samples_dot: List[List[float]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks, samples, samples_dot) -> Any: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m,n]]], samples_dot: List[numpy.ndarray[numpy.float64[m,n]]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[float], samples: List[List[float]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m,n]]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[float], samples: List[List[float]], sample_dot_at_start: numpy.ndarray[numpy.float64[m,n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m,n]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m,n]]], sample_dot_at_start: numpy.ndarray[numpy.float64[m,n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m,n]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[float], samples: List[List[float]], periodic_end_condition: bool = ...) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m,n]]], periodic_end: bool) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[float], samples: List[List[float]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m,n]]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[float], samples: List[List[float]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times, samples) -> Any: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[float], samples: List[numpy.ndarray[numpy.float64[m,n]]]) -> PiecewisePolynomial: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: float) -> None: ...
    def Transpose(self) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[float], samples: List[List[float]]) -> PiecewisePolynomial: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m,n]]]) -> PiecewisePolynomial: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial, tol: float, tol_type: pydrake.common.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: float) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial: ...
    def __add__(self, arg0: PiecewisePolynomial) -> PiecewisePolynomial: ...
    def __copy__(self) -> PiecewisePolynomial: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial: ...
    def __setattr__(self, arg0: str, arg1: object) -> None: ...

class PiecewisePolynomial_𝓣AutoDiffXd𝓤(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_𝓣AutoDiffXd𝓤], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], samples_dot: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks, samples, samples_dot) -> Any: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], samples_dot: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], periodic_end_condition: bool = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], periodic_end: bool) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times, samples) -> Any: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_𝓣AutoDiffXd𝓤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_𝓣AutoDiffXd𝓤, tol: float, tol_type: pydrake.common.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __add__(self, arg0: PiecewisePolynomial_𝓣AutoDiffXd𝓤) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...

class PiecewisePolynomial_𝓣Expression𝓤(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_𝓣Expression𝓤], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_𝓣Expression𝓤) -> None: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], samples_dot: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks, samples, samples_dot) -> Any: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], samples_dot: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], periodic_end_condition: bool = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], periodic_end: bool) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times, samples) -> Any: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.symbolic.Expression) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_𝓣Expression𝓤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_𝓣Expression𝓤, tol: float, tol_type: pydrake.common.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.symbolic.Expression) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __add__(self, arg0: PiecewisePolynomial_𝓣Expression𝓤) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __copy__(self) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_𝓣Expression𝓤: ...

class PiecewisePose(PiecewiseTrajectory):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial, orientation_trajectory: PiecewiseQuaternionSlerp) -> None: ...
    def GetAcceleration(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def GetPose(self, time: float) -> pydrake.math.RigidTransform: ...
    def GetVelocity(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def IsApprox(self, other: PiecewisePose, tol: float) -> bool: ...
    @classmethod
    def MakeCubicLinearWithEndLinearVelocity(cls, times: List[float], poses: List[pydrake.math.RigidTransform], start_vel: numpy.ndarray[numpy.float64[3,1]] = ..., end_vel: numpy.ndarray[numpy.float64[3,1]] = ...) -> PiecewisePose: ...
    @classmethod
    def MakeLinear(cls, times: List[float], poses: List[pydrake.math.RigidTransform]) -> PiecewisePose: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp: ...
    def get_position_trajectory(self) -> PiecewisePolynomial: ...
    def __copy__(self) -> PiecewisePose: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose: ...

class PiecewisePose_𝓣AutoDiffXd𝓤(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_𝓣AutoDiffXd𝓤, orientation_trajectory: PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤) -> None: ...
    def GetAcceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def GetVelocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_𝓣AutoDiffXd𝓤, tol: float) -> bool: ...
    @classmethod
    def MakeCubicLinearWithEndLinearVelocity(cls, times: List[pydrake.autodiffutils.AutoDiffXd], poses: List[pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤], start_vel: numpy.ndarray[object[3,1]] = ..., end_vel: numpy.ndarray[object[3,1]] = ...) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def MakeLinear(cls, times: List[pydrake.autodiffutils.AutoDiffXd], poses: List[pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤]) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...

class PiecewisePose_𝓣Expression𝓤(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_𝓣Expression𝓤, orientation_trajectory: PiecewiseQuaternionSlerp_𝓣Expression𝓤) -> None: ...
    def GetAcceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.symbolic.Expression) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def GetVelocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_𝓣Expression𝓤, tol: float) -> bool: ...
    @classmethod
    def MakeCubicLinearWithEndLinearVelocity(cls, times: List[pydrake.symbolic.Expression], poses: List[pydrake.math.RigidTransform_𝓣Expression𝓤], start_vel: numpy.ndarray[object[3,1]] = ..., end_vel: numpy.ndarray[object[3,1]] = ...) -> PiecewisePose_𝓣Expression𝓤: ...
    @classmethod
    def MakeLinear(cls, times: List[pydrake.symbolic.Expression], poses: List[pydrake.math.RigidTransform_𝓣Expression𝓤]) -> PiecewisePose_𝓣Expression𝓤: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_𝓣Expression𝓤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __copy__(self) -> PiecewisePose_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_𝓣Expression𝓤: ...

class PiecewiseQuaternionSlerp(PiecewiseTrajectory):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis]) -> None: ...
    @overload
    def Append(self, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    @overload
    def Append(self, time: float, rotation_matrix: pydrake.math.RotationMatrix) -> None: ...
    @overload
    def Append(self, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis) -> None: ...
    def angular_acceleration(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def angular_velocity(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def orientation(self, time: float) -> pydrake.common.eigen_geometry.Quaternion: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp: ...

class PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], quaternions: List[pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_𝓣AutoDiffXd𝓤]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_𝓣AutoDiffXd𝓤) -> None: ...
    def angular_acceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤: ...

class PiecewiseQuaternionSlerp_𝓣Expression𝓤(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], quaternions: List[pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[pydrake.math.RotationMatrix_𝓣Expression𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_𝓣Expression𝓤]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_𝓣Expression𝓤) -> None: ...
    def angular_acceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.symbolic.Expression) -> pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_𝓣Expression𝓤: ...

class PiecewiseTrajectory(Trajectory):
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> float: ...
    @overload
    def end_time(self, segment_index: int) -> float: ...
    @overload
    def end_time(self) -> float: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: float) -> int: ...
    def get_segment_times(self) -> List[float]: ...
    def is_time_in_range(self, t: float) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> float: ...
    @overload
    def start_time(self) -> float: ...

class PiecewiseTrajectory_𝓣AutoDiffXd𝓤(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def get_segment_times(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def is_time_in_range(self, t: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...

class PiecewiseTrajectory_𝓣Expression𝓤(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.symbolic.Expression) -> int: ...
    def get_segment_times(self) -> List[pydrake.symbolic.Expression]: ...
    def is_time_in_range(self, t: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def start_time(self) -> pydrake.symbolic.Expression: ...

class StackedTrajectory(Trajectory):
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory) -> None: ...
    def Clone(self) -> Trajectory: ...
    def __copy__(self) -> StackedTrajectory: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory: ...

class StackedTrajectory_𝓣AutoDiffXd𝓤(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_𝓣AutoDiffXd𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> StackedTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_𝓣AutoDiffXd𝓤: ...

class StackedTrajectory_𝓣Expression𝓤(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_𝓣Expression𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def __copy__(self) -> StackedTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_𝓣Expression𝓤: ...

class Trajectory:
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: float, derivative_order: int = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory: ...
    def cols(self) -> int: ...
    def end_time(self) -> float: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> float: ...
    def value(self, t: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def vector_values(self, t: List[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...

class Trajectory_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.autodiffutils.AutoDiffXd, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def value(self, t: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, t: List[pydrake.autodiffutils.AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...

class Trajectory_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.symbolic.Expression, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_𝓣Expression𝓤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.symbolic.Expression: ...
    def value(self, t: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, t: List[pydrake.symbolic.Expression]) -> numpy.ndarray[object[m,n]]: ...

class _MangledName:
    UNICODE_COMMA: ClassVar[str] = ...
    UNICODE_LEFT_BRACKET: ClassVar[str] = ...
    UNICODE_PERIOD: ClassVar[str] = ...
    UNICODE_RIGHT_BRACKET: ClassVar[str] = ...
    demangle: ClassVar[function] = ...
    mangle: ClassVar[function] = ...
    module_getattr: ClassVar[function] = ...

class _TemporaryName_N5drake12trajectories10TrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.autodiffutils.AutoDiffXd, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def value(self, t: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, t: List[pydrake.autodiffutils.AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...

class _TemporaryName_N5drake12trajectories10TrajectoryINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.symbolic.Expression, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_𝓣Expression𝓤: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.symbolic.Expression: ...
    def value(self, t: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, t: List[pydrake.symbolic.Expression]) -> numpy.ndarray[object[m,n]]: ...

class _TemporaryName_N5drake12trajectories11BezierCurveIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, start_time: float, end_time: float, control_points: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def AsLinearInControlPoints(self, derivative_order: int = ...) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    @overload
    def AsLinearInControlPoints(self, n) -> Any: ...
    def BernsteinBasis(self, i: int, time: pydrake.autodiffutils.AutoDiffXd, order: Optional[int] = ...) -> pydrake.autodiffutils.AutoDiffXd: ...
    def ElevateOrder(self) -> None: ...
    def GetExpression(self, time: pydrake.symbolic.Variable = ...) -> numpy.ndarray[object[m,1]]: ...
    def control_points(self) -> numpy.ndarray[object[m,n]]: ...
    def order(self) -> int: ...
    def __copy__(self) -> BezierCurve_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BezierCurve_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake12trajectories11BezierCurveINS_8symbolic10ExpressionEEE(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, start_time: float, end_time: float, control_points: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def AsLinearInControlPoints(self, derivative_order: int = ...) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    @overload
    def AsLinearInControlPoints(self, n) -> Any: ...
    def BernsteinBasis(self, i: int, time: pydrake.symbolic.Expression, order: Optional[int] = ...) -> pydrake.symbolic.Expression: ...
    def ElevateOrder(self) -> None: ...
    def GetExpression(self, time: pydrake.symbolic.Variable = ...) -> numpy.ndarray[object[m,1]]: ...
    def control_points(self) -> numpy.ndarray[object[m,n]]: ...
    def order(self) -> int: ...
    def __copy__(self) -> BezierCurve_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BezierCurve_𝓣Expression𝓤: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_𝓣AutoDiffXd𝓤, orientation_trajectory: PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤) -> None: ...
    def GetAcceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def GetVelocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_𝓣AutoDiffXd𝓤, tol: float) -> bool: ...
    @classmethod
    def MakeCubicLinearWithEndLinearVelocity(cls, times: List[pydrake.autodiffutils.AutoDiffXd], poses: List[pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤], start_vel: numpy.ndarray[object[3,1]] = ..., end_vel: numpy.ndarray[object[3,1]] = ...) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def MakeLinear(cls, times: List[pydrake.autodiffutils.AutoDiffXd], poses: List[pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤]) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_𝓣Expression𝓤, orientation_trajectory: PiecewiseQuaternionSlerp_𝓣Expression𝓤) -> None: ...
    def GetAcceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.symbolic.Expression) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def GetVelocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_𝓣Expression𝓤, tol: float) -> bool: ...
    @classmethod
    def MakeCubicLinearWithEndLinearVelocity(cls, times: List[pydrake.symbolic.Expression], poses: List[pydrake.math.RigidTransform_𝓣Expression𝓤], start_vel: numpy.ndarray[object[3,1]] = ..., end_vel: numpy.ndarray[object[3,1]] = ...) -> PiecewisePose_𝓣Expression𝓤: ...
    @classmethod
    def MakeLinear(cls, times: List[pydrake.symbolic.Expression], poses: List[pydrake.math.RigidTransform_𝓣Expression𝓤]) -> PiecewisePose_𝓣Expression𝓤: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_𝓣Expression𝓤: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __copy__(self) -> PiecewisePose_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_𝓣Expression𝓤: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤, control_points: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_𝓣AutoDiffXd𝓤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣Expression𝓤, control_points: List[List[pydrake.symbolic.Expression]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_𝓣Expression𝓤, control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.symbolic.Expression]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_𝓣Expression𝓤: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_𝓣Expression𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_𝓣Expression𝓤,List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_𝓣Expression𝓤,List[numpy.ndarray[object[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_𝓣AutoDiffXd𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> StackedTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_𝓣Expression𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def __copy__(self) -> StackedTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_𝓣Expression𝓤: ...

class _TemporaryName_N5drake12trajectories19CompositeTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, segments: List[Trajectory_𝓣AutoDiffXd𝓤]) -> None: ...
    def segment(self, segment_index: int) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> CompositeTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CompositeTrajectory_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake12trajectories19CompositeTrajectoryINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, segments: List[Trajectory_𝓣Expression𝓤]) -> None: ...
    def segment(self, segment_index: int) -> Trajectory_𝓣Expression𝓤: ...
    def __copy__(self) -> CompositeTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CompositeTrajectory_𝓣Expression𝓤: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_𝓣AutoDiffXd𝓤], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], samples_dot: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks, samples, samples_dot) -> Any: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], samples_dot: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], periodic_end_condition: bool = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]], periodic_end: bool) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times, samples) -> Any: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_𝓣AutoDiffXd𝓤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_𝓣AutoDiffXd𝓤, tol: float, tol_type: pydrake.common.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __add__(self, arg0: PiecewisePolynomial_𝓣AutoDiffXd𝓤) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_𝓣Expression𝓤], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_𝓣Expression𝓤) -> None: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], samples_dot: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks, samples, samples_dot) -> Any: ...
    @overload
    @classmethod
    def CubicHermite(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], samples_dot: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicShapePreserving(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], zero_end_point_derivatives: bool = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], sample_dot_at_start: numpy.ndarray[object[m,n]], sample_dot_at_end: numpy.ndarray[object[m,n]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], periodic_end_condition: bool = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def CubicWithContinuousSecondDerivatives(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]], periodic_end: bool) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def FirstOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times, samples) -> Any: ...
    @overload
    @classmethod
    def LagrangeInterpolatingPolynomial(cls, times: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.symbolic.Expression) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks, samples) -> Any: ...
    @overload
    @classmethod
    def ZeroOrderHold(cls, breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m,n]]]) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_𝓣Expression𝓤: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_𝓣Expression𝓤, tol: float, tol_type: pydrake.common.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.symbolic.Expression) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __add__(self, arg0: PiecewisePolynomial_𝓣Expression𝓤) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __copy__(self) -> PiecewisePolynomial_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_𝓣Expression𝓤: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def get_segment_times(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def is_time_in_range(self, t: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.symbolic.Expression) -> int: ...
    def get_segment_times(self) -> List[pydrake.symbolic.Expression]: ...
    def is_time_in_range(self, t: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def start_time(self) -> pydrake.symbolic.Expression: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], quaternions: List[pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_𝓣AutoDiffXd𝓤]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_𝓣AutoDiffXd𝓤) -> None: ...
    def angular_acceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.common.eigen_geometry.Quaternion_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], quaternions: List[pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[pydrake.math.RotationMatrix_𝓣Expression𝓤]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_𝓣Expression𝓤]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_𝓣Expression𝓤) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_𝓣Expression𝓤) -> None: ...
    def angular_acceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.symbolic.Expression) -> pydrake.common.eigen_geometry.Quaternion_𝓣Expression𝓤: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_𝓣Expression𝓤: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_𝓣AutoDiffXd𝓤, time_scaling: Trajectory_𝓣AutoDiffXd𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def path(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def time_scaling(self) -> Trajectory_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> PathParameterizedTrajectory_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_𝓣Expression𝓤, time_scaling: Trajectory_𝓣Expression𝓤) -> None: ...
    def Clone(self) -> Trajectory_𝓣Expression𝓤: ...
    def path(self) -> Trajectory_𝓣Expression𝓤: ...
    def time_scaling(self) -> Trajectory_𝓣Expression𝓤: ...
    def __copy__(self) -> PathParameterizedTrajectory_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_𝓣Expression𝓤: ...
