from typing import Any, ClassVar, List, Optional, Tuple

from typing import overload
import numpy
import pydrake.common.value
import pydrake.geometry
import pydrake.multibody.math
import pydrake.multibody.plant
import pydrake.multibody.tree
import pydrake.solvers
import pydrake.symbolic
import pydrake.systems.framework
import pydrake.trajectories

class CalcGridPointsOptions:
    __fields__: ClassVar[tuple] = ...  # read-only
    max_err: float
    max_iter: int
    max_seg_length: float
    min_points: int
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> CalcGridPointsOptions: ...
    def __deepcopy__(self, arg0: dict) -> CalcGridPointsOptions: ...

class CentroidalMomentumConstraint(pydrake.solvers.Constraint):
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_𝓣AutoDiffXd𝓤, model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], plant_context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, angular_only: bool) -> None: ...

class ContactWrench:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def F_Cb_W(self) -> pydrake.multibody.math.SpatialForce: ...
    @property
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    @property
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    @property
    def p_WCb_W(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class ContactWrenchFromForceInWorldFrameEvaluator(pydrake.solvers.EvaluatorBase):
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_𝓣AutoDiffXd𝓤, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, geometry_id_pair: Tuple[pydrake.geometry.GeometryId]) -> None: ...

class QuaternionEulerIntegrationConstraint(pydrake.solvers.Constraint):
    def __init__(self, allow_quaternion_negation: bool) -> None: ...
    @overload
    def ComposeVariable(self, quat1: numpy.ndarray[numpy.float64[4,1]], quat2: numpy.ndarray[numpy.float64[4,1]], angular_vel: numpy.ndarray[numpy.float64[3,1]], h: float) -> numpy.ndarray[numpy.float64[12,1]]: ...
    @overload
    def ComposeVariable(self, quat1: numpy.ndarray[object[4,1]], quat2: numpy.ndarray[object[4,1]], angular_vel: numpy.ndarray[object[3,1]], h: pydrake.symbolic.Variable) -> numpy.ndarray[object[12,1]]: ...
    @overload
    def ComposeVariable(self, quat1: numpy.ndarray[object[4,1]], quat2: numpy.ndarray[object[4,1]], angular_vel: numpy.ndarray[object[3,1]], h: pydrake.symbolic.Expression) -> numpy.ndarray[object[12,1]]: ...
    def allow_quaternion_negation(self) -> bool: ...

class SpatialVelocityConstraint(pydrake.solvers.Constraint):
    class AngularVelocityBounds:
        magnitude_lower: float
        magnitude_upper: float
        reference_direction: numpy.ndarray[numpy.float64[3,1]]
        theta_bound: float
        def __init__(self) -> None: ...
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_𝓣AutoDiffXd𝓤, frameA: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, v_AC_lower: numpy.ndarray[numpy.float64[3,1]], v_AC_upper: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BCo: numpy.ndarray[numpy.float64[3,1]], plant_context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, w_AC_bounds = ...) -> None: ...

class StaticEquilibriumProblem:
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_𝓣AutoDiffXd𝓤, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, ignored_collision_pairs: Set[Tuple[pydrake.geometry.GeometryId,pydrake.geometry.GeometryId]]) -> None: ...
    def GetContactWrenchSolution(self, result: pydrake.solvers.MathematicalProgramResult) -> List[ContactWrench]: ...
    def UpdateComplementarityTolerance(self, tol: float) -> None: ...
    def get_mutable_prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def q_vars(self) -> numpy.ndarray[object[m,1]]: ...
    def u_vars(self) -> numpy.ndarray[object[m,1]]: ...

class Toppra:
    def __init__(self, path: pydrake.trajectories.Trajectory, plant: pydrake.multibody.plant.MultibodyPlant, gridpoints: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def AddFrameAccelerationLimit(self, constraint_frame: pydrake.multibody.tree.Frame, lower_limit: numpy.ndarray[numpy.float64[6,1]], upper_limit: numpy.ndarray[numpy.float64[6,1]], discretization: ToppraDiscretization = ...) -> Tuple[pydrake.solvers.Binding𝓣LinearConstraint𝓤,pydrake.solvers.Binding𝓣LinearConstraint𝓤]: ...
    @overload
    def AddFrameAccelerationLimit(self, constraint_frame: pydrake.multibody.tree.Frame, lower_limit: pydrake.trajectories.Trajectory, upper_limit: pydrake.trajectories.Trajectory, discretization: ToppraDiscretization = ...) -> Tuple[pydrake.solvers.Binding𝓣LinearConstraint𝓤,pydrake.solvers.Binding𝓣LinearConstraint𝓤]: ...
    @overload
    def AddFrameTranslationalSpeedLimit(self, constraint_frame: pydrake.multibody.tree.Frame, upper_limit: float) -> pydrake.solvers.Binding𝓣BoundingBoxConstraint𝓤: ...
    @overload
    def AddFrameTranslationalSpeedLimit(self, constraint_frame: pydrake.multibody.tree.Frame, upper_limit: pydrake.trajectories.Trajectory) -> pydrake.solvers.Binding𝓣BoundingBoxConstraint𝓤: ...
    def AddFrameVelocityLimit(self, constraint_frame: pydrake.multibody.tree.Frame, lower_limit: numpy.ndarray[numpy.float64[6,1]], upper_limit: numpy.ndarray[numpy.float64[6,1]]) -> pydrake.solvers.Binding𝓣BoundingBoxConstraint𝓤: ...
    def AddJointAccelerationLimit(self, lower_limit: numpy.ndarray[numpy.float64[m,1]], upper_limit: numpy.ndarray[numpy.float64[m,1]], discretization: ToppraDiscretization = ...) -> Tuple[pydrake.solvers.Binding𝓣LinearConstraint𝓤,pydrake.solvers.Binding𝓣LinearConstraint𝓤]: ...
    def AddJointTorqueLimit(self, lower_limit: numpy.ndarray[numpy.float64[m,1]], upper_limit: numpy.ndarray[numpy.float64[m,1]], discretization: ToppraDiscretization = ...) -> Tuple[pydrake.solvers.Binding𝓣LinearConstraint𝓤,pydrake.solvers.Binding𝓣LinearConstraint𝓤]: ...
    def AddJointVelocityLimit(self, lower_limit: numpy.ndarray[numpy.float64[m,1]], upper_limit: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.solvers.Binding𝓣BoundingBoxConstraint𝓤: ...
    @classmethod
    def CalcGridPoints(cls, path: pydrake.trajectories.Trajectory, options: CalcGridPointsOptions) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def SolvePathParameterization(self) -> Optional[pydrake.trajectories.PiecewisePolynomial]: ...

class ToppraDiscretization:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kCollocation: ClassVar[ToppraDiscretization] = ...
    kInterpolation: ClassVar[ToppraDiscretization] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class _TemporaryName_N5drake5ValueINS_9multibody13ContactWrenchEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactWrench) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactWrench: ...
    def get_value(self) -> ContactWrench: ...
    def set_value(self, arg0: ContactWrench) -> None: ...
