from typing import Any, Callable, ClassVar, List, Optional, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common
import pydrake.common.value
import pydrake.geometry
import pydrake.math
import pydrake.multibody.math
import pydrake.multibody.tree
import pydrake.symbolic
import pydrake.systems.framework
import scipy.sparse
ContactResults_: pydrake.common.cpp_template.TemplateClass
CoulombFriction_: pydrake.common.cpp_template.TemplateClass
ExternallyAppliedSpatialForceMultiplexer_: pydrake.common.cpp_template.TemplateClass
ExternallyAppliedSpatialForce_: pydrake.common.cpp_template.TemplateClass
HydroelasticContactInfo_: pydrake.common.cpp_template.TemplateClass
MultibodyPlant_: pydrake.common.cpp_template.TemplateClass
PointPairContactInfo_: pydrake.common.cpp_template.TemplateClass
Propeller_: pydrake.common.cpp_template.TemplateClass
Wing_: pydrake.common.cpp_template.TemplateClass

class ContactModel:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kHydroelastic: ClassVar[ContactModel] = ...
    kHydroelasticWithFallback: ClassVar[ContactModel] = ...
    kHydroelasticsOnly: ClassVar[ContactModel] = ...
    kPoint: ClassVar[ContactModel] = ...
    kPointContactOnly: ClassVar[ContactModel] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ContactResults:
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo],bool]) -> ContactResults: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo: ...
    def __copy__(self) -> ContactResults: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults: ...

class ContactResultsToLcmSystem(pydrake.systems.framework.LeafSystem):
    def __init__(self, *args, **kwargs) -> None: ...
    def get_contact_result_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_lcm_message_output_port(self) -> pydrake.systems.framework.OutputPort: ...

class ContactResults_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_𝓣AutoDiffXd𝓤],bool]) -> ContactResults_𝓣AutoDiffXd𝓤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> ContactResults_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_𝓣AutoDiffXd𝓤: ...

class ContactResults_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_𝓣Expression𝓤],bool]) -> ContactResults_𝓣Expression𝓤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_𝓣Expression𝓤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_𝓣Expression𝓤: ...
    def __copy__(self) -> ContactResults_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_𝓣Expression𝓤: ...

class CoulombFriction:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: float, dynamic_friction: float) -> None: ...
    def dynamic_friction(self) -> float: ...
    def static_friction(self) -> float: ...
    def __copy__(self) -> CoulombFriction: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class CoulombFriction_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def dynamic_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def static_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> CoulombFriction_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]: ...
    def __setstate__(self, arg0: Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]) -> None: ...

class CoulombFriction_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -> None: ...
    def dynamic_friction(self) -> pydrake.symbolic.Expression: ...
    def static_friction(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> CoulombFriction_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_𝓣Expression𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]: ...
    def __setstate__(self, arg0: Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]) -> None: ...

class DeformableBodyId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> DeformableBodyId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: DeformableBodyId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: DeformableBodyId) -> bool: ...
    def __ne__(self, arg0: DeformableBodyId) -> bool: ...

class DeformableModel(PhysicalModel):
    def __init__(self, *args, **kwargs) -> None: ...
    def GetBodyId(self, *args, **kwargs) -> Any: ...
    def GetDiscreteStateIndex(self, *args, **kwargs) -> Any: ...
    def GetGeometryId(self, *args, **kwargs) -> Any: ...
    def GetReferencePositions(self, *args, **kwargs) -> Any: ...
    def RegisterDeformableBody(self, *args, **kwargs) -> Any: ...
    def SetWallBoundaryCondition(self, *args, **kwargs) -> Any: ...
    def num_bodies(self) -> int: ...
    def vertex_positions_port(self) -> pydrake.systems.framework.OutputPort: ...

class DiscreteContactSolver:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kSap: ClassVar[DiscreteContactSolver] = ...
    kTamsi: ClassVar[DiscreteContactSolver] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExternallyAppliedSpatialForce:
    F_Bq_W: pydrake.multibody.math.SpatialForce
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce: ...

class ExternallyAppliedSpatialForceMultiplexer(pydrake.systems.framework.LeafSystem):
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForceMultiplexer_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForceMultiplexer_𝓣Expression𝓤(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤: ...

class ExternallyAppliedSpatialForce_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_𝓣Expression𝓤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_𝓣Expression𝓤: ...

class HydroelasticContactInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface: ...
    def __copy__(self) -> HydroelasticContactInfo: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo: ...

class HydroelasticContactInfo_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...

class HydroelasticContactInfo_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    def contact_surface(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> HydroelasticContactInfo_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_𝓣Expression𝓤: ...

class MultibodyPlant(pydrake.systems.framework.LeafSystem):
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint, joint1: pydrake.multibody.tree.Joint, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement) -> pydrake.multibody.tree.ForceElement: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame) -> pydrake.multibody.tree.Frame: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint) -> pydrake.multibody.tree.Joint: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, model: PhysicalModel) -> None: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBp_B: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> pydrake.multibody.math.SpatialAcceleration: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context, forces: pydrake.multibody.tree.MultibodyForces) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context, forces: pydrake.multibody.tree.MultibodyForces) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context, known_vdot: numpy.ndarray[numpy.float64[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context, frame_B: pydrake.multibody.tree.Frame, p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBp_B: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context, frame_B: pydrake.multibody.tree.Frame, p_BQi: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context, frame_A: pydrake.multibody.tree.Frame, frame_B: pydrake.multibody.tree.Frame) -> pydrake.math.RigidTransform: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context, known_vdot: numpy.ndarray[numpy.float64[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context, frame_F: pydrake.multibody.tree.Frame, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context, p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context) -> float: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> float: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body) -> pydrake.math.RigidTransform: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body) -> pydrake.multibody.math.SpatialVelocity: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body) -> List[pydrake.multibody.tree.Body]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body) -> pydrake.math.RigidTransform: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeQDotToVelocityMap(self, context: pydrake.systems.framework.Context) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeVelocityToQDotMap(self, context: pydrake.systems.framework.Context) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context, qdot: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context, v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context, state: pydrake.systems.framework.State) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body, X_WB: pydrake.math.RigidTransform) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body, V_WB: pydrake.multibody.math.SpatialVelocity, context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context, q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]], q: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context, v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[numpy.float64[m,1]], v: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame, frame_on_child_M: pydrake.multibody.tree.Frame, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self) -> List[PhysicalModel]: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame: ...

class MultibodyPlantConfig:
    __fields__: ClassVar[tuple] = ...  # read-only
    adjacent_bodies_collision_filters: bool
    contact_model: str
    contact_surface_representation: str
    discrete_contact_solver: str
    penetration_allowance: float
    sap_near_rigid_threshold: float
    stiction_tolerance: float
    time_step: float
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MultibodyPlantConfig: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyPlantConfig: ...

class MultibodyPlant_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤, joint1: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_𝓣AutoDiffXd𝓤) -> pydrake.multibody.tree.ForceElement_𝓣AutoDiffXd𝓤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣AutoDiffXd𝓤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_F: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣AutoDiffXd𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣AutoDiffXd𝓤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> List[pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_𝓣AutoDiffXd𝓤) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, state: pydrake.systems.framework.State_𝓣AutoDiffXd𝓤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_WB: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, V_WB: pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_on_child_M: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_𝓣AutoDiffXd𝓤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_𝓣AutoDiffXd𝓤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣AutoDiffXd𝓤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣AutoDiffXd𝓤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_𝓣AutoDiffXd𝓤: ...

class MultibodyPlant_𝓣Expression𝓤(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_𝓣Expression𝓤, joint1: pydrake.multibody.tree.Joint_𝓣Expression𝓤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_𝓣Expression𝓤) -> pydrake.multibody.tree.ForceElement_𝓣Expression𝓤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_𝓣Expression𝓤) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_𝓣Expression𝓤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣Expression𝓤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_F: pydrake.multibody.tree.Frame_𝓣Expression𝓤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_𝓣Expression𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣Expression𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣Expression𝓤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.symbolic.Expression: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_𝓣Expression𝓤]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> List[pydrake.multibody.tree.Body_𝓣Expression𝓤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_𝓣Expression𝓤) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, state: pydrake.systems.framework.State_𝓣Expression𝓤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_WB: pydrake.math.RigidTransform_𝓣Expression𝓤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, V_WB: pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_on_child_M: pydrake.multibody.tree.Frame_𝓣Expression𝓤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_𝓣Expression𝓤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_𝓣Expression𝓤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣Expression𝓤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣Expression𝓤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_𝓣Expression𝓤: ...

class PhysicalModel:
    def __init__(self, *args, **kwargs) -> None: ...

class PointPairContactInfo:
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[numpy.float64[3,1]], p_WC: numpy.ndarray[numpy.float64[3,1]], separation_speed: float, slip_speed: float, point_pair: pydrake.geometry.PenetrationAsPointPair) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> float: ...
    def slip_speed(self) -> float: ...
    def __copy__(self) -> PointPairContactInfo: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo: ...

class PointPairContactInfo_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.autodiffutils.AutoDiffXd, slip_speed: pydrake.autodiffutils.AutoDiffXd, point_pair: pydrake.geometry.PenetrationAsPointPair_𝓣AutoDiffXd𝓤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_𝓣AutoDiffXd𝓤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def slip_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> PointPairContactInfo_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_𝓣AutoDiffXd𝓤: ...

class PointPairContactInfo_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.symbolic.Expression, slip_speed: pydrake.symbolic.Expression, point_pair: pydrake.geometry.PenetrationAsPointPair_𝓣Expression𝓤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_𝓣Expression𝓤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.symbolic.Expression: ...
    def slip_speed(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> PointPairContactInfo_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_𝓣Expression𝓤: ...

class Propeller(pydrake.systems.framework.LeafSystem):
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def num_propellers(self) -> int: ...

class PropellerInfo:
    X_BP: pydrake.math.RigidTransform
    body_index: pydrake.multibody.tree.BodyIndex
    moment_ratio: float
    thrust_ratio: float
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    def __copy__(self) -> PropellerInfo: ...
    def __deepcopy__(self, arg0: dict) -> PropellerInfo: ...

class Propeller_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def num_propellers(self) -> int: ...

class Propeller_𝓣Expression𝓤(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def num_propellers(self) -> int: ...

class Wing(pydrake.systems.framework.LeafSystem):
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, plant: MultibodyPlant, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort: ...

class Wing_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_𝓣AutoDiffXd𝓤, plant: MultibodyPlant_𝓣AutoDiffXd𝓤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_𝓣AutoDiffXd𝓤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...

class Wing_𝓣Expression𝓤(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_𝓣Expression𝓤, plant: MultibodyPlant_𝓣Expression𝓤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_𝓣Expression𝓤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...

class _MangledName:
    UNICODE_COMMA: ClassVar[str] = ...
    UNICODE_LEFT_BRACKET: ClassVar[str] = ...
    UNICODE_PERIOD: ClassVar[str] = ...
    UNICODE_RIGHT_BRACKET: ClassVar[str] = ...
    demangle: ClassVar[function] = ...
    mangle: ClassVar[function] = ...
    module_getattr: ClassVar[function] = ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults_𝓣AutoDiffXd𝓤: ...
    def get_value(self) -> ContactResults_𝓣AutoDiffXd𝓤: ...
    def set_value(self, arg0: ContactResults_𝓣AutoDiffXd𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults_𝓣Expression𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults_𝓣Expression𝓤: ...
    def get_value(self) -> ContactResults_𝓣Expression𝓤: ...
    def set_value(self, arg0: ContactResults_𝓣Expression𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults: ...
    def get_value(self) -> ContactResults: ...
    def set_value(self, arg0: ContactResults) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction_𝓣AutoDiffXd𝓤: ...
    def get_value(self) -> CoulombFriction_𝓣AutoDiffXd𝓤: ...
    def set_value(self, arg0: CoulombFriction_𝓣AutoDiffXd𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction_𝓣Expression𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction_𝓣Expression𝓤: ...
    def get_value(self) -> CoulombFriction_𝓣Expression𝓤: ...
    def set_value(self, arg0: CoulombFriction_𝓣Expression𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction: ...
    def get_value(self) -> CoulombFriction: ...
    def set_value(self, arg0: CoulombFriction) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...
    def get_value(self) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...
    def set_value(self, arg0: HydroelasticContactInfo_𝓣AutoDiffXd𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo_𝓣Expression𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo_𝓣Expression𝓤: ...
    def get_value(self) -> HydroelasticContactInfo_𝓣Expression𝓤: ...
    def set_value(self, arg0: HydroelasticContactInfo_𝓣Expression𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo: ...
    def get_value(self) -> HydroelasticContactInfo: ...
    def set_value(self, arg0: HydroelasticContactInfo) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤: ...
    def get_value(self) -> ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce_𝓣Expression𝓤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce_𝓣Expression𝓤: ...
    def get_value(self) -> ExternallyAppliedSpatialForce_𝓣Expression𝓤: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce_𝓣Expression𝓤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce: ...
    def get_value(self) -> ExternallyAppliedSpatialForce: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS4_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEESaIS9_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEESaIS6_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce_𝓣Expression𝓤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce_𝓣Expression𝓤]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce_𝓣Expression𝓤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceIdEESaIS4_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce]) -> None: ...

class _TemporaryName_N5drake9multibody14ContactResultsIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_𝓣AutoDiffXd𝓤],bool]) -> ContactResults_𝓣AutoDiffXd𝓤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> ContactResults_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody14ContactResultsINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_𝓣Expression𝓤],bool]) -> ContactResults_𝓣Expression𝓤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_𝓣Expression𝓤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_𝓣Expression𝓤: ...
    def __copy__(self) -> ContactResults_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody14MultibodyPlantIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤, joint1: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_𝓣AutoDiffXd𝓤) -> pydrake.multibody.tree.ForceElement_𝓣AutoDiffXd𝓤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣AutoDiffXd𝓤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_𝓣AutoDiffXd𝓤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, frame_F: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_𝓣AutoDiffXd𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣AutoDiffXd𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣AutoDiffXd𝓤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> List[pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_𝓣AutoDiffXd𝓤) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, state: pydrake.systems.framework.State_𝓣AutoDiffXd𝓤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, X_WB: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤, V_WB: pydrake.multibody.math.SpatialVelocity_𝓣AutoDiffXd𝓤, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, frame_on_child_M: pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_𝓣AutoDiffXd𝓤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_𝓣AutoDiffXd𝓤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_𝓣AutoDiffXd𝓤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣AutoDiffXd𝓤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣AutoDiffXd𝓤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣AutoDiffXd𝓤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_𝓣AutoDiffXd𝓤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody14MultibodyPlantINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_𝓣Expression𝓤, joint1: pydrake.multibody.tree.Joint_𝓣Expression𝓤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_𝓣Expression𝓤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_𝓣Expression𝓤) -> pydrake.multibody.tree.ForceElement_𝓣Expression𝓤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_𝓣Expression𝓤) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_𝓣Expression𝓤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣Expression𝓤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, forces: pydrake.multibody.tree.MultibodyForces_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_E: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_A: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_B: pydrake.multibody.tree.Frame_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_𝓣Expression𝓤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, frame_F: pydrake.multibody.tree.Frame_𝓣Expression𝓤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_𝓣Expression𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣Expression𝓤: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_𝓣Expression𝓤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.symbolic.Expression: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.symbolic.Expression: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_𝓣Expression𝓤]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> List[pydrake.multibody.tree.Body_𝓣Expression𝓤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_𝓣Expression𝓤) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, state: pydrake.systems.framework.State_𝓣Expression𝓤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, X_WB: pydrake.math.RigidTransform_𝓣Expression𝓤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_𝓣Expression𝓤, V_WB: pydrake.multibody.math.SpatialVelocity_𝓣Expression𝓤, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_𝓣Expression𝓤, frame_on_child_M: pydrake.multibody.tree.Frame_𝓣Expression𝓤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_𝓣Expression𝓤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_𝓣Expression𝓤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_𝓣Expression𝓤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_𝓣Expression𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_𝓣Expression𝓤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_𝓣Expression𝓤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣Expression𝓤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_𝓣Expression𝓤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_𝓣Expression𝓤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody15CoulombFrictionIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def dynamic_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def static_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> CoulombFriction_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_𝓣AutoDiffXd𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]: ...
    def __setstate__(self, arg0: Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake9multibody15CoulombFrictionINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -> None: ...
    def dynamic_friction(self) -> pydrake.symbolic.Expression: ...
    def static_friction(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> CoulombFriction_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_𝓣Expression𝓤: ...
    def __getstate__(self) -> Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]: ...
    def __setstate__(self, arg0: Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]) -> None: ...

class _TemporaryName_N5drake9multibody20PointPairContactInfoIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.autodiffutils.AutoDiffXd, slip_speed: pydrake.autodiffutils.AutoDiffXd, point_pair: pydrake.geometry.PenetrationAsPointPair_𝓣AutoDiffXd𝓤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_𝓣AutoDiffXd𝓤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def slip_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> PointPairContactInfo_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody20PointPairContactInfoINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.symbolic.Expression, slip_speed: pydrake.symbolic.Expression, point_pair: pydrake.geometry.PenetrationAsPointPair_𝓣Expression𝓤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_𝓣Expression𝓤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.symbolic.Expression: ...
    def slip_speed(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> PointPairContactInfo_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody23HydroelasticContactInfoIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody23HydroelasticContactInfoINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_𝓣Expression𝓤: ...
    def contact_surface(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> HydroelasticContactInfo_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_𝓣AutoDiffXd𝓤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_𝓣Expression𝓤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_𝓣Expression𝓤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody40ExternallyAppliedSpatialForceMultiplexerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class _TemporaryName_N5drake9multibody40ExternallyAppliedSpatialForceMultiplexerINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class _TemporaryName_N5drake9multibody4WingIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_𝓣AutoDiffXd𝓤, plant: MultibodyPlant_𝓣AutoDiffXd𝓤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_𝓣AutoDiffXd𝓤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...

class _TemporaryName_N5drake9multibody4WingINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_𝓣Expression𝓤, plant: MultibodyPlant_𝓣Expression𝓤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_𝓣Expression𝓤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...

class _TemporaryName_N5drake9multibody9PropellerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def num_propellers(self) -> int: ...

class _TemporaryName_N5drake9multibody9PropellerINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def num_propellers(self) -> int: ...

def AddMultibodyPlant(config: MultibodyPlantConfig, builder: pydrake.systems.framework.DiagramBuilder) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, plant: MultibodyPlant, scene_graph: pydrake.geometry.SceneGraph = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, time_step: float, scene_graph: pydrake.geometry.SceneGraph = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_𝓣AutoDiffXd𝓤, plant: MultibodyPlant_𝓣AutoDiffXd𝓤, scene_graph: pydrake.geometry.SceneGraph_𝓣AutoDiffXd𝓤 = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_𝓣AutoDiffXd𝓤, time_step: float, scene_graph: pydrake.geometry.SceneGraph_𝓣AutoDiffXd𝓤 = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_𝓣Expression𝓤, plant: MultibodyPlant_𝓣Expression𝓤, scene_graph: pydrake.geometry.SceneGraph_𝓣Expression𝓤 = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_𝓣Expression𝓤, time_step: float, scene_graph: pydrake.geometry.SceneGraph_𝓣Expression𝓤 = ...) -> tuple: ...
def ApplyMultibodyPlantConfig(config: MultibodyPlantConfig, plant: MultibodyPlant) -> None: ...
@overload
def CalcContactFrictionFromSurfaceProperties(surface_properties1: CoulombFriction, surface_properties2: CoulombFriction) -> CoulombFriction: ...
@overload
def CalcContactFrictionFromSurfaceProperties(surface_properties1: CoulombFriction_𝓣AutoDiffXd𝓤, surface_properties2: CoulombFriction_𝓣AutoDiffXd𝓤) -> CoulombFriction_𝓣AutoDiffXd𝓤: ...
@overload
def CalcContactFrictionFromSurfaceProperties(surface_properties1: CoulombFriction_𝓣Expression𝓤, surface_properties2: CoulombFriction_𝓣Expression𝓤) -> CoulombFriction_𝓣Expression𝓤: ...
def ConnectContactResultsToDrakeVisualizer(*args, **kwargs) -> Any: ...
