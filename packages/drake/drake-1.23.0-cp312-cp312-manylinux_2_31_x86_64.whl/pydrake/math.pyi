from typing import Any, Callable, ClassVar, List, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common
import pydrake.common.eigen_geometry
import pydrake.common.value
import pydrake.symbolic
BsplineBasis_: pydrake.common.cpp_template.TemplateClass
RigidTransform_: pydrake.common.cpp_template.TemplateClass
RollPitchYaw_: pydrake.common.cpp_template.TemplateClass
RotationMatrix_: pydrake.common.cpp_template.TemplateClass
_OPERATORS: tuple
_OPERATORS_REVERSE: dict
_add_repr_functions: function
_best_effort_rich_compare: function
_drake_vectorize: function
_indented_repr: function
_is_elementwise_comparison_error: function
_pretty_class_name: function
_rigid_transform_repr: function
_roll_pitch_yaw_repr: function
_rotation_matrix_repr: function
_sym_cls_list: tuple
eq: numpy.vectorize
ge: numpy.vectorize
gt: numpy.vectorize
le: numpy.vectorize
lt: numpy.vectorize
ne: numpy.vectorize

class BarycentricMesh:
    def __init__(self, arg0: List[Set[float]]) -> None: ...
    def Eval(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], arg1: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def EvalBarycentricWeights(self, arg0: numpy.ndarray[numpy.float64[m,1]]) -> Tuple[numpy.ndarray[numpy.int32[m,1]],numpy.ndarray[numpy.float64[m,1]]]: ...
    def MeshValuesFrom(self, arg0: Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def get_all_mesh_points(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def get_input_grid(self) -> List[Set[float]]: ...
    def get_input_size(self) -> int: ...
    def get_mesh_point(self, arg0: int) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def get_num_interpolants(self) -> int: ...
    def get_num_mesh_points(self) -> int: ...

class BsplineBasis:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, order: int, knots: List[float]) -> None: ...
    @overload
    def __init__(self, order: int, num_basis_functions: int, type: KnotVectorType = ..., initial_parameter_value: float = ..., final_parameter_value: float = ...) -> None: ...
    @overload
    def __init__(self, other: BsplineBasis) -> None: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_interval) -> List[int]: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_value: float) -> List[int]: ...
    def EvaluateBasisFunctionI(self, i: int, parameter_value: float) -> float: ...
    def EvaluateCurve(self, control_points: List[numpy.ndarray[numpy.float64[m,1]]], parameter_value: float) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def FindContainingInterval(self, parameter_value: float) -> int: ...
    def degree(self) -> int: ...
    def final_parameter_value(self) -> float: ...
    def initial_parameter_value(self) -> float: ...
    def knots(self) -> List[float]: ...
    def num_basis_functions(self) -> int: ...
    def order(self) -> int: ...
    def __getstate__(self) -> Tuple[int,List[float]]: ...
    def __setstate__(self, arg0: Tuple[int,List[float]]) -> None: ...

class BsplineBasis_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, order: int, knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, order: int, num_basis_functions: int, type: KnotVectorType = ..., initial_parameter_value: pydrake.autodiffutils.AutoDiffXd = ..., final_parameter_value: pydrake.autodiffutils.AutoDiffXd = ...) -> None: ...
    @overload
    def __init__(self, other: BsplineBasis_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_interval) -> List[int]: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_value: pydrake.autodiffutils.AutoDiffXd) -> List[int]: ...
    def EvaluateBasisFunctionI(self, i: int, parameter_value: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCurve(self, control_points: List[numpy.ndarray[object[m,1]]], parameter_value: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,1]]: ...
    def FindContainingInterval(self, parameter_value: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def degree(self) -> int: ...
    def final_parameter_value(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def initial_parameter_value(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def knots(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def num_basis_functions(self) -> int: ...
    def order(self) -> int: ...
    def __getstate__(self) -> Tuple[int,List[pydrake.autodiffutils.AutoDiffXd]]: ...
    def __setstate__(self, arg0: Tuple[int,List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...

class BsplineBasis_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, order: int, knots: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, order: int, num_basis_functions: int, type: KnotVectorType = ..., initial_parameter_value: pydrake.symbolic.Expression = ..., final_parameter_value: pydrake.symbolic.Expression = ...) -> None: ...
    @overload
    def __init__(self, other: BsplineBasis_ð“£Expressionð“¤) -> None: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_interval) -> List[int]: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_value: pydrake.symbolic.Expression) -> List[int]: ...
    def EvaluateBasisFunctionI(self, i: int, parameter_value: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def EvaluateCurve(self, control_points: List[numpy.ndarray[object[m,1]]], parameter_value: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,1]]: ...
    def FindContainingInterval(self, parameter_value: pydrake.symbolic.Expression) -> int: ...
    def degree(self) -> int: ...
    def final_parameter_value(self) -> pydrake.symbolic.Expression: ...
    def initial_parameter_value(self) -> pydrake.symbolic.Expression: ...
    def knots(self) -> List[pydrake.symbolic.Expression]: ...
    def num_basis_functions(self) -> int: ...
    def order(self) -> int: ...
    def __getstate__(self) -> Tuple[int,List[pydrake.symbolic.Expression]]: ...
    def __setstate__(self, arg0: Tuple[int,List[pydrake.symbolic.Expression]]) -> None: ...

class KnotVectorType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kClampedUniform: ClassVar[KnotVectorType] = ...
    kUniform: ClassVar[KnotVectorType] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class NumericalGradientMethod:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kBackward: ClassVar[NumericalGradientMethod] = ...
    kCentral: ClassVar[NumericalGradientMethod] = ...
    kForward: ClassVar[NumericalGradientMethod] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class NumericalGradientOption:
    def __init__(self, method: NumericalGradientMethod, function_accuracy: float = ...) -> None: ...
    def NumericalGradientMethod(self) -> NumericalGradientMethod: ...
    def perturbation_size(self) -> float: ...

class RigidTransform:
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: RigidTransform) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion, p: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis, p: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, p: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, pose: pydrake.common.eigen_geometry.Isometry3) -> None: ...
    @overload
    def __init__(self, pose: numpy.ndarray[numpy.float64[m,n]]) -> None: ...
    def GetAsIsometry3(self) -> pydrake.common.eigen_geometry.Isometry3: ...
    def GetAsMatrix34(self) -> numpy.ndarray[numpy.float64[3,4]]: ...
    def GetAsMatrix4(self) -> numpy.ndarray[numpy.float64[4,4]]: ...
    def GetMaximumAbsoluteDifference(self, other: RigidTransform) -> float: ...
    def GetMaximumAbsoluteTranslationDifference(self, other: RigidTransform) -> float: ...
    @classmethod
    def Identity(cls) -> RigidTransform: ...
    def InvertAndCompose(self, other: RigidTransform) -> RigidTransform: ...
    def IsExactlyEqualTo(self, other: RigidTransform) -> bool: ...
    def IsExactlyIdentity(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RigidTransform, tolerance: float) -> bool: ...
    @overload
    def IsNearlyIdentity(self, translation_tolerance: float) -> bool: ...
    @overload
    def IsNearlyIdentity(self) -> Any: ...
    def SetFromIsometry3(self, pose: pydrake.common.eigen_geometry.Isometry3) -> None: ...
    def SetIdentity(self) -> RigidTransform: ...
    def castð“£AutoDiffXdð“¤(self, *args, **kwargs) -> Any: ...
    def castð“£Expressionð“¤(self, *args, **kwargs) -> Any: ...
    def castð“£floatð“¤(self) -> RigidTransform: ...
    def inverse(self) -> RigidTransform: ...
    def rotation(self, *args, **kwargs) -> Any: ...
    def set(self, *args, **kwargs) -> Any: ...
    @overload
    def set_rotation(self, quaternion: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    @overload
    def set_rotation(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis) -> None: ...
    def set_translation(self, p: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> RigidTransform: ...
    def __deepcopy__(self, arg0: dict) -> RigidTransform: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,4]]) -> None: ...

class RigidTransform_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£AutoDiffXdð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, pose: numpy.ndarray[object[m,n]]) -> None: ...
    def GetAsIsometry3(self) -> pydrake.common.eigen_geometry.Isometry3_ð“£AutoDiffXdð“¤: ...
    def GetAsMatrix34(self) -> numpy.ndarray[object[3,4]]: ...
    def GetAsMatrix4(self) -> numpy.ndarray[object[4,4]]: ...
    def GetMaximumAbsoluteDifference(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetMaximumAbsoluteTranslationDifference(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> pydrake.autodiffutils.AutoDiffXd: ...
    @classmethod
    def Identity(cls) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def InvertAndCompose(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def IsExactlyEqualTo(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> bool: ...
    def IsExactlyIdentity(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RigidTransform_ð“£AutoDiffXdð“¤, tolerance: float) -> bool: ...
    @overload
    def IsNearlyIdentity(self, translation_tolerance: float) -> bool: ...
    @overload
    def IsNearlyIdentity(self) -> Any: ...
    def SetFromIsometry3(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£AutoDiffXdð“¤) -> None: ...
    def SetIdentity(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def castð“£AutoDiffXdð“¤(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def inverse(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def rotation(self, *args, **kwargs) -> Any: ...
    def set(self, *args, **kwargs) -> Any: ...
    @overload
    def set_rotation(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def set_rotation(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£AutoDiffXdð“¤) -> None: ...
    def set_translation(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,4]]) -> None: ...

class RigidTransform_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: RigidTransform_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£Expressionð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, pose: numpy.ndarray[object[m,n]]) -> None: ...
    def GetAsIsometry3(self) -> pydrake.common.eigen_geometry.Isometry3_ð“£Expressionð“¤: ...
    def GetAsMatrix34(self) -> numpy.ndarray[object[3,4]]: ...
    def GetAsMatrix4(self) -> numpy.ndarray[object[4,4]]: ...
    def GetMaximumAbsoluteDifference(self, other: RigidTransform_ð“£Expressionð“¤) -> pydrake.symbolic.Expression: ...
    def GetMaximumAbsoluteTranslationDifference(self, other: RigidTransform_ð“£Expressionð“¤) -> pydrake.symbolic.Expression: ...
    @classmethod
    def Identity(cls) -> RigidTransform_ð“£Expressionð“¤: ...
    def InvertAndCompose(self, other: RigidTransform_ð“£Expressionð“¤) -> RigidTransform_ð“£Expressionð“¤: ...
    def IsExactlyEqualTo(self, other: RigidTransform_ð“£Expressionð“¤) -> pydrake.symbolic.Formula: ...
    def IsExactlyIdentity(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyEqualTo(self, other: RigidTransform_ð“£Expressionð“¤, tolerance: float) -> pydrake.symbolic.Formula: ...
    @overload
    def IsNearlyIdentity(self, translation_tolerance: float) -> pydrake.symbolic.Formula: ...
    @overload
    def IsNearlyIdentity(self) -> Any: ...
    def SetFromIsometry3(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£Expressionð“¤) -> None: ...
    def SetIdentity(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def castð“£Expressionð“¤(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def inverse(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def rotation(self, *args, **kwargs) -> Any: ...
    def set(self, *args, **kwargs) -> Any: ...
    @overload
    def set_rotation(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤) -> None: ...
    @overload
    def set_rotation(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£Expressionð“¤) -> None: ...
    def set_translation(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RigidTransform_ð“£Expressionð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,4]]) -> None: ...

class RollPitchYaw:
    @overload
    def __init__(self, other: RollPitchYaw) -> None: ...
    @overload
    def __init__(self, rpy: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, roll: float, pitch: float, yaw: float) -> None: ...
    @overload
    def __init__(self, R: RotationMatrix) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def CalcAngularVelocityInChildFromRpyDt(self, rpyDt: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcAngularVelocityInParentFromRpyDt(self, rpyDt: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRotationMatrixDt(self, rpyDt: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def CalcRpyDDtFromAngularAccelInChild(self, rpyDt: numpy.ndarray[numpy.float64[3,1]], alpha_AD_D: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRpyDDtFromRpyDtAndAngularAccelInParent(self, rpyDt: numpy.ndarray[numpy.float64[3,1]], alpha_AD_A: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInChild(self, w_AD_D: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInParent(self, w_AD_A: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion: ...
    def ToRotationMatrix(self) -> RotationMatrix: ...
    def pitch_angle(self) -> float: ...
    def roll_angle(self) -> float: ...
    def vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def yaw_angle(self) -> float: ...
    def __copy__(self) -> RollPitchYaw: ...
    def __deepcopy__(self, arg0: dict) -> RollPitchYaw: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class RollPitchYaw_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, other: RollPitchYaw_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, rpy: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, roll: pydrake.autodiffutils.AutoDiffXd, pitch: pydrake.autodiffutils.AutoDiffXd, yaw: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, R: RotationMatrix_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[3,3]]) -> None: ...
    def CalcAngularVelocityInChildFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcAngularVelocityInParentFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationMatrixDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,3]]: ...
    def CalcRpyDDtFromAngularAccelInChild(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDDtFromRpyDtAndAngularAccelInParent(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInChild(self, w_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInParent(self, w_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤: ...
    def ToRotationMatrix(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def pitch_angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def roll_angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vector(self) -> numpy.ndarray[object[3,1]]: ...
    def yaw_angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> RollPitchYaw_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RollPitchYaw_ð“£AutoDiffXdð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,1]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...

class RollPitchYaw_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, other: RollPitchYaw_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, rpy: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, roll: pydrake.symbolic.Expression, pitch: pydrake.symbolic.Expression, yaw: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, R: RotationMatrix_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[3,3]]) -> None: ...
    def CalcAngularVelocityInChildFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcAngularVelocityInParentFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationMatrixDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,3]]: ...
    def CalcRpyDDtFromAngularAccelInChild(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDDtFromRpyDtAndAngularAccelInParent(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInChild(self, w_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInParent(self, w_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤: ...
    def ToRotationMatrix(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def pitch_angle(self) -> pydrake.symbolic.Expression: ...
    def roll_angle(self) -> pydrake.symbolic.Expression: ...
    def vector(self) -> numpy.ndarray[object[3,1]]: ...
    def yaw_angle(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> RollPitchYaw_ð“£Expressionð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RollPitchYaw_ð“£Expressionð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,1]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...

class RotationMatrix:
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Identity(cls) -> RotationMatrix: ...
    def InvertAndCompose(self, other: RotationMatrix) -> RotationMatrix: ...
    def IsExactlyIdentity(self) -> bool: ...
    def IsNearlyIdentity(self, tolerance: float = ...) -> bool: ...
    def IsValid(self) -> bool: ...
    @classmethod
    def MakeFromOneVector(cls, b_A: numpy.ndarray[numpy.float64[3,1]], axis_index: int) -> RotationMatrix: ...
    @classmethod
    def MakeXRotation(cls, theta: float) -> RotationMatrix: ...
    @classmethod
    def MakeYRotation(cls, theta: float) -> RotationMatrix: ...
    @classmethod
    def MakeZRotation(cls, theta: float) -> RotationMatrix: ...
    @classmethod
    def ProjectToRotationMatrix(cls, M: numpy.ndarray[numpy.float64[3,3]]) -> RotationMatrix: ...
    def ToAngleAxis(self) -> pydrake.common.eigen_geometry.AngleAxis: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion: ...
    def ToRollPitchYaw(self, *args, **kwargs) -> Any: ...
    def castð“£AutoDiffXdð“¤(self, *args, **kwargs) -> Any: ...
    def castð“£Expressionð“¤(self, *args, **kwargs) -> Any: ...
    def castð“£floatð“¤(self) -> RotationMatrix: ...
    def col(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def inverse(self) -> RotationMatrix: ...
    def matrix(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def row(self, index: int) -> numpy.ndarray[numpy.float64[1,3]]: ...
    def set(self, R: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def transpose(self) -> RotationMatrix: ...
    def __copy__(self) -> RotationMatrix: ...
    def __deepcopy__(self, arg0: dict) -> RotationMatrix: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...

class RotationMatrix_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Identity(cls) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def InvertAndCompose(self, other: RotationMatrix_ð“£AutoDiffXdð“¤) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def IsExactlyIdentity(self) -> bool: ...
    def IsNearlyIdentity(self, tolerance: float = ...) -> bool: ...
    def IsValid(self) -> bool: ...
    @classmethod
    def MakeFromOneVector(cls, b_A: numpy.ndarray[object[3,1]], axis_index: int) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def MakeXRotation(cls, theta: pydrake.autodiffutils.AutoDiffXd) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def MakeYRotation(cls, theta: pydrake.autodiffutils.AutoDiffXd) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def MakeZRotation(cls, theta: pydrake.autodiffutils.AutoDiffXd) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def ProjectToRotationMatrix(cls, M: numpy.ndarray[object[3,3]]) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def ToAngleAxis(self) -> pydrake.common.eigen_geometry.AngleAxis_ð“£AutoDiffXdð“¤: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤: ...
    def ToRollPitchYaw(self, *args, **kwargs) -> Any: ...
    def castð“£AutoDiffXdð“¤(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def col(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def inverse(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def matrix(self) -> numpy.ndarray[object[3,3]]: ...
    def row(self, index: int) -> numpy.ndarray[object[1,3]]: ...
    def set(self, R: numpy.ndarray[object[3,3]]) -> None: ...
    def transpose(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def __copy__(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class RotationMatrix_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Identity(cls) -> RotationMatrix_ð“£Expressionð“¤: ...
    def InvertAndCompose(self, other: RotationMatrix_ð“£Expressionð“¤) -> RotationMatrix_ð“£Expressionð“¤: ...
    def IsExactlyIdentity(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyIdentity(self, tolerance: float = ...) -> pydrake.symbolic.Formula: ...
    def IsValid(self) -> pydrake.symbolic.Formula: ...
    @classmethod
    def MakeFromOneVector(cls, b_A: numpy.ndarray[object[3,1]], axis_index: int) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def MakeXRotation(cls, theta: pydrake.symbolic.Expression) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def MakeYRotation(cls, theta: pydrake.symbolic.Expression) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def MakeZRotation(cls, theta: pydrake.symbolic.Expression) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def ProjectToRotationMatrix(cls, M: numpy.ndarray[object[3,3]]) -> RotationMatrix_ð“£Expressionð“¤: ...
    def ToAngleAxis(self) -> pydrake.common.eigen_geometry.AngleAxis_ð“£Expressionð“¤: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤: ...
    def ToRollPitchYaw(self, *args, **kwargs) -> Any: ...
    def castð“£Expressionð“¤(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def col(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def inverse(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def matrix(self) -> numpy.ndarray[object[3,3]]: ...
    def row(self, index: int) -> numpy.ndarray[object[1,3]]: ...
    def set(self, R: numpy.ndarray[object[3,3]]) -> None: ...
    def transpose(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def __copy__(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RotationMatrix_ð“£Expressionð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class _AutoDiffXd:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self, value: float) -> None: ...
    @overload
    def __init__(self, value: float, derivatives: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, value: float, size: int, offset: int) -> None: ...
    def abs(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def acos(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def arccos(self, *args, **kwargs) -> Any: ...
    def arcsin(self, *args, **kwargs) -> Any: ...
    def arctan(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def arctan2(self, *args, **kwargs) -> Any: ...
    def asin(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def atan(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def atan2(self, x: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def atan2(self, y, x) -> Any: ...
    def ceil(self) -> float: ...
    def cos(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def cosh(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def derivatives(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def exp(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def floor(self) -> float: ...
    def log(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def max(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def min(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def pow(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    def sin(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def sinh(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def sqrt(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tan(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tanh(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def value(self) -> float: ...
    @overload
    def __abs__(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __abs__(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __add__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __add__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __ceil__(self) -> float: ...
    def __copy__(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __eq__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def __eq__(self, arg0: float) -> bool: ...
    def __floor__(self) -> float: ...
    @overload
    def __ge__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def __ge__(self, arg0: float) -> bool: ...
    def __getstate__(self) -> tuple: ...
    @overload
    def __gt__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def __gt__(self, arg0: float) -> bool: ...
    @overload
    def __le__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def __le__(self, arg0: float) -> bool: ...
    @overload
    def __lt__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def __lt__(self, arg0: float) -> bool: ...
    @overload
    def __mul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __mul__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __ne__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def __ne__(self, arg0: float) -> bool: ...
    def __neg__(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __pow__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __radd__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __rmul__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __rsub__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __rtruediv__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    @overload
    def __sub__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __sub__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __truediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def __truediv__(self, arg0: float) -> pydrake.autodiffutils.AutoDiffXd: ...

class _MangledName:
    UNICODE_COMMA: ClassVar[str] = ...
    UNICODE_LEFT_BRACKET: ClassVar[str] = ...
    UNICODE_PERIOD: ClassVar[str] = ...
    UNICODE_RIGHT_BRACKET: ClassVar[str] = ...
    demangle: ClassVar[function] = ...
    mangle: ClassVar[function] = ...
    module_getattr: ClassVar[function] = ...

class _TemporaryName_N5drake4math12BsplineBasisIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, order: int, knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, order: int, num_basis_functions: int, type: KnotVectorType = ..., initial_parameter_value: pydrake.autodiffutils.AutoDiffXd = ..., final_parameter_value: pydrake.autodiffutils.AutoDiffXd = ...) -> None: ...
    @overload
    def __init__(self, other: BsplineBasis_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_interval) -> List[int]: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_value: pydrake.autodiffutils.AutoDiffXd) -> List[int]: ...
    def EvaluateBasisFunctionI(self, i: int, parameter_value: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCurve(self, control_points: List[numpy.ndarray[object[m,1]]], parameter_value: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,1]]: ...
    def FindContainingInterval(self, parameter_value: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def degree(self) -> int: ...
    def final_parameter_value(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def initial_parameter_value(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def knots(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def num_basis_functions(self) -> int: ...
    def order(self) -> int: ...
    def __getstate__(self) -> Tuple[int,List[pydrake.autodiffutils.AutoDiffXd]]: ...
    def __setstate__(self, arg0: Tuple[int,List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...

class _TemporaryName_N5drake4math12BsplineBasisINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, order: int, knots: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, order: int, num_basis_functions: int, type: KnotVectorType = ..., initial_parameter_value: pydrake.symbolic.Expression = ..., final_parameter_value: pydrake.symbolic.Expression = ...) -> None: ...
    @overload
    def __init__(self, other: BsplineBasis_ð“£Expressionð“¤) -> None: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_interval) -> List[int]: ...
    @overload
    def ComputeActiveBasisFunctionIndices(self, parameter_value: pydrake.symbolic.Expression) -> List[int]: ...
    def EvaluateBasisFunctionI(self, i: int, parameter_value: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def EvaluateCurve(self, control_points: List[numpy.ndarray[object[m,1]]], parameter_value: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,1]]: ...
    def FindContainingInterval(self, parameter_value: pydrake.symbolic.Expression) -> int: ...
    def degree(self) -> int: ...
    def final_parameter_value(self) -> pydrake.symbolic.Expression: ...
    def initial_parameter_value(self) -> pydrake.symbolic.Expression: ...
    def knots(self) -> List[pydrake.symbolic.Expression]: ...
    def num_basis_functions(self) -> int: ...
    def order(self) -> int: ...
    def __getstate__(self) -> Tuple[int,List[pydrake.symbolic.Expression]]: ...
    def __setstate__(self, arg0: Tuple[int,List[pydrake.symbolic.Expression]]) -> None: ...

class _TemporaryName_N5drake4math12RollPitchYawIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, other: RollPitchYaw_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, rpy: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, roll: pydrake.autodiffutils.AutoDiffXd, pitch: pydrake.autodiffutils.AutoDiffXd, yaw: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, R: RotationMatrix_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[3,3]]) -> None: ...
    def CalcAngularVelocityInChildFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcAngularVelocityInParentFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationMatrixDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,3]]: ...
    def CalcRpyDDtFromAngularAccelInChild(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDDtFromRpyDtAndAngularAccelInParent(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInChild(self, w_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInParent(self, w_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤: ...
    def ToRotationMatrix(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def pitch_angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def roll_angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vector(self) -> numpy.ndarray[object[3,1]]: ...
    def yaw_angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> RollPitchYaw_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RollPitchYaw_ð“£AutoDiffXdð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,1]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...

class _TemporaryName_N5drake4math12RollPitchYawINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, other: RollPitchYaw_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, rpy: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, roll: pydrake.symbolic.Expression, pitch: pydrake.symbolic.Expression, yaw: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, R: RotationMatrix_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[3,3]]) -> None: ...
    def CalcAngularVelocityInChildFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcAngularVelocityInParentFromRpyDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationMatrixDt(self, rpyDt: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,3]]: ...
    def CalcRpyDDtFromAngularAccelInChild(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDDtFromRpyDtAndAngularAccelInParent(self, rpyDt: numpy.ndarray[object[3,1]], alpha_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInChild(self, w_AD_D: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def CalcRpyDtFromAngularVelocityInParent(self, w_AD_A: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤: ...
    def ToRotationMatrix(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def pitch_angle(self) -> pydrake.symbolic.Expression: ...
    def roll_angle(self) -> pydrake.symbolic.Expression: ...
    def vector(self) -> numpy.ndarray[object[3,1]]: ...
    def yaw_angle(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> RollPitchYaw_ð“£Expressionð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RollPitchYaw_ð“£Expressionð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,1]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...

class _TemporaryName_N5drake4math14RigidTransformIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£AutoDiffXdð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, pose: numpy.ndarray[object[m,n]]) -> None: ...
    def GetAsIsometry3(self) -> pydrake.common.eigen_geometry.Isometry3_ð“£AutoDiffXdð“¤: ...
    def GetAsMatrix34(self) -> numpy.ndarray[object[3,4]]: ...
    def GetAsMatrix4(self) -> numpy.ndarray[object[4,4]]: ...
    def GetMaximumAbsoluteDifference(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetMaximumAbsoluteTranslationDifference(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> pydrake.autodiffutils.AutoDiffXd: ...
    @classmethod
    def Identity(cls) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def InvertAndCompose(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def IsExactlyEqualTo(self, other: RigidTransform_ð“£AutoDiffXdð“¤) -> bool: ...
    def IsExactlyIdentity(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RigidTransform_ð“£AutoDiffXdð“¤, tolerance: float) -> bool: ...
    @overload
    def IsNearlyIdentity(self, translation_tolerance: float) -> bool: ...
    @overload
    def IsNearlyIdentity(self) -> Any: ...
    def SetFromIsometry3(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£AutoDiffXdð“¤) -> None: ...
    def SetIdentity(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def castð“£AutoDiffXdð“¤(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def inverse(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def rotation(self, *args, **kwargs) -> Any: ...
    def set(self, *args, **kwargs) -> Any: ...
    @overload
    def set_rotation(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def set_rotation(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£AutoDiffXdð“¤) -> None: ...
    def set_translation(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,4]]) -> None: ...

class _TemporaryName_N5drake4math14RigidTransformINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: RigidTransform_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£Expressionð“¤, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, pose: numpy.ndarray[object[m,n]]) -> None: ...
    def GetAsIsometry3(self) -> pydrake.common.eigen_geometry.Isometry3_ð“£Expressionð“¤: ...
    def GetAsMatrix34(self) -> numpy.ndarray[object[3,4]]: ...
    def GetAsMatrix4(self) -> numpy.ndarray[object[4,4]]: ...
    def GetMaximumAbsoluteDifference(self, other: RigidTransform_ð“£Expressionð“¤) -> pydrake.symbolic.Expression: ...
    def GetMaximumAbsoluteTranslationDifference(self, other: RigidTransform_ð“£Expressionð“¤) -> pydrake.symbolic.Expression: ...
    @classmethod
    def Identity(cls) -> RigidTransform_ð“£Expressionð“¤: ...
    def InvertAndCompose(self, other: RigidTransform_ð“£Expressionð“¤) -> RigidTransform_ð“£Expressionð“¤: ...
    def IsExactlyEqualTo(self, other: RigidTransform_ð“£Expressionð“¤) -> pydrake.symbolic.Formula: ...
    def IsExactlyIdentity(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyEqualTo(self, other: RigidTransform_ð“£Expressionð“¤, tolerance: float) -> pydrake.symbolic.Formula: ...
    @overload
    def IsNearlyIdentity(self, translation_tolerance: float) -> pydrake.symbolic.Formula: ...
    @overload
    def IsNearlyIdentity(self) -> Any: ...
    def SetFromIsometry3(self, pose: pydrake.common.eigen_geometry.Isometry3_ð“£Expressionð“¤) -> None: ...
    def SetIdentity(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def castð“£Expressionð“¤(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def inverse(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def rotation(self, *args, **kwargs) -> Any: ...
    def set(self, *args, **kwargs) -> Any: ...
    @overload
    def set_rotation(self, quaternion: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤) -> None: ...
    @overload
    def set_rotation(self, theta_lambda: pydrake.common.eigen_geometry.AngleAxis_ð“£Expressionð“¤) -> None: ...
    def set_translation(self, p: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RigidTransform_ð“£Expressionð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,4]]) -> None: ...

class _TemporaryName_N5drake4math14RotationMatrixIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Identity(cls) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def InvertAndCompose(self, other: RotationMatrix_ð“£AutoDiffXdð“¤) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def IsExactlyIdentity(self) -> bool: ...
    def IsNearlyIdentity(self, tolerance: float = ...) -> bool: ...
    def IsValid(self) -> bool: ...
    @classmethod
    def MakeFromOneVector(cls, b_A: numpy.ndarray[object[3,1]], axis_index: int) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def MakeXRotation(cls, theta: pydrake.autodiffutils.AutoDiffXd) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def MakeYRotation(cls, theta: pydrake.autodiffutils.AutoDiffXd) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def MakeZRotation(cls, theta: pydrake.autodiffutils.AutoDiffXd) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def ProjectToRotationMatrix(cls, M: numpy.ndarray[object[3,3]]) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def ToAngleAxis(self) -> pydrake.common.eigen_geometry.AngleAxis_ð“£AutoDiffXdð“¤: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤: ...
    def ToRollPitchYaw(self, *args, **kwargs) -> Any: ...
    def castð“£AutoDiffXdð“¤(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def col(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def inverse(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def matrix(self) -> numpy.ndarray[object[3,3]]: ...
    def row(self, index: int) -> numpy.ndarray[object[1,3]]: ...
    def set(self, R: numpy.ndarray[object[3,3]]) -> None: ...
    def transpose(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def __copy__(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class _TemporaryName_N5drake4math14RotationMatrixINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def Identity(cls) -> RotationMatrix_ð“£Expressionð“¤: ...
    def InvertAndCompose(self, other: RotationMatrix_ð“£Expressionð“¤) -> RotationMatrix_ð“£Expressionð“¤: ...
    def IsExactlyIdentity(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyIdentity(self, tolerance: float = ...) -> pydrake.symbolic.Formula: ...
    def IsValid(self) -> pydrake.symbolic.Formula: ...
    @classmethod
    def MakeFromOneVector(cls, b_A: numpy.ndarray[object[3,1]], axis_index: int) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def MakeXRotation(cls, theta: pydrake.symbolic.Expression) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def MakeYRotation(cls, theta: pydrake.symbolic.Expression) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def MakeZRotation(cls, theta: pydrake.symbolic.Expression) -> RotationMatrix_ð“£Expressionð“¤: ...
    @classmethod
    def ProjectToRotationMatrix(cls, M: numpy.ndarray[object[3,3]]) -> RotationMatrix_ð“£Expressionð“¤: ...
    def ToAngleAxis(self) -> pydrake.common.eigen_geometry.AngleAxis_ð“£Expressionð“¤: ...
    def ToQuaternion(self) -> pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤: ...
    def ToRollPitchYaw(self, *args, **kwargs) -> Any: ...
    def castð“£Expressionð“¤(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def col(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def inverse(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def matrix(self) -> numpy.ndarray[object[3,3]]: ...
    def row(self, index: int) -> numpy.ndarray[object[1,3]]: ...
    def set(self, R: numpy.ndarray[object[3,3]]) -> None: ...
    def transpose(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def __copy__(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def __deepcopy__(self, arg0: dict) -> RotationMatrix_ð“£Expressionð“¤: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class _TemporaryName_N5drake5ValueINS_4math14RigidTransformIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: RigidTransform_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def get_value(self) -> RigidTransform_ð“£AutoDiffXdð“¤: ...
    def set_value(self, arg0: RigidTransform_ð“£AutoDiffXdð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_4math14RigidTransformINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: RigidTransform_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def get_value(self) -> RigidTransform_ð“£Expressionð“¤: ...
    def set_value(self, arg0: RigidTransform_ð“£Expressionð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_4math14RigidTransformIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: RigidTransform) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> RigidTransform: ...
    def get_value(self) -> RigidTransform: ...
    def set_value(self, arg0: RigidTransform) -> None: ...

class _TemporaryName_N5drake5ValueINS_4math14RotationMatrixIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: RotationMatrix_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def get_value(self) -> RotationMatrix_ð“£AutoDiffXdð“¤: ...
    def set_value(self, arg0: RotationMatrix_ð“£AutoDiffXdð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_4math14RotationMatrixINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: RotationMatrix_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def get_value(self) -> RotationMatrix_ð“£Expressionð“¤: ...
    def set_value(self, arg0: RotationMatrix_ð“£Expressionð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_4math14RotationMatrixIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: RotationMatrix) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> RotationMatrix: ...
    def get_value(self) -> RotationMatrix: ...
    def set_value(self, arg0: RotationMatrix) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_4math14RigidTransformIN5Eigen14AutoDiffScalarINS4_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEESaIS9_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[RigidTransform_ð“£AutoDiffXdð“¤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[RigidTransform_ð“£AutoDiffXdð“¤]: ...
    def set_value(self, arg0: List[RigidTransform_ð“£AutoDiffXdð“¤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_4math14RigidTransformINS_8symbolic10ExpressionEEESaIS6_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[RigidTransform_ð“£Expressionð“¤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[RigidTransform_ð“£Expressionð“¤]: ...
    def set_value(self, arg0: List[RigidTransform_ð“£Expressionð“¤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_4math14RigidTransformIdEESaIS4_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[RigidTransform]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[RigidTransform]: ...
    def set_value(self, arg0: List[RigidTransform]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_4math14RotationMatrixIN5Eigen14AutoDiffScalarINS4_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEESaIS9_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[RotationMatrix_ð“£AutoDiffXdð“¤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[RotationMatrix_ð“£AutoDiffXdð“¤]: ...
    def set_value(self, arg0: List[RotationMatrix_ð“£AutoDiffXdð“¤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_4math14RotationMatrixINS_8symbolic10ExpressionEEESaIS6_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[RotationMatrix_ð“£Expressionð“¤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[RotationMatrix_ð“£Expressionð“¤]: ...
    def set_value(self, arg0: List[RotationMatrix_ð“£Expressionð“¤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_4math14RotationMatrixIdEESaIS4_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[RotationMatrix]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[RotationMatrix]: ...
    def set_value(self, arg0: List[RotationMatrix]) -> None: ...

@overload
def AreQuaternionsEqualForOrientation(quat1: pydrake.common.eigen_geometry.Quaternion, quat2: pydrake.common.eigen_geometry.Quaternion, tolerance: float) -> bool: ...
@overload
def AreQuaternionsEqualForOrientation(quat1: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, quat2: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, tolerance: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
@overload
def AreQuaternionsEqualForOrientation(quat1: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, quat2: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, tolerance: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
def BalanceQuadraticForms(S: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], P: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
def CalculateAngularVelocityExpressedInBFromQuaternionDt(quat_AB: pydrake.common.eigen_geometry.Quaternion, quatDt: numpy.ndarray[numpy.float64[4,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
@overload
def CalculateQuaternionDtConstraintViolation(quat: pydrake.common.eigen_geometry.Quaternion, quatDt: numpy.ndarray[numpy.float64[4,1]]) -> float: ...
@overload
def CalculateQuaternionDtConstraintViolation(quat: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, quatDt: numpy.ndarray[object[4,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def CalculateQuaternionDtConstraintViolation(quat: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, quatDt: numpy.ndarray[object[4,1]]) -> pydrake.symbolic.Expression: ...
def CalculateQuaternionDtFromAngularVelocityExpressedInB(quat_AB: pydrake.common.eigen_geometry.Quaternion, w_AB_B: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[4,1]]: ...
@overload
def ClosestQuaternion(quat1: pydrake.common.eigen_geometry.Quaternion, quat2: pydrake.common.eigen_geometry.Quaternion) -> pydrake.common.eigen_geometry.Quaternion: ...
@overload
def ClosestQuaternion(quat1: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, quat2: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤) -> pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤: ...
@overload
def ClosestQuaternion(quat1: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, quat2: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤) -> pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤: ...
def ComputeNumericalGradient(calc_func: Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]], x: numpy.ndarray[numpy.float64[m,1]], option: NumericalGradientOption = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
def ContinuousAlgebraicRiccatiEquation(A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], B: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
def DecomposePSDmatrixIntoXtransposeTimesX(Y: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], zero_tol: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
def DecomposePositiveQuadraticForm(Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], b: numpy.ndarray[numpy.float64[m,1]], c: float, tol: float = ...) -> Tuple[numpy.ndarray[numpy.float64[m,n]],numpy.ndarray[numpy.float64[m,n]]]: ...
def DiscreteAlgebraicRiccatiEquation(A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], B: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
@overload
def IsBothQuaternionAndQuaternionDtOK(quat: pydrake.common.eigen_geometry.Quaternion, quatDt: numpy.ndarray[numpy.float64[4,1]], tolerance: float) -> bool: ...
@overload
def IsBothQuaternionAndQuaternionDtOK(quat: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, quatDt: numpy.ndarray[object[4,1]], tolerance: float) -> bool: ...
@overload
def IsBothQuaternionAndQuaternionDtOK(quat: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, quatDt: numpy.ndarray[object[4,1]], tolerance: float) -> pydrake.symbolic.Formula: ...
def IsPositiveDefinite(matrix: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], tolerance: float = ...) -> bool: ...
@overload
def IsQuaternionValid(quat: pydrake.common.eigen_geometry.Quaternion, tolerance: float) -> bool: ...
@overload
def IsQuaternionValid(quat: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤, tolerance: float) -> bool: ...
@overload
def IsQuaternionValid(quat: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤, tolerance: float) -> pydrake.symbolic.Formula: ...
@overload
def IsSymmetric(matrix: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> bool: ...
@overload
def IsSymmetric(matrix: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], precision: float) -> bool: ...
def QuaternionToCanonicalForm(quat: pydrake.common.eigen_geometry.Quaternion) -> pydrake.common.eigen_geometry.Quaternion: ...
def RealContinuousLyapunovEquation(A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
def RealDiscreteLyapunovEquation(A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
@overload
def SoftOverMax(x: List[float], alpha: float = ...) -> float: ...
@overload
def SoftOverMax(x) -> Any: ...
@overload
def SoftOverMax(x: List[pydrake.autodiffutils.AutoDiffXd], alpha: float = ...) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def SoftOverMax(x) -> Any: ...
@overload
def SoftOverMin(x: List[float], alpha: float = ...) -> float: ...
@overload
def SoftOverMin(x) -> Any: ...
@overload
def SoftOverMin(x: List[pydrake.autodiffutils.AutoDiffXd], alpha: float = ...) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def SoftOverMin(x) -> Any: ...
@overload
def SoftUnderMax(x: List[float], alpha: float = ...) -> float: ...
@overload
def SoftUnderMax(x) -> Any: ...
@overload
def SoftUnderMax(x: List[pydrake.autodiffutils.AutoDiffXd], alpha: float = ...) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def SoftUnderMax(x) -> Any: ...
@overload
def SoftUnderMin(x: List[float], alpha: float = ...) -> float: ...
@overload
def SoftUnderMin(x) -> Any: ...
@overload
def SoftUnderMin(x: List[pydrake.autodiffutils.AutoDiffXd], alpha: float = ...) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def SoftUnderMin(x) -> Any: ...
def ToSymmetricMatrixFromLowerTriangularColumns(lower_triangular_columns: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,n]]: ...
def UniformlyRandomAngleAxis(generator: pydrake.common.RandomGenerator) -> pydrake.common.eigen_geometry.AngleAxis: ...
def UniformlyRandomQuaternion(generator: pydrake.common.RandomGenerator) -> pydrake.common.eigen_geometry.Quaternion: ...
def UniformlyRandomRPY(generator: pydrake.common.RandomGenerator) -> numpy.ndarray[numpy.float64[3,1]]: ...
def UniformlyRandomRotationMatrix(*args, **kwargs) -> Any: ...
@overload
def VectorToSkewSymmetric(p: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,3]]: ...
@overload
def VectorToSkewSymmetric(p: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,3]]: ...
@overload
def VectorToSkewSymmetric(p: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,3]]: ...
@overload
def abs(arg0: float) -> float: ...
@overload
def abs(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def abs(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def acos(arg0: float) -> float: ...
@overload
def acos(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def acos(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def arccos(arg0: float) -> float: ...
@overload
def arccos(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def arccos(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def arcsin(arg0: float) -> float: ...
@overload
def arcsin(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def arcsin(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def arctan(arg0: float) -> float: ...
@overload
def arctan(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def arctan(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def arctan2(y: float, x: float) -> float: ...
@overload
def arctan2(y: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def arctan2(y: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def asin(arg0: float) -> float: ...
@overload
def asin(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def asin(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def atan(arg0: float) -> float: ...
@overload
def atan(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def atan(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def atan2(y: float, x: float) -> float: ...
@overload
def atan2(y: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def atan2(y: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def ceil(arg0: float) -> float: ...
@overload
def ceil(arg0: pydrake.autodiffutils.AutoDiffXd) -> float: ...
@overload
def ceil(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def cos(arg0: float) -> float: ...
@overload
def cos(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def cos(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def cosh(arg0: float) -> float: ...
@overload
def cosh(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def cosh(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def exp(arg0: float) -> float: ...
@overload
def exp(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def exp(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def floor(arg0: float) -> float: ...
@overload
def floor(arg0: pydrake.autodiffutils.AutoDiffXd) -> float: ...
@overload
def floor(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def inv(arg0: numpy.ndarray[numpy.float64[m,n]]) -> numpy.ndarray[numpy.float64[m,n]]: ...
@overload
def inv(arg0: numpy.ndarray[object[m,n]]) -> numpy.ndarray[object[m,n]]: ...
@overload
def inv(arg0: numpy.ndarray[object[m,n]]) -> numpy.ndarray[object[m,n]]: ...
@overload
def is_quaternion_in_canonical_form(quat: pydrake.common.eigen_geometry.Quaternion) -> bool: ...
@overload
def is_quaternion_in_canonical_form(quat: pydrake.common.eigen_geometry.Quaternion_ð“£AutoDiffXdð“¤) -> bool: ...
@overload
def is_quaternion_in_canonical_form(quat: pydrake.common.eigen_geometry.Quaternion_ð“£Expressionð“¤) -> pydrake.symbolic.Formula: ...
@overload
def isnan(x: float) -> bool: ...
@overload
def isnan(x: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
@overload
def isnan(x: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
@overload
def log(arg0: float) -> float: ...
@overload
def log(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def log(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
def matmul(arg0: numpy.ndarray[numpy.float64[m,n]], arg1: numpy.ndarray[numpy.float64[m,n]]) -> numpy.ndarray[numpy.float64[m,n]]: ...
@overload
def max(arg0: float, arg1: float) -> float: ...
@overload
def max(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def max(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def min(arg0: float, arg1: float) -> float: ...
@overload
def min(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def min(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def pow(arg0: float, arg1: float) -> float: ...
@overload
def pow(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: float) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def pow(arg0: pydrake.symbolic.Expression, arg1: float) -> pydrake.symbolic.Expression: ...
@overload
def pow(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def sin(arg0: float) -> float: ...
@overload
def sin(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def sin(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def sinh(arg0: float) -> float: ...
@overload
def sinh(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def sinh(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def sqrt(arg0: float) -> float: ...
@overload
def sqrt(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def sqrt(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def tan(arg0: float) -> float: ...
@overload
def tan(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def tan(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def tanh(arg0: float) -> float: ...
@overload
def tanh(arg0: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def tanh(arg0: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
@overload
def wrap_to(value: float, low: float, high: float) -> float: ...
@overload
def wrap_to(value: pydrake.autodiffutils.AutoDiffXd, low: pydrake.autodiffutils.AutoDiffXd, high: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
@overload
def wrap_to(value: pydrake.symbolic.Expression, low: pydrake.symbolic.Expression, high: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
