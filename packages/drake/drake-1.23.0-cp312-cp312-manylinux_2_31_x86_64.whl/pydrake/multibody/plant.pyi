from typing import Any, Callable, ClassVar, List, Optional, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common
import pydrake.common.value
import pydrake.geometry
import pydrake.math
import pydrake.multibody.math
import pydrake.multibody.tree
import pydrake.symbolic
import pydrake.systems.framework
import scipy.sparse
ContactResults_: pydrake.common.cpp_template.TemplateClass
CoulombFriction_: pydrake.common.cpp_template.TemplateClass
ExternallyAppliedSpatialForceMultiplexer_: pydrake.common.cpp_template.TemplateClass
ExternallyAppliedSpatialForce_: pydrake.common.cpp_template.TemplateClass
HydroelasticContactInfo_: pydrake.common.cpp_template.TemplateClass
MultibodyPlant_: pydrake.common.cpp_template.TemplateClass
PointPairContactInfo_: pydrake.common.cpp_template.TemplateClass
Propeller_: pydrake.common.cpp_template.TemplateClass
Wing_: pydrake.common.cpp_template.TemplateClass

class ContactModel:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kHydroelastic: ClassVar[ContactModel] = ...
    kHydroelasticWithFallback: ClassVar[ContactModel] = ...
    kHydroelasticsOnly: ClassVar[ContactModel] = ...
    kPoint: ClassVar[ContactModel] = ...
    kPointContactOnly: ClassVar[ContactModel] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ContactResults:
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo],bool]) -> ContactResults: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo: ...
    def __copy__(self) -> ContactResults: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults: ...

class ContactResultsToLcmSystem(pydrake.systems.framework.LeafSystem):
    def __init__(self, *args, **kwargs) -> None: ...
    def get_contact_result_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_lcm_message_output_port(self) -> pydrake.systems.framework.OutputPort: ...

class ContactResults_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤],bool]) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...

class ContactResults_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_ğ“£Expressionğ“¤],bool]) -> ContactResults_ğ“£Expressionğ“¤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> ContactResults_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_ğ“£Expressionğ“¤: ...

class CoulombFriction:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: float, dynamic_friction: float) -> None: ...
    def dynamic_friction(self) -> float: ...
    def static_friction(self) -> float: ...
    def __copy__(self) -> CoulombFriction: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class CoulombFriction_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def dynamic_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def static_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> CoulombFriction_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_ğ“£AutoDiffXdğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]: ...
    def __setstate__(self, arg0: Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]) -> None: ...

class CoulombFriction_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -> None: ...
    def dynamic_friction(self) -> pydrake.symbolic.Expression: ...
    def static_friction(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> CoulombFriction_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_ğ“£Expressionğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]: ...
    def __setstate__(self, arg0: Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]) -> None: ...

class DeformableBodyId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> DeformableBodyId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: DeformableBodyId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: DeformableBodyId) -> bool: ...
    def __ne__(self, arg0: DeformableBodyId) -> bool: ...

class DeformableModel(PhysicalModel):
    def __init__(self, *args, **kwargs) -> None: ...
    def GetBodyId(self, *args, **kwargs) -> Any: ...
    def GetDiscreteStateIndex(self, *args, **kwargs) -> Any: ...
    def GetGeometryId(self, *args, **kwargs) -> Any: ...
    def GetReferencePositions(self, *args, **kwargs) -> Any: ...
    def RegisterDeformableBody(self, *args, **kwargs) -> Any: ...
    def SetWallBoundaryCondition(self, *args, **kwargs) -> Any: ...
    def num_bodies(self) -> int: ...
    def vertex_positions_port(self) -> pydrake.systems.framework.OutputPort: ...

class DiscreteContactSolver:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kSap: ClassVar[DiscreteContactSolver] = ...
    kTamsi: ClassVar[DiscreteContactSolver] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExternallyAppliedSpatialForce:
    F_Bq_W: pydrake.multibody.math.SpatialForce
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce: ...

class ExternallyAppliedSpatialForceMultiplexer(pydrake.systems.framework.LeafSystem):
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForceMultiplexer_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForceMultiplexer_ğ“£Expressionğ“¤(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_ğ“£AutoDiffXdğ“¤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤: ...

class ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_ğ“£Expressionğ“¤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤: ...

class HydroelasticContactInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface: ...
    def __copy__(self) -> HydroelasticContactInfo: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo: ...

class HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_ğ“£AutoDiffXdğ“¤: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...

class HydroelasticContactInfo_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_ğ“£Expressionğ“¤: ...
    def contact_surface(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...

class MultibodyPlant(pydrake.systems.framework.LeafSystem):
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint, joint1: pydrake.multibody.tree.Joint, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement) -> pydrake.multibody.tree.ForceElement: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame) -> pydrake.multibody.tree.Frame: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint) -> pydrake.multibody.tree.Joint: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, model: PhysicalModel) -> None: ...
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBp_B: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> pydrake.multibody.math.SpatialAcceleration: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,n]]: ...
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context, forces: pydrake.multibody.tree.MultibodyForces) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context, forces: pydrake.multibody.tree.MultibodyForces) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context, known_vdot: numpy.ndarray[numpy.float64[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,n]]: ...
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context, frame_B: pydrake.multibody.tree.Frame, p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBp_B: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame, p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context, frame_B: pydrake.multibody.tree.Frame, p_BQi: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context, frame_A: pydrake.multibody.tree.Frame, frame_B: pydrake.multibody.tree.Frame) -> pydrake.math.RigidTransform: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context, known_vdot: numpy.ndarray[numpy.float64[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context, frame_F: pydrake.multibody.tree.Frame, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia: ...
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context, p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context) -> float: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> float: ...
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body]) -> pydrake.geometry.GeometrySet: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body) -> pydrake.math.RigidTransform: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body) -> pydrake.multibody.math.SpatialVelocity: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body) -> List[pydrake.multibody.tree.Body]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body) -> pydrake.math.RigidTransform: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeQDotToVelocityMap(self, context: pydrake.systems.framework.Context) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeVelocityToQDotMap(self, context: pydrake.systems.framework.Context) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context, qdot: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context, v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph) -> pydrake.geometry.SourceId: ...
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context, state: pydrake.systems.framework.State) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context, body: pydrake.multibody.tree.Body, X_WB: pydrake.math.RigidTransform) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body, V_WB: pydrake.multibody.math.SpatialVelocity, context: pydrake.systems.framework.Context) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context, q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]], q: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context, v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[numpy.float64[m,1]], v: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame, frame_on_child_M: pydrake.multibody.tree.Frame, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self) -> List[PhysicalModel]: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame: ...

class MultibodyPlantConfig:
    __fields__: ClassVar[tuple] = ...  # read-only
    adjacent_bodies_collision_filters: bool
    contact_model: str
    contact_surface_representation: str
    discrete_contact_solver: str
    penetration_allowance: float
    sap_near_rigid_threshold: float
    stiction_tolerance: float
    time_step: float
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MultibodyPlantConfig: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyPlantConfig: ...

class MultibodyPlant_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤, joint1: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.tree.ForceElement_ğ“£AutoDiffXdğ“¤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.math.SpatialAcceleration_ğ“£AutoDiffXdğ“¤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£AutoDiffXdğ“¤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_ğ“£AutoDiffXdğ“¤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_F: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_ğ“£AutoDiffXdğ“¤: ...
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤]) -> pydrake.geometry.GeometrySet: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.math.SpatialVelocity_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> List[pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_ğ“£AutoDiffXdğ“¤) -> pydrake.geometry.SourceId: ...
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, state: pydrake.systems.framework.State_ğ“£AutoDiffXdğ“¤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_WB: pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, V_WB: pydrake.multibody.math.SpatialVelocity_ğ“£AutoDiffXdğ“¤, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_on_child_M: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_ğ“£AutoDiffXdğ“¤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_ğ“£AutoDiffXdğ“¤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£AutoDiffXdğ“¤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_ğ“£AutoDiffXdğ“¤: ...

class MultibodyPlant_ğ“£Expressionğ“¤(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤, joint1: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_ğ“£Expressionğ“¤) -> pydrake.multibody.tree.ForceElement_ğ“£Expressionğ“¤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> pydrake.multibody.math.SpatialAcceleration_ğ“£Expressionğ“¤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£Expressionğ“¤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_ğ“£Expressionğ“¤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_F: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_ğ“£Expressionğ“¤: ...
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_ğ“£Expressionğ“¤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> pydrake.symbolic.Expression: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.symbolic.Expression: ...
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_ğ“£Expressionğ“¤]) -> pydrake.geometry.GeometrySet: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.multibody.math.SpatialVelocity_ğ“£Expressionğ“¤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> List[pydrake.multibody.tree.Body_ğ“£Expressionğ“¤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_ğ“£Expressionğ“¤) -> pydrake.geometry.SourceId: ...
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, state: pydrake.systems.framework.State_ğ“£Expressionğ“¤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_WB: pydrake.math.RigidTransform_ğ“£Expressionğ“¤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, V_WB: pydrake.multibody.math.SpatialVelocity_ğ“£Expressionğ“¤, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_on_child_M: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_ğ“£Expressionğ“¤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_ğ“£Expressionğ“¤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£Expressionğ“¤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£Expressionğ“¤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_ğ“£Expressionğ“¤: ...

class PhysicalModel:
    def __init__(self, *args, **kwargs) -> None: ...

class PointPairContactInfo:
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[numpy.float64[3,1]], p_WC: numpy.ndarray[numpy.float64[3,1]], separation_speed: float, slip_speed: float, point_pair: pydrake.geometry.PenetrationAsPointPair) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> float: ...
    def slip_speed(self) -> float: ...
    def __copy__(self) -> PointPairContactInfo: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo: ...

class PointPairContactInfo_ğ“£AutoDiffXdğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.autodiffutils.AutoDiffXd, slip_speed: pydrake.autodiffutils.AutoDiffXd, point_pair: pydrake.geometry.PenetrationAsPointPair_ğ“£AutoDiffXdğ“¤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def slip_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> PointPairContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_ğ“£AutoDiffXdğ“¤: ...

class PointPairContactInfo_ğ“£Expressionğ“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.symbolic.Expression, slip_speed: pydrake.symbolic.Expression, point_pair: pydrake.geometry.PenetrationAsPointPair_ğ“£Expressionğ“¤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_ğ“£Expressionğ“¤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.symbolic.Expression: ...
    def slip_speed(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> PointPairContactInfo_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_ğ“£Expressionğ“¤: ...

class Propeller(pydrake.systems.framework.LeafSystem):
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def num_propellers(self) -> int: ...

class PropellerInfo:
    X_BP: pydrake.math.RigidTransform
    body_index: pydrake.multibody.tree.BodyIndex
    moment_ratio: float
    thrust_ratio: float
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    def __copy__(self) -> PropellerInfo: ...
    def __deepcopy__(self, arg0: dict) -> PropellerInfo: ...

class Propeller_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def num_propellers(self) -> int: ...

class Propeller_ğ“£Expressionğ“¤(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def num_propellers(self) -> int: ...

class Wing(pydrake.systems.framework.LeafSystem):
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, plant: MultibodyPlant, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort: ...

class Wing_ğ“£AutoDiffXdğ“¤(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ğ“£AutoDiffXdğ“¤, plant: MultibodyPlant_ğ“£AutoDiffXdğ“¤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_ğ“£AutoDiffXdğ“¤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...

class Wing_ğ“£Expressionğ“¤(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ğ“£Expressionğ“¤, plant: MultibodyPlant_ğ“£Expressionğ“¤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_ğ“£Expressionğ“¤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...

class _MangledName:
    UNICODE_COMMA: ClassVar[str] = ...
    UNICODE_LEFT_BRACKET: ClassVar[str] = ...
    UNICODE_PERIOD: ClassVar[str] = ...
    UNICODE_RIGHT_BRACKET: ClassVar[str] = ...
    demangle: ClassVar[function] = ...
    mangle: ClassVar[function] = ...
    module_getattr: ClassVar[function] = ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...
    def get_value(self) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...
    def set_value(self, arg0: ContactResults_ğ“£AutoDiffXdğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults_ğ“£Expressionğ“¤: ...
    def get_value(self) -> ContactResults_ğ“£Expressionğ“¤: ...
    def set_value(self, arg0: ContactResults_ğ“£Expressionğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults: ...
    def get_value(self) -> ContactResults: ...
    def set_value(self, arg0: ContactResults) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction_ğ“£AutoDiffXdğ“¤: ...
    def get_value(self) -> CoulombFriction_ğ“£AutoDiffXdğ“¤: ...
    def set_value(self, arg0: CoulombFriction_ğ“£AutoDiffXdğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction_ğ“£Expressionğ“¤: ...
    def get_value(self) -> CoulombFriction_ğ“£Expressionğ“¤: ...
    def set_value(self, arg0: CoulombFriction_ğ“£Expressionğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction: ...
    def get_value(self) -> CoulombFriction: ...
    def set_value(self, arg0: CoulombFriction) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def get_value(self) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def set_value(self, arg0: HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...
    def get_value(self) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...
    def set_value(self, arg0: HydroelasticContactInfo_ğ“£Expressionğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo: ...
    def get_value(self) -> HydroelasticContactInfo: ...
    def set_value(self, arg0: HydroelasticContactInfo) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤: ...
    def get_value(self) -> ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤: ...
    def get_value(self) -> ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce: ...
    def get_value(self) -> ExternallyAppliedSpatialForce: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS4_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEESaIS9_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEESaIS6_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceIdEESaIS4_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce]) -> None: ...

class _TemporaryName_N5drake9multibody14ContactResultsIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤],bool]) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake9multibody14ContactResultsINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def SelectHydroelastic(self, selector: Callable[[HydroelasticContactInfo_ğ“£Expressionğ“¤],bool]) -> ContactResults_ğ“£Expressionğ“¤: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_ğ“£Expressionğ“¤: ...
    def __copy__(self) -> ContactResults_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake9multibody14MultibodyPlantIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤, joint1: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.tree.ForceElement_ğ“£AutoDiffXdğ“¤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.math.SpatialAcceleration_ğ“£AutoDiffXdğ“¤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£AutoDiffXdğ“¤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_ğ“£AutoDiffXdğ“¤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, frame_F: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_ğ“£AutoDiffXdğ“¤: ...
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤]) -> pydrake.geometry.GeometrySet: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.multibody.math.SpatialVelocity_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> List[pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤) -> pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_ğ“£AutoDiffXdğ“¤) -> pydrake.geometry.SourceId: ...
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, state: pydrake.systems.framework.State_ğ“£AutoDiffXdğ“¤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, X_WB: pydrake.math.RigidTransform_ğ“£AutoDiffXdğ“¤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤, V_WB: pydrake.multibody.math.SpatialVelocity_ğ“£AutoDiffXdğ“¤, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£AutoDiffXdğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, frame_on_child_M: pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_ğ“£AutoDiffXdğ“¤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_ğ“£AutoDiffXdğ“¤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_ğ“£AutoDiffXdğ“¤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£AutoDiffXdğ“¤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£AutoDiffXdğ“¤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_ğ“£AutoDiffXdğ“¤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake9multibody14MultibodyPlantINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddBallConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤, joint1: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤, gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddDistanceConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_AP: numpy.ndarray[numpy.float64[3,1]], body_B: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, p_BQ: numpy.ndarray[numpy.float64[3,1]], distance: float, stiffness: float = ..., damping: float = ...) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_ğ“£Expressionğ“¤) -> pydrake.multibody.tree.ForceElement_ğ“£Expressionğ“¤: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤, effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    def AddWeldConstraint(self, body_A: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_AP: pydrake.math.RigidTransform, body_B: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_BQ: pydrake.math.RigidTransform) -> pydrake.multibody.tree.MultibodyConstraintId: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> pydrake.multibody.math.SpatialAcceleration_ğ“£Expressionğ“¤: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£Expressionğ“¤) -> None: ...
    def CalcGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, forces: pydrake.multibody.tree.MultibodyForces_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_E: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_A: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_B: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_ğ“£Expressionğ“¤]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, frame_F: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_ğ“£Expressionğ“¤: ...
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_ğ“£Expressionğ“¤: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> pydrake.symbolic.Expression: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.symbolic.Expression: ...
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_ğ“£Expressionğ“¤]) -> pydrake.geometry.GeometrySet: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.multibody.math.SpatialVelocity_ğ“£Expressionğ“¤: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetActuatedJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    @overload
    def GetActuatorNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetActuatorNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> List[pydrake.multibody.tree.Body_ğ“£Expressionğ“¤]: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> List[pydrake.geometry.GeometryId]: ...
    def GetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId) -> bool: ...
    @classmethod
    def GetDefaultContactSurfaceRepresentation(cls, time_step: float) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform: ...
    @overload
    def GetDefaultPositions(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    def GetFrameIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.FrameIndex]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤) -> pydrake.math.RigidTransform_ğ“£Expressionğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    @overload
    def GetJointActuatorByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    def GetJointActuatorIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointActuatorIndex]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetPositionNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    @overload
    def GetStateNames(self, add_model_instance_prefix: bool = ...) -> List[str]: ...
    @overload
    def GetStateNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ...) -> List[str]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocityNames(self, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    @overload
    def GetVelocityNames(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, add_model_instance_prefix: bool = ..., always_add_suffix: bool = ...) -> List[str]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def IsVelocityEqualToQDot(self) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeStateSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_ğ“£Expressionğ“¤) -> pydrake.geometry.SourceId: ...
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_BG: pydrake.math.RigidTransform, shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def RenameModelInstance(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, name: str) -> None: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetConstraintActiveStatus(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, id: pydrake.multibody.tree.MultibodyConstraintId, status: bool) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_WB: pydrake.math.RigidTransform) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, state: pydrake.systems.framework.State_ğ“£Expressionğ“¤) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, X_WB: pydrake.math.RigidTransform_ğ“£Expressionğ“¤) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_ğ“£Expressionğ“¤, V_WB: pydrake.multibody.math.SpatialVelocity_ğ“£Expressionğ“¤, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_ğ“£Expressionğ“¤, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, frame_on_child_M: pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤, X_FM: pydrake.math.RigidTransform = ...) -> pydrake.multibody.tree.WeldJoint_ğ“£Expressionğ“¤: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_adjacent_bodies_collision_filters(self) -> bool: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_ğ“£Expressionğ“¤: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_desired_state_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_ğ“£Expressionğ“¤: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_ğ“£Expressionğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_ğ“£Expressionğ“¤: ...
    def get_mutable_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_ğ“£Expressionğ“¤: ...
    @overload
    def get_net_actuation_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_net_actuation_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_sap_near_rigid_threshold(self) -> float: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£Expressionğ“¤: ...
    def is_finalized(self) -> bool: ...
    def is_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_ğ“£Expressionğ“¤: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_actuators(self) -> int: ...
    @overload
    def num_actuators(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_adjacent_bodies_collision_filters(self, value: bool) -> None: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_gravity_enabled(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, is_enabled: bool) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_sap_near_rigid_threshold(self, near_rigid_threshold: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_ğ“£Expressionğ“¤: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake9multibody15CoulombFrictionIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def dynamic_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def static_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> CoulombFriction_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_ğ“£AutoDiffXdğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]: ...
    def __setstate__(self, arg0: Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake9multibody15CoulombFrictionINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -> None: ...
    def dynamic_friction(self) -> pydrake.symbolic.Expression: ...
    def static_friction(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> CoulombFriction_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_ğ“£Expressionğ“¤: ...
    def __getstate__(self) -> Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]: ...
    def __setstate__(self, arg0: Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]) -> None: ...

class _TemporaryName_N5drake9multibody20PointPairContactInfoIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.autodiffutils.AutoDiffXd, slip_speed: pydrake.autodiffutils.AutoDiffXd, point_pair: pydrake.geometry.PenetrationAsPointPair_ğ“£AutoDiffXdğ“¤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_ğ“£AutoDiffXdğ“¤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def slip_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> PointPairContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake9multibody20PointPairContactInfoINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.symbolic.Expression, slip_speed: pydrake.symbolic.Expression, point_pair: pydrake.geometry.PenetrationAsPointPair_ğ“£Expressionğ“¤) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_ğ“£Expressionğ“¤: ...
    @overload
    def point_pair(self) -> Any: ...
    @overload
    def point_pair(self) -> Any: ...
    def separation_speed(self) -> pydrake.symbolic.Expression: ...
    def slip_speed(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> PointPairContactInfo_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake9multibody23HydroelasticContactInfoIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_ğ“£AutoDiffXdğ“¤: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_ğ“£AutoDiffXdğ“¤: ...
    def __copy__(self) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake9multibody23HydroelasticContactInfoINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_ğ“£Expressionğ“¤: ...
    def contact_surface(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_ğ“£AutoDiffXdğ“¤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_ğ“£Expressionğ“¤
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake9multibody40ExternallyAppliedSpatialForceMultiplexerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class _TemporaryName_N5drake9multibody40ExternallyAppliedSpatialForceMultiplexerINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class _TemporaryName_N5drake9multibody4WingIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ğ“£AutoDiffXdğ“¤, plant: MultibodyPlant_ğ“£AutoDiffXdğ“¤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_ğ“£AutoDiffXdğ“¤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...

class _TemporaryName_N5drake9multibody4WingINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ğ“£Expressionğ“¤, plant: MultibodyPlant_ğ“£Expressionğ“¤, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform = ..., fluid_density: float = ...) -> Wing_ğ“£Expressionğ“¤: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...

class _TemporaryName_N5drake9multibody9PropellerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ğ“£AutoDiffXdğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£AutoDiffXdğ“¤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£AutoDiffXdğ“¤: ...
    def num_propellers(self) -> int: ...

class _TemporaryName_N5drake9multibody9PropellerINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_ğ“£Expressionğ“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_ğ“£Expressionğ“¤: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_ğ“£Expressionğ“¤: ...
    def num_propellers(self) -> int: ...

def AddMultibodyPlant(config: MultibodyPlantConfig, builder: pydrake.systems.framework.DiagramBuilder) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, plant: MultibodyPlant, scene_graph: pydrake.geometry.SceneGraph = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder, time_step: float, scene_graph: pydrake.geometry.SceneGraph = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_ğ“£AutoDiffXdğ“¤, plant: MultibodyPlant_ğ“£AutoDiffXdğ“¤, scene_graph: pydrake.geometry.SceneGraph_ğ“£AutoDiffXdğ“¤ = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_ğ“£AutoDiffXdğ“¤, time_step: float, scene_graph: pydrake.geometry.SceneGraph_ğ“£AutoDiffXdğ“¤ = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_ğ“£Expressionğ“¤, plant: MultibodyPlant_ğ“£Expressionğ“¤, scene_graph: pydrake.geometry.SceneGraph_ğ“£Expressionğ“¤ = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_ğ“£Expressionğ“¤, time_step: float, scene_graph: pydrake.geometry.SceneGraph_ğ“£Expressionğ“¤ = ...) -> tuple: ...
def ApplyMultibodyPlantConfig(config: MultibodyPlantConfig, plant: MultibodyPlant) -> None: ...
def CalcContactFrictionFromSurfaceProperties(surface_properties1: CoulombFriction, surface_properties2: CoulombFriction) -> CoulombFriction: ...
def ConnectContactResultsToDrakeVisualizer(*args, **kwargs) -> Any: ...
