from typing import Any, ClassVar, List, Optional, Tuple, Union

from typing import overload
import flags
import numpy
import os
import pydrake.autodiffutils
import pydrake.common
import pydrake.common.value
import pydrake.lcm
import pydrake.math
import pydrake.symbolic
import pydrake.systems.framework
ContactSurface_: pydrake.common.cpp_template.TemplateClass
DrakeVisualizer_: pydrake.common.cpp_template.TemplateClass
FramePoseVector_: pydrake.common.cpp_template.TemplateClass
MeshcatPointCloudVisualizer_: pydrake.common.cpp_template.TemplateClass
MeshcatVisualizer_: pydrake.common.cpp_template.TemplateClass
PenetrationAsPointPair_: pydrake.common.cpp_template.TemplateClass
PolygonSurfaceMeshFieldLinear_: pydrake.common.cpp_template.TemplateClass
PolygonSurfaceMesh_: pydrake.common.cpp_template.TemplateClass
QueryObject_: pydrake.common.cpp_template.TemplateClass
SceneGraphInspector_: pydrake.common.cpp_template.TemplateClass
SceneGraph_: pydrake.common.cpp_template.TemplateClass
SignedDistancePair_: pydrake.common.cpp_template.TemplateClass
SignedDistanceToPoint_: pydrake.common.cpp_template.TemplateClass
StartMeshcat: function
TriangleSurfaceMeshFieldLinear_: pydrake.common.cpp_template.TemplateClass
TriangleSurfaceMesh_: pydrake.common.cpp_template.TemplateClass
VolumeMesh_: pydrake.common.cpp_template.TemplateClass
_install_deepnote_nginx: function
_is_listening: function
_start_meshcat_deepnote: function

class Box(Shape):
    def __init__(self, width: float, depth: float, height: float) -> None: ...
    def depth(self) -> float: ...
    def height(self) -> float: ...
    def size(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def width(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class Capsule(Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class ClippingRange:
    @overload
    def __init__(self, other: ClippingRange) -> None: ...
    @overload
    def __init__(self, near: float, far: float) -> None: ...
    def far(self) -> float: ...
    def near(self) -> float: ...

class CollisionFilterDeclaration:
    def __init__(self) -> None: ...
    def AllowBetween(self, *args, **kwargs) -> Any: ...
    def AllowWithin(self, *args, **kwargs) -> Any: ...
    def ExcludeBetween(self, *args, **kwargs) -> Any: ...
    def ExcludeWithin(self, *args, **kwargs) -> Any: ...

class CollisionFilterManager:
    def __init__(self, *args, **kwargs) -> None: ...
    def Apply(self, declaration: CollisionFilterDeclaration) -> None: ...
    def ApplyTransient(self, *args, **kwargs) -> Any: ...
    def IsActive(self, *args, **kwargs) -> Any: ...
    def RemoveDeclaration(self, *args, **kwargs) -> Any: ...
    def has_transient_history(self) -> bool: ...

class ColorRenderCamera:
    def __init__(self, other: ColorRenderCamera) -> None: ...
    def core(self, *args, **kwargs) -> Any: ...
    def show_window(self) -> bool: ...
    def __copy__(self) -> ColorRenderCamera: ...
    def __deepcopy__(self, arg0: dict) -> ColorRenderCamera: ...

class ContactSurface:
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> float: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> float: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh: ...
    def __copy__(self) -> ContactSurface: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface: ...

class ContactSurface_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_ð“£AutoDiffXdð“¤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_ð“£AutoDiffXdð“¬AutoDiffXdð“¤: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_ð“£AutoDiffXdð“¤: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_ð“£AutoDiffXdð“¬AutoDiffXdð“¤: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_ð“£AutoDiffXdð“¤: ...
    def __copy__(self) -> ContactSurface_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_ð“£AutoDiffXdð“¤: ...

class Convex(Shape):
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    @overload
    def extension(self) -> str: ...
    @overload
    def extension(self) -> Any: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...
    def __getstate__(self) -> Tuple[str,float]: ...
    def __setstate__(self, arg0: Tuple[str,float]) -> None: ...

class Cylinder(Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class DepthRange:
    @overload
    def __init__(self, other: DepthRange) -> None: ...
    @overload
    def __init__(self, min_in: float, min_out: float) -> None: ...
    def max_depth(self) -> float: ...
    def min_depth(self) -> float: ...
    def __copy__(self) -> DepthRange: ...
    def __deepcopy__(self, arg0: dict) -> DepthRange: ...

class DepthRenderCamera:
    def __init__(self, other: DepthRenderCamera) -> None: ...
    def core(self, *args, **kwargs) -> Any: ...
    def depth_range(self) -> DepthRange: ...
    def __copy__(self) -> DepthRenderCamera: ...
    def __deepcopy__(self, arg0: dict) -> DepthRenderCamera: ...

class DrakeVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, scene_graph: SceneGraph, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: SceneGraph, lcm: pydrake.lcm.DrakeLcmInterface, params: DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort: ...

class DrakeVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: Rgba
    publish_period: float
    role: Role
    show_hydroelastic: bool
    use_role_channel_suffix: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> DrakeVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> DrakeVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class DrakeVisualizer_ð“£AutoDiffXdð“¤(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ð“£AutoDiffXdð“¤, scene_graph: SceneGraph_ð“£AutoDiffXdð“¤, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: SceneGraph_ð“£AutoDiffXdð“¤, lcm: pydrake.lcm.DrakeLcmInterface, params: DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...

class Ellipsoid(Shape):
    @overload
    def __init__(self, a: float, b: float, c: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def c(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class EnvironmentMap:
    __fields__: ClassVar[tuple] = ...  # read-only
    skybox: bool
    texture: Union[NullTexture,EquirectangularMap]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> EnvironmentMap: ...
    def __deepcopy__(self, arg0: dict) -> EnvironmentMap: ...

class EquirectangularMap:
    __fields__: ClassVar[tuple] = ...  # read-only
    path: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> EquirectangularMap: ...
    def __deepcopy__(self, arg0: dict) -> EquirectangularMap: ...

class FilterId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> FilterId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: FilterId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: FilterId) -> bool: ...
    def __ne__(self, arg0: FilterId) -> bool: ...

class FrameId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> FrameId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: FrameId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: FrameId) -> bool: ...
    def __ne__(self, arg0: FrameId) -> bool: ...

class FramePoseVector:
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform: ...

class FramePoseVector_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...

class FramePoseVector_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ð“£Expressionð“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...

class GeometryFrame:
    def __init__(self, frame_name: str, frame_group_id: int = ...) -> None: ...
    def frame_group(self) -> int: ...
    def id(self, *args, **kwargs) -> Any: ...
    def name(self) -> str: ...
    def __copy__(self) -> GeometryFrame: ...
    def __deepcopy__(self, arg0: dict) -> GeometryFrame: ...

class GeometryId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> GeometryId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: GeometryId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: GeometryId) -> bool: ...
    def __ne__(self, arg0: GeometryId) -> bool: ...

class GeometryInstance:
    def __init__(self, *args, **kwargs) -> None: ...
    def id(self, *args, **kwargs) -> Any: ...
    def illustration_properties(self, *args, **kwargs) -> Any: ...
    def mutable_illustration_properties(self, *args, **kwargs) -> Any: ...
    def mutable_perception_properties(self, *args, **kwargs) -> Any: ...
    def mutable_proximity_properties(self, *args, **kwargs) -> Any: ...
    def name(self) -> str: ...
    def perception_properties(self, *args, **kwargs) -> Any: ...
    def pose(self) -> pydrake.math.RigidTransform: ...
    def proximity_properties(self, *args, **kwargs) -> Any: ...
    def set_illustration_properties(self, *args, **kwargs) -> Any: ...
    def set_name(self, arg0: str) -> None: ...
    def set_perception_properties(self, *args, **kwargs) -> Any: ...
    def set_pose(self, X_PG: pydrake.math.RigidTransform) -> None: ...
    def set_proximity_properties(self, *args, **kwargs) -> Any: ...
    def shape(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> GeometryInstance: ...
    def __deepcopy__(self, arg0: dict) -> GeometryInstance: ...

class GeometryProperties:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddProperty(self, group_name: str, name: str, value: object) -> None: ...
    def GetGroupNames(self) -> Set[str]: ...
    def GetPropertiesInGroup(self, group_name: str) -> dict: ...
    def GetProperty(self, group_name: str, name: str) -> object: ...
    def GetPropertyOrDefault(self, group_name: str, name: str, default_value: object) -> object: ...
    def HasGroup(self, group_name: str) -> bool: ...
    def HasProperty(self, group_name: str, name: str) -> bool: ...
    def RemoveProperty(self, group_name: str, name: str) -> bool: ...
    def UpdateProperty(self, group_name: str, name: str, value: object) -> None: ...
    @classmethod
    def default_group_name(cls) -> str: ...
    def num_groups(self) -> int: ...

class GeometrySet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, geometry_ids) -> None: ...
    @overload
    def __init__(self, frame_ids) -> None: ...
    @overload
    def __init__(self, geometry_ids, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids) -> None: ...
    @overload
    def Add(self, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids, frame_ids) -> None: ...

class GeometryVersion:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: GeometryVersion) -> None: ...
    def IsSameAs(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> GeometryVersion: ...
    def __deepcopy__(self, arg0: dict) -> GeometryVersion: ...

class HalfSpace(Shape):
    def __init__(self) -> None: ...
    @classmethod
    def MakePose(cls, Hz_dir_F: numpy.ndarray[numpy.float64[3,1]], p_FB: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.math.RigidTransform: ...

class HydroelasticContactRepresentation:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kPolygon: ClassVar[HydroelasticContactRepresentation] = ...
    kTriangle: ClassVar[HydroelasticContactRepresentation] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IllustrationProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: IllustrationProperties) -> None: ...
    def __copy__(self) -> IllustrationProperties: ...
    def __deepcopy__(self, arg0: dict) -> IllustrationProperties: ...

class LightParameter:
    __fields__: ClassVar[tuple] = ...  # read-only
    attenuation_values: numpy.ndarray[numpy.float64[3,1]]
    color: Rgba
    cone_angle: float
    direction: numpy.ndarray[numpy.float64[3,1]]
    frame: str
    intensity: float
    position: numpy.ndarray[numpy.float64[3,1]]
    type: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> LightParameter: ...
    def __deepcopy__(self, arg0: dict) -> LightParameter: ...

class Mesh(Shape):
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    @overload
    def extension(self) -> str: ...
    @overload
    def extension(self) -> Any: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...
    def __getstate__(self) -> Tuple[str,float]: ...
    def __setstate__(self, arg0: Tuple[str,float]) -> None: ...

class Meshcat:
    class Gamepad:
        __fields__: ClassVar[tuple] = ...  # read-only
        axes: List[float]
        button_values: List[float]
        index: Optional[int]
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.Gamepad: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.Gamepad: ...

    class OrthographicCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        bottom: float
        far: float
        left: float
        near: float
        right: float
        top: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.OrthographicCamera: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.OrthographicCamera: ...

    class PerspectiveCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        aspect: float
        far: float
        fov: float
        near: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> Meshcat.PerspectiveCamera: ...
        def __deepcopy__(self, arg0: dict) -> Meshcat.PerspectiveCamera: ...

    class SideOfFaceToRender:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kBackSide: ClassVar[Meshcat.SideOfFaceToRender] = ...
        kDoubleSide: ClassVar[Meshcat.SideOfFaceToRender] = ...
        kFrontSide: ClassVar[Meshcat.SideOfFaceToRender] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    @overload
    def __init__(self, port: Optional[int] = ...) -> None: ...
    @overload
    def __init__(self, params: MeshcatParams) -> None: ...
    def AddButton(self, name: str, keycode: str = ...) -> None: ...
    def AddSlider(self, name: str, min: float, max: float, step: float, value: float, decrement_keycode: str = ..., increment_keycode: str = ...) -> None: ...
    def Delete(self, path: str = ...) -> None: ...
    def DeleteAddedControls(self) -> None: ...
    def DeleteButton(self, name: str) -> None: ...
    def DeleteRecording(self) -> None: ...
    def DeleteSlider(self, name: str) -> None: ...
    def Flush(self) -> None: ...
    def GetButtonClicks(self, name: str) -> int: ...
    def GetGamepad(self, *args, **kwargs) -> Any: ...
    def GetNumActiveConnections(self) -> int: ...
    def GetRealtimeRate(self) -> float: ...
    def GetSliderNames(self) -> List[str]: ...
    def GetSliderValue(self, name: str) -> float: ...
    def HasPath(self, path: str) -> bool: ...
    def PlotSurface(self, path: str, X: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Y: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Z: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ...) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRenderMode(self) -> None: ...
    def Set2dRenderMode(self, X_WC: pydrake.math.RigidTransform = ..., xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ...) -> None: ...
    def SetAnimation(self) -> Any: ...
    def SetCamera(self, *args, **kwargs) -> Any: ...
    def SetCameraPose(self, camera_in_world: numpy.ndarray[numpy.float64[3,1]], target_in_world: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetCameraTarget(self, target_in_world: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetEnvironmentMap(self, image_path: os.PathLike) -> None: ...
    def SetLine(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], line_width: float = ..., rgba: Rgba = ...) -> None: ...
    def SetLineSegments(self, path: str, start: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], end: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], line_width: float = ..., rgba: Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, shape: Shape, rgba: Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, mesh: TriangleSurfaceMesh, rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ..., side: Meshcat.SideOfFaceToRender = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: bool, time_in_recording: Optional[float] = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: float, time_in_recording: Optional[float] = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: List[float], time_in_recording: Optional[float] = ...) -> None: ...
    def SetRealtimeRate(self, rate: float) -> None: ...
    def SetSliderValue(self, name: str, value: float) -> None: ...
    def SetTransform(self, path: str, X_ParentPath: pydrake.math.RigidTransform, time_in_recording: Optional[float] = ...) -> None: ...
    def SetTriangleColorMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3,n],flags.f_contiguous], colors: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], wireframe: bool = ..., wireframe_line_width: float = ..., side: Meshcat.SideOfFaceToRender = ...) -> None: ...
    def SetTriangleMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3,n],flags.f_contiguous], rgba: Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ..., side: Meshcat.SideOfFaceToRender = ...) -> None: ...
    def StartRecording(self, frames_per_second: float = ..., set_visualizations_while_recording: bool = ...) -> None: ...
    def StaticHtml(self) -> str: ...
    def StopRecording(self) -> None: ...
    def _GetPackedObject(self, path: str) -> bytes: ...
    def _GetPackedProperty(self, path: str, property: str) -> bytes: ...
    def _GetPackedTransform(self, path: str) -> bytes: ...
    def _InjectWebsocketMessage(self, message: bytes) -> None: ...
    def get_mutable_recording(self, *args, **kwargs) -> Any: ...
    def port(self) -> int: ...
    def web_url(self) -> str: ...
    def ws_url(self) -> str: ...

class MeshcatAnimation:
    class LoopMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kLoopOnce: ClassVar[MeshcatAnimation.LoopMode] = ...
        kLoopPingPong: ClassVar[MeshcatAnimation.LoopMode] = ...
        kLoopRepeat: ClassVar[MeshcatAnimation.LoopMode] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, frames_per_second: float = ...) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: bool) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: float) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: List[float]) -> None: ...
    def SetTransform(self, frame: int, path: str, X_ParentPath: pydrake.math.RigidTransform) -> None: ...
    def autoplay(self) -> bool: ...
    def clamp_when_finished(self) -> bool: ...
    def frame(self, time_from_start: float) -> int: ...
    def frames_per_second(self) -> float: ...
    def loop_mode(self, *args, **kwargs) -> Any: ...
    def repetitions(self) -> int: ...
    def set_autoplay(self, play: bool) -> None: ...
    def set_clamp_when_finished(self, clamp: bool) -> None: ...
    def set_loop_mode(self, *args, **kwargs) -> Any: ...
    def set_repetitions(self, repetitions: int) -> None: ...

class MeshcatCone(Shape):
    @overload
    def __init__(self, height: float, a: float = ..., b: float = ...) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def height(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class MeshcatParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    host: str
    port: Optional[int]
    show_stats_plot: bool
    web_url_pattern: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MeshcatParams: ...
    def __deepcopy__(self, arg0: dict) -> MeshcatParams: ...

class MeshcatPointCloudVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatPointCloudVisualizer_ð“£AutoDiffXdð“¤(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, scene_graph: SceneGraph, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort: ...

class MeshcatVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: Rgba
    delete_on_initialization_event: bool
    enable_alpha_slider: bool
    include_unspecified_accepting: Any
    prefix: str
    publish_period: float
    role: Role
    show_hydroelastic: bool
    visible_by_default: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MeshcatVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> MeshcatVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class MeshcatVisualizer_ð“£AutoDiffXdð“¤(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ð“£AutoDiffXdð“¤, scene_graph: SceneGraph_ð“£AutoDiffXdð“¤, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer_ð“£AutoDiffXdð“¤: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...

class NullTexture:
    __fields__: ClassVar[tuple] = ...  # read-only
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> NullTexture: ...
    def __deepcopy__(self, arg0: dict) -> NullTexture: ...

class PenetrationAsPointPair:
    depth: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_WCa: numpy.ndarray[numpy.float64[3,1]]
    p_WCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PerceptionProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: PerceptionProperties) -> None: ...
    def __copy__(self) -> PerceptionProperties: ...
    def __deepcopy__(self, arg0: dict) -> PerceptionProperties: ...

class PolygonSurfaceMesh:
    def __init__(self) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh) -> bool: ...
    def area(self, f: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh: ...

class PolygonSurfaceMeshFieldLinear:
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...

class PolygonSurfaceMeshFieldLinear_ð“£AutoDiffXdð“¬AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[object[3,1]]: ...

class PolygonSurfaceMesh_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_ð“£AutoDiffXdð“¤) -> bool: ...
    def area(self, f: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[object[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_ð“£AutoDiffXdð“¤: ...

class ProximityProperties(GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: ProximityProperties) -> None: ...
    def __copy__(self) -> ProximityProperties: ...
    def __deepcopy__(self, arg0: dict) -> ProximityProperties: ...

class QueryObject:
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector: ...

class QueryObject_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ð“£AutoDiffXdð“¤: ...

class QueryObject_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ð“£Expressionð“¤: ...

class RenderCameraCore:
    def __init__(self, other: RenderCameraCore) -> None: ...
    def clipping(self) -> ClippingRange: ...
    def intrinsics(self, *args, **kwargs) -> Any: ...
    def renderer_name(self) -> str: ...
    def sensor_pose_in_camera_body(self) -> pydrake.math.RigidTransform: ...
    def __copy__(self) -> RenderCameraCore: ...
    def __deepcopy__(self, arg0: dict) -> RenderCameraCore: ...

class RenderEngine:
    def __init__(self) -> None: ...
    def Clone(self) -> RenderEngine: ...
    @classmethod
    def GetColorDFromLabel(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def GetColorIFromLabel(cls, *args, **kwargs) -> Any: ...
    def GetRenderLabelOrThrow(self, *args, **kwargs) -> Any: ...
    @classmethod
    def LabelFromColor(cls, *args, **kwargs) -> Any: ...
    def RegisterVisual(self, id: GeometryId, shape: Shape, properties: PerceptionProperties, X_WG: pydrake.math.RigidTransform, needs_updates: bool = ...) -> bool: ...
    def RemoveGeometry(self, id: GeometryId) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def SetDefaultLightPosition(self, X_DL: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @classmethod
    def ThrowIfInvalid(cls, *args, **kwargs) -> Any: ...
    def UpdateViewpoint(self, X_WR: pydrake.math.RigidTransform) -> None: ...
    def default_render_label(self, *args, **kwargs) -> Any: ...
    def has_geometry(self, id: GeometryId) -> bool: ...

class RenderEngineGlParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_clear_color: Rgba
    default_diffuse: Rgba
    default_label: RenderLabel
    lights: List[LightParameter]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> RenderEngineGlParams: ...
    def __deepcopy__(self, arg0: dict) -> RenderEngineGlParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class RenderEngineGltfClientParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    base_url: str
    cleanup: bool
    default_label: Optional[RenderLabel]
    render_endpoint: Any
    verbose: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> RenderEngineGltfClientParams: ...
    def __deepcopy__(self, arg0: dict) -> RenderEngineGltfClientParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class RenderEngineVtkParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    default_clear_color: numpy.ndarray[numpy.float64[3,1]]
    default_diffuse: Optional[numpy.ndarray[numpy.float64[4,1]]]
    default_label: Optional[RenderLabel]
    environment_map: Optional[EnvironmentMap]
    lights: List[LightParameter]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> RenderEngineVtkParams: ...
    def __deepcopy__(self, arg0: dict) -> RenderEngineVtkParams: ...

class RenderLabel:
    _pybind11_del_orig: ClassVar[None] = ...
    kDoNotRender: ClassVar[RenderLabel] = ...
    kDontCare: ClassVar[RenderLabel] = ...
    kEmpty: ClassVar[RenderLabel] = ...
    kMaxUnreserved: ClassVar[int] = ...
    kUnspecified: ClassVar[RenderLabel] = ...
    __hash__: ClassVar[None] = ...
    def __init__(self, value: int) -> None: ...
    def is_reserved(self) -> bool: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    @overload
    def __eq__(self, arg0: RenderLabel) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, arg0: RenderLabel) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...

class Rgba:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    __hash__: ClassVar[None] = ...
    rgba: numpy.ndarray[numpy.float64[4,1]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def g(self) -> float: ...
    def r(self) -> float: ...
    def scale_rgb(self, scale: float) -> Rgba: ...
    @overload
    def set(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    @overload
    def set(self, rgba: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def update(self, r: Optional[float] = ..., g: Optional[float] = ..., b: Optional[float] = ..., a: Optional[float] = ...) -> None: ...
    def __copy__(self) -> Rgba: ...
    def __deepcopy__(self, arg0: dict) -> Rgba: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, arg0: Rgba) -> bool: ...
    def __mul__(self, arg0: Rgba) -> Rgba: ...
    def __ne__(self, arg0: Rgba) -> bool: ...

class Role:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kIllustration: ClassVar[Role] = ...
    kPerception: ClassVar[Role] = ...
    kProximity: ClassVar[Role] = ...
    kUnassigned: ClassVar[Role] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RoleAssign:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNew: ClassVar[RoleAssign] = ...
    kReplace: ClassVar[RoleAssign] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SceneGraph(pydrake.systems.framework.LeafSystem):
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort: ...
    def model_inspector(self) -> SceneGraphInspector: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class SceneGraphInspector:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh,VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraphInspector_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh,VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraphInspector_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh,VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class SceneGraph_ð“£AutoDiffXdð“¤(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ð“£AutoDiffXdð“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class SceneGraph_ð“£Expressionð“¤(pydrake.systems.framework.LeafSystem_ð“£Expressionð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ð“£Expressionð“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£Expressionð“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£Expressionð“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ð“£Expressionð“¤: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class Shape:
    def __init__(self, *args, **kwargs) -> None: ...
    def Clone(self) -> Shape: ...
    def __copy__(self) -> Shape: ...
    def __deepcopy__(self, arg0: dict) -> Shape: ...

class SignedDistancePair:
    distance: float
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_ACa: numpy.ndarray[numpy.float64[3,1]]
    p_BCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint:
    distance: float
    grad_W: numpy.ndarray[numpy.float64[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_ð“£Expressionð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SourceId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> SourceId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: SourceId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: SourceId) -> bool: ...
    def __ne__(self, arg0: SourceId) -> bool: ...

class Sphere(Shape):
    def __init__(self, radius: float) -> None: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> float: ...
    def __setstate__(self, arg0: float) -> None: ...

class SurfacePolygon:
    def __init__(self, *args, **kwargs) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...

class SurfaceTriangle:
    def __init__(self, v0: int, v1: int, v2: int) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> SurfaceTriangle: ...
    def __deepcopy__(self, arg0: dict) -> SurfaceTriangle: ...

class TriangleSurfaceMesh:
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh) -> bool: ...
    def area(self, t: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class TriangleSurfaceMeshFieldLinear:
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...

class TriangleSurfaceMeshFieldLinear_ð“£AutoDiffXdð“¬AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...

class TriangleSurfaceMesh_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], t: int) -> numpy.ndarray[object[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_ð“£AutoDiffXdð“¤) -> bool: ...
    def area(self, t: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class VolumeElement:
    def __init__(self, v0: int, v1: int, v2: int, v3: int) -> None: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> VolumeElement: ...
    def __deepcopy__(self, arg0: dict) -> VolumeElement: ...

class VolumeMesh:
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], e: int) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> float: ...
    def CalcVolume(self) -> float: ...
    def Equal(self, mesh: VolumeMesh, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class VolumeMesh_ð“£AutoDiffXdð“¤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], e: int) -> numpy.ndarray[object[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcVolume(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def Equal(self, mesh: VolumeMesh_ð“£AutoDiffXdð“¤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class _TemporaryName_N5drake5ValueINS_8geometry11QueryObjectIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: QueryObject_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> QueryObject_ð“£AutoDiffXdð“¤: ...
    def get_value(self) -> QueryObject_ð“£AutoDiffXdð“¤: ...
    def set_value(self, arg0: QueryObject_ð“£AutoDiffXdð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry11QueryObjectINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: QueryObject_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> QueryObject_ð“£Expressionð“¤: ...
    def get_value(self) -> QueryObject_ð“£Expressionð“¤: ...
    def set_value(self, arg0: QueryObject_ð“£Expressionð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry11QueryObjectIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: QueryObject) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> QueryObject: ...
    def get_value(self) -> QueryObject: ...
    def set_value(self, arg0: QueryObject) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry16KinematicsVectorINS_10IdentifierINS1_8FrameTagEEENS_4math14RigidTransformIN5Eigen14AutoDiffScalarINS8_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FramePoseVector_ð“£AutoDiffXdð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FramePoseVector_ð“£AutoDiffXdð“¤: ...
    def get_value(self) -> FramePoseVector_ð“£AutoDiffXdð“¤: ...
    def set_value(self, arg0: FramePoseVector_ð“£AutoDiffXdð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry16KinematicsVectorINS_10IdentifierINS1_8FrameTagEEENS_4math14RigidTransformINS_8symbolic10ExpressionEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FramePoseVector_ð“£Expressionð“¤) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FramePoseVector_ð“£Expressionð“¤: ...
    def get_value(self) -> FramePoseVector_ð“£Expressionð“¤: ...
    def set_value(self, arg0: FramePoseVector_ð“£Expressionð“¤) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry16KinematicsVectorINS_10IdentifierINS1_8FrameTagEEENS_4math14RigidTransformIdEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FramePoseVector) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FramePoseVector: ...
    def get_value(self) -> FramePoseVector: ...
    def set_value(self, arg0: FramePoseVector) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry4RgbaEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: Rgba) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> Rgba: ...
    def get_value(self) -> Rgba: ...
    def set_value(self, arg0: Rgba) -> None: ...

class _TemporaryName_N5drake5ValueINS_8geometry6render11RenderLabelEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: RenderLabel) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> RenderLabel: ...
    def get_value(self) -> RenderLabel: ...
    def set_value(self, arg0: RenderLabel) -> None: ...

class _TemporaryName_N5drake8geometry10SceneGraphIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ð“£AutoDiffXdð“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ð“£AutoDiffXdð“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class _TemporaryName_N5drake8geometry10SceneGraphINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_ð“£Expressionð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, source_id: SourceId, geometry_id: GeometryId, properties: ProximityProperties, assign: RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, source_id: SourceId, geometry_id: GeometryId, shape: Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: SourceId, geometry: GeometryInstance) -> GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, frame: GeometryFrame) -> FrameId: ...
    @overload
    def RegisterFrame(self, source_id: SourceId, parent_id: FrameId, frame: GeometryFrame) -> FrameId: ...
    def RegisterGeometry(self, source_id: SourceId, frame_id: FrameId, geometry: GeometryInstance) -> GeometryId: ...
    def RegisterSource(self, name: str = ...) -> SourceId: ...
    def RemoveGeometry(self, source_id: SourceId, geometry_id: GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤, source_id: SourceId, frame_id: FrameId, role: Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_ð“£Expressionð“¤) -> CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_ð“£Expressionð“¤: ...
    def get_source_configuration_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£Expressionð“¤: ...
    def get_source_pose_port(self, arg0: SourceId) -> pydrake.systems.framework.InputPort_ð“£Expressionð“¤: ...
    def model_inspector(self) -> SceneGraphInspector_ð“£Expressionð“¤: ...
    @classmethod
    def world_frame_id(cls) -> FrameId: ...

class _TemporaryName_N5drake8geometry10VolumeMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[VolumeElement], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], e: int) -> numpy.ndarray[object[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcVolume(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def Equal(self, mesh: VolumeMesh_ð“£AutoDiffXdð“¤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class _TemporaryName_N5drake8geometry11QueryObjectIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ð“£AutoDiffXdð“¤: ...

class _TemporaryName_N5drake8geometry11QueryObjectINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...
    @overload
    def GetPoseInWorld(self, frame_id: FrameId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> SceneGraphInspector_ð“£Expressionð“¤: ...

class _TemporaryName_N5drake8geometry14ContactSurfaceIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: ContactSurface_ð“£AutoDiffXdð“¤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    def id_M(self) -> GeometryId: ...
    def id_N(self) -> GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> PolygonSurfaceMeshFieldLinear_ð“£AutoDiffXdð“¬AutoDiffXdð“¤: ...
    def poly_mesh_W(self) -> PolygonSurfaceMesh_ð“£AutoDiffXdð“¤: ...
    def representation(self) -> HydroelasticContactRepresentation: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tri_e_MN(self) -> TriangleSurfaceMeshFieldLinear_ð“£AutoDiffXdð“¬AutoDiffXdð“¤: ...
    def tri_mesh_W(self) -> TriangleSurfaceMesh_ð“£AutoDiffXdð“¤: ...
    def __copy__(self) -> ContactSurface_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> ContactSurface_ð“£AutoDiffXdð“¤: ...

class _TemporaryName_N5drake8geometry15DrakeVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ð“£AutoDiffXdð“¤, scene_graph: SceneGraph_ð“£AutoDiffXdð“¤, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: DrakeVisualizerParams = ...) -> DrakeVisualizer_ð“£AutoDiffXdð“¤: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: SceneGraph_ð“£AutoDiffXdð“¤, lcm: pydrake.lcm.DrakeLcmInterface, params: DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEENS0_18PolygonSurfaceMeshIS6_EEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[object[3,1]]: ...

class _TemporaryName_N5drake8geometry15MeshFieldLinearIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEENS0_19TriangleSurfaceMeshIS6_EEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...

class _TemporaryName_N5drake8geometry16KinematicsVectorINS_10IdentifierINS0_8FrameTagEEENS_4math14RigidTransformIN5Eigen14AutoDiffScalarINS7_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ð“£AutoDiffXdð“¤: ...

class _TemporaryName_N5drake8geometry16KinematicsVectorINS_10IdentifierINS0_8FrameTagEEENS_4math14RigidTransformINS_8symbolic10ExpressionEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: FrameId) -> bool: ...
    @overload
    def ids(self) -> List[FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: FrameId, value: pydrake.math.RigidTransform_ð“£Expressionð“¤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: FrameId) -> pydrake.math.RigidTransform_ð“£Expressionð“¤: ...

class _TemporaryName_N5drake8geometry17MeshcatVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_ð“£AutoDiffXdð“¤, scene_graph: SceneGraph_ð“£AutoDiffXdð“¤, meshcat: Meshcat, params: MeshcatVisualizerParams = ...) -> MeshcatVisualizer_ð“£AutoDiffXdð“¤: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...

class _TemporaryName_N5drake8geometry18PolygonSurfaceMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def Equal(self, mesh: PolygonSurfaceMesh_ð“£AutoDiffXdð“¤) -> bool: ...
    def area(self, f: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[object[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> PolygonSurfaceMesh_ð“£AutoDiffXdð“¤: ...
    def __deepcopy__(self, arg0: dict) -> PolygonSurfaceMesh_ð“£AutoDiffXdð“¤: ...

class _TemporaryName_N5drake8geometry18SignedDistancePairIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry18SignedDistancePairINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry19SceneGraphInspectorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh,VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class _TemporaryName_N5drake8geometry19SceneGraphInspectorINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: FrameId, source_id: SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: GeometryId, source_id: SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: GeometryId) -> GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: GeometryId, geometry_id2: GeometryId) -> bool: ...
    def FramesForSource(self, source_id: SourceId) -> Set[FrameId]: ...
    def GetAllFrameIds(self) -> List[FrameId]: ...
    def GetAllGeometryIds(self) -> List[GeometryId]: ...
    def GetAllSourceIds(self) -> List[SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[GeometryId,GeometryId]]: ...
    def GetFrameGroup(self, frame_id: FrameId) -> int: ...
    def GetFrameId(self, geometry_id: GeometryId) -> FrameId: ...
    def GetGeometries(self, frame_id: FrameId, role: Optional[Role] = ...) -> List[GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: FrameId, role: Role, name: str) -> GeometryId: ...
    def GetGeometryIds(self, geometry_set: GeometrySet, role: Optional[Role] = ...) -> Set[GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: GeometryId) -> IllustrationProperties: ...
    @overload
    def GetName(self, source_id: SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: GeometryId) -> PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: GeometryId, role: Role) -> GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: GeometryId) -> ProximityProperties: ...
    def GetShape(self, geometry_id: GeometryId) -> Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: FrameId, role: Role) -> int: ...
    def NumGeometriesWithRole(self, role: Role) -> int: ...
    def SourceIsRegistered(self, source_id: SourceId) -> bool: ...
    def geometry_version(self) -> GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: GeometryId) -> Union[None,TriangleSurfaceMesh,VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> FrameId: ...

class _TemporaryName_N5drake8geometry19TriangleSurfaceMeshIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[SurfaceTriangle], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], t: int) -> numpy.ndarray[object[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def Equal(self, mesh: TriangleSurfaceMesh_ð“£AutoDiffXdð“¤) -> bool: ...
    def area(self, t: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def triangles(self) -> List[SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class _TemporaryName_N5drake8geometry21SignedDistanceToPointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry21SignedDistanceToPointINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    grad_W: numpy.ndarray[object[3,1]]
    id_G: GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry22PenetrationAsPointPairIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.autodiffutils.AutoDiffXd
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry22PenetrationAsPointPairINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.symbolic.Expression
    id_A: GeometryId
    id_B: GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class _TemporaryName_N5drake8geometry27MeshcatPointCloudVisualizerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_ð“£AutoDiffXdð“¤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_ð“£AutoDiffXdð“¤: ...
    def set_default_rgba(self, arg0: Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

def AddCompliantHydroelasticProperties(resolution_hint: float, hydroelastic_modulus: float, properties: ProximityProperties) -> None: ...
def AddCompliantHydroelasticPropertiesForHalfSpace(slab_thickness: float, hydroelastic_modulus: float, properties: ProximityProperties) -> None: ...
@overload
def AddContactMaterial(dissipation: Optional[float], point_stiffness: Optional[float], friction, properties: ProximityProperties) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
@overload
def AddContactMaterial(properties: ProximityProperties, dissipation: Optional[float] = ..., point_stiffness: Optional[float] = ..., friction = ...) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
def AddRigidHydroelasticProperties(resolution_hint: float, properties: ProximityProperties) -> None: ...
def CalcVolume(shape: Shape) -> float: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: VolumeMesh) -> TriangleSurfaceMesh: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: VolumeMesh_ð“£AutoDiffXdð“¤) -> TriangleSurfaceMesh_ð“£AutoDiffXdð“¤: ...
def FindResourceOrThrow(resource_path: str) -> str: ...
def MakePhongIllustrationProperties(diffuse: numpy.ndarray[numpy.float64[4,1]]) -> IllustrationProperties: ...
def MakeRenderEngineGl(params: RenderEngineGlParams = ...) -> RenderEngine: ...
@overload
def MakeRenderEngineGltfClient(params: RenderEngineGltfClientParams = ...) -> RenderEngine: ...
@overload
def MakeRenderEngineGltfClient(params) -> Any: ...
@overload
def MakeRenderEngineGltfClient() -> Any: ...
def MakeRenderEngineVtk(params: RenderEngineVtkParams) -> RenderEngine: ...
def ReadObjToTriangleSurfaceMesh(*args, **kwargs) -> Any: ...
