from typing import Any, ClassVar, Dict, List, Optional, Tuple, Union

from typing import overload
import flags
import numpy
import os
import pydrake.autodiffutils
import pydrake.common
import pydrake.geometry
import pydrake.geometry.optimization
import pydrake.lcm
import pydrake.math
import pydrake.solvers
import pydrake.symbolic
import pydrake.systems.framework
CSpaceSeparatingPlane_: pydrake.common.cpp_template.TemplateClass
ContactSurface_: pydrake.common.cpp_template.TemplateClass
DrakeVisualizer_: pydrake.common.cpp_template.TemplateClass
FramePoseVector_: pydrake.common.cpp_template.TemplateClass
MeshcatPointCloudVisualizer_: pydrake.common.cpp_template.TemplateClass
MeshcatVisualizer_: pydrake.common.cpp_template.TemplateClass
PenetrationAsPointPair_: pydrake.common.cpp_template.TemplateClass
PolygonSurfaceMeshFieldLinear_: pydrake.common.cpp_template.TemplateClass
PolygonSurfaceMesh_: pydrake.common.cpp_template.TemplateClass
QueryObject_: pydrake.common.cpp_template.TemplateClass
SceneGraphInspector_: pydrake.common.cpp_template.TemplateClass
SceneGraph_: pydrake.common.cpp_template.TemplateClass
SignedDistancePair_: pydrake.common.cpp_template.TemplateClass
SignedDistanceToPoint_: pydrake.common.cpp_template.TemplateClass
StartMeshcat: function
TriangleSurfaceMeshFieldLinear_: pydrake.common.cpp_template.TemplateClass
TriangleSurfaceMesh_: pydrake.common.cpp_template.TemplateClass
VolumeMesh_: pydrake.common.cpp_template.TemplateClass

class AffineBall(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, B: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], center: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, ellipsoid: pydrake.geometry.optimization.Hyperellipsoid) -> None: ...
    def B(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def Clone(self) -> pydrake.geometry.optimization.ConvexSet: ...
    @classmethod
    def MakeAxisAligned(cls, radius: numpy.ndarray[numpy.float64[m,1]], center: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.geometry.optimization.AffineBall: ...
    @classmethod
    def MakeHypersphere(cls, radius: float, center: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.geometry.optimization.AffineBall: ...
    @classmethod
    def MakeUnitBall(cls, dim: int) -> pydrake.geometry.optimization.AffineBall: ...
    @classmethod
    def MinimumVolumeCircumscribedEllipsoid(cls, points: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], rank_tol: float = ...) -> pydrake.geometry.optimization.AffineBall: ...
    def center(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def __copy__(self) -> pydrake.geometry.optimization.ConvexSet: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.optimization.ConvexSet: ...

class AffineSubspace(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], translation: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, set: pydrake.geometry.optimization.ConvexSet, tol: float = ...) -> None: ...
    def AffineDimension(self) -> int: ...
    def Clone(self) -> pydrake.geometry.optimization.ConvexSet: ...
    def ContainedIn(self, other: pydrake.geometry.optimization.AffineSubspace, tol: float = ...) -> bool: ...
    def IsNearlyEqualTo(self, other: pydrake.geometry.optimization.AffineSubspace, tol: float = ...) -> bool: ...
    def OrthogonalComplementBasis(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def Project(self, x: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def ToGlobalCoordinates(self, y: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def ToLocalCoordinates(self, x: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def ToLocalCoordinates(self, x) -> Any: ...
    def basis(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def translation(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def __copy__(self) -> pydrake.geometry.optimization.ConvexSet: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.optimization.ConvexSet: ...

class Box(pydrake.geometry.Shape):
    def __init__(self, width: float, depth: float, height: float) -> None: ...
    def depth(self) -> float: ...
    def height(self) -> float: ...
    def size(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def width(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class CIrisCollisionGeometry:
    def __init__(self, *args, **kwargs) -> None: ...
    def X_BG(self) -> pydrake.math.RigidTransform: ...
    def body_index(self, *args, **kwargs) -> Any: ...
    def geometry(self) -> pydrake.geometry.Shape: ...
    def id(self) -> pydrake.geometry.GeometryId: ...
    def num_rationals(self) -> int: ...
    def type(self) -> pydrake.geometry.optimization.CIrisGeometryType: ...

class CIrisGeometryType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kCapsule: ClassVar[pydrake.geometry.optimization.CIrisGeometryType] = ...
    kCylinder: ClassVar[pydrake.geometry.optimization.CIrisGeometryType] = ...
    kPolytope: ClassVar[pydrake.geometry.optimization.CIrisGeometryType] = ...
    kSphere: ClassVar[pydrake.geometry.optimization.CIrisGeometryType] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CSpaceSeparatingPlane:
    def __init__(self, *args, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.optimization.CSpaceSeparatingPlane: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.optimization.CSpaceSeparatingPlane: ...
    @property
    def a(self) -> numpy.ndarray[object[3,1]]: ...
    @property
    def b(self) -> pydrake.symbolic.Polynomial: ...
    @property
    def decision_variables(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def expressed_body(self) -> Any: ...
    @property
    def negative_side_geometry(self) -> pydrake.geometry.optimization.CIrisCollisionGeometry: ...
    @property
    def plane_degree(self) -> int: ...
    @property
    def positive_side_geometry(self) -> pydrake.geometry.optimization.CIrisCollisionGeometry: ...

class CSpaceSeparatingPlane_𝓣Variable𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.optimization.CSpaceSeparatingPlane_𝓣Variable𝓤: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.optimization.CSpaceSeparatingPlane_𝓣Variable𝓤: ...
    @property
    def a(self) -> numpy.ndarray[object[3,1]]: ...
    @property
    def b(self) -> pydrake.symbolic.Polynomial: ...
    @property
    def decision_variables(self) -> numpy.ndarray[object[m,1]]: ...
    @property
    def expressed_body(self) -> Any: ...
    @property
    def negative_side_geometry(self) -> pydrake.geometry.optimization.CIrisCollisionGeometry: ...
    @property
    def plane_degree(self) -> int: ...
    @property
    def positive_side_geometry(self) -> pydrake.geometry.optimization.CIrisCollisionGeometry: ...

class Capsule(pydrake.geometry.Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class CartesianProduct(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sets: List[pydrake.geometry.optimization.ConvexSet]) -> None: ...
    @overload
    def __init__(self, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -> None: ...
    @overload
    def __init__(self, sets: List[pydrake.geometry.optimization.ConvexSet], A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], b: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    def factor(self, index: int) -> pydrake.geometry.optimization.ConvexSet: ...
    def num_factors(self) -> int: ...

class ClippingRange:
    @overload
    def __init__(self, other: pydrake.geometry.ClippingRange) -> None: ...
    @overload
    def __init__(self, near: float, far: float) -> None: ...
    def far(self) -> float: ...
    def near(self) -> float: ...

class CollisionFilterDeclaration:
    def __init__(self) -> None: ...
    def AllowBetween(self, *args, **kwargs) -> Any: ...
    def AllowWithin(self, *args, **kwargs) -> Any: ...
    def ExcludeBetween(self, *args, **kwargs) -> Any: ...
    def ExcludeWithin(self, *args, **kwargs) -> Any: ...

class CollisionFilterManager:
    def __init__(self, *args, **kwargs) -> None: ...
    def Apply(self, declaration: pydrake.geometry.CollisionFilterDeclaration) -> None: ...
    def ApplyTransient(self, *args, **kwargs) -> Any: ...
    def IsActive(self, *args, **kwargs) -> Any: ...
    def RemoveDeclaration(self, *args, **kwargs) -> Any: ...
    def has_transient_history(self) -> bool: ...

class ColorRenderCamera:
    def __init__(self, other: pydrake.geometry.ColorRenderCamera) -> None: ...
    def core(self, *args, **kwargs) -> Any: ...
    def show_window(self) -> bool: ...
    def __copy__(self) -> pydrake.geometry.ColorRenderCamera: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.ColorRenderCamera: ...

class ContactSurface:
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: pydrake.geometry.ContactSurface) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> float: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def id_M(self) -> pydrake.geometry.GeometryId: ...
    def id_N(self) -> pydrake.geometry.GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> pydrake.geometry.PolygonSurfaceMeshFieldLinear: ...
    def poly_mesh_W(self) -> pydrake.geometry.PolygonSurfaceMesh: ...
    def representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def total_area(self) -> float: ...
    def tri_e_MN(self) -> pydrake.geometry.TriangleSurfaceMeshFieldLinear: ...
    def tri_mesh_W(self) -> pydrake.geometry.TriangleSurfaceMesh: ...
    def __copy__(self) -> pydrake.geometry.ContactSurface: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.ContactSurface: ...

class ContactSurface_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Equal(self, surface: pydrake.geometry.ContactSurface_𝓣AutoDiffXd𝓤) -> bool: ...
    def EvaluateGradE_M_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def EvaluateGradE_N_W(self, index: int) -> numpy.ndarray[object[3,1]]: ...
    def HasGradE_M(self) -> bool: ...
    def HasGradE_N(self) -> bool: ...
    def area(self, face_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def centroid(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, face_index: int) -> numpy.ndarray[object[3,1]]: ...
    def id_M(self) -> pydrake.geometry.GeometryId: ...
    def id_N(self) -> pydrake.geometry.GeometryId: ...
    def is_triangle(self) -> bool: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def poly_e_MN(self) -> pydrake.geometry.PolygonSurfaceMeshFieldLinear_𝓣AutoDiffXd𝓬AutoDiffXd𝓤: ...
    def poly_mesh_W(self) -> pydrake.geometry.PolygonSurfaceMesh_𝓣AutoDiffXd𝓤: ...
    def representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def tri_e_MN(self) -> pydrake.geometry.TriangleSurfaceMeshFieldLinear_𝓣AutoDiffXd𝓬AutoDiffXd𝓤: ...
    def tri_mesh_W(self) -> pydrake.geometry.TriangleSurfaceMesh_𝓣AutoDiffXd𝓤: ...
    def __copy__(self) -> pydrake.geometry.ContactSurface_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.ContactSurface_𝓣AutoDiffXd𝓤: ...

class Convex(pydrake.geometry.Shape):
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    @overload
    def extension(self) -> str: ...
    @overload
    def extension(self) -> Any: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...
    def __getstate__(self) -> Tuple[str,float]: ...
    def __setstate__(self, arg0: Tuple[str,float]) -> None: ...

class ConvexSet:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def AddPointInNonnegativeScalingConstraints(self, prog: pydrake.solvers.MathematicalProgram, x: numpy.ndarray[object[m,1]], t: pydrake.symbolic.Variable) -> List[pydrake.solvers.Binding𝓣Constraint𝓤]: ...
    @overload
    def AddPointInNonnegativeScalingConstraints(self, prog: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], b: numpy.ndarray[numpy.float64[m,1]], c: numpy.ndarray[numpy.float64[m,1]], d: float, x: numpy.ndarray[object[m,1]], t: numpy.ndarray[object[m,1]]) -> List[pydrake.solvers.Binding𝓣Constraint𝓤]: ...
    def AddPointInSetConstraints(self, prog: pydrake.solvers.MathematicalProgram, vars: numpy.ndarray[object[m,1]]) -> Tuple[numpy.ndarray[object[m,1]],List[pydrake.solvers.Binding𝓣Constraint𝓤]]: ...
    def CalcVolume(self) -> float: ...
    def Clone(self) -> pydrake.geometry.optimization.ConvexSet: ...
    def IntersectsWith(self, other: pydrake.geometry.optimization.ConvexSet) -> bool: ...
    def IsBounded(self) -> bool: ...
    def IsEmpty(self) -> bool: ...
    def MaybeGetFeasiblePoint(self) -> Optional[numpy.ndarray[numpy.float64[m,1]]]: ...
    def MaybeGetPoint(self) -> Optional[numpy.ndarray[numpy.float64[m,1]]]: ...
    def PointInSet(self, x: numpy.ndarray[numpy.float64[m,1]], tol: float = ...) -> bool: ...
    def ToShapeWithPose(self) -> Tuple[pydrake.geometry.Shape,pydrake.math.RigidTransform]: ...
    @overload
    def ambient_dimension(self) -> int: ...
    @overload
    def ambient_dimension(self) -> Any: ...

class CspaceFreePolytope(pydrake.geometry.optimization.CspaceFreePolytopeBase):
    class BilinearAlternationOptions:
        convergence_tol: float
        ellipsoid_scaling: float
        find_polytope_options: pydrake.geometry.optimization.CspaceFreePolytope.FindPolytopeGivenLagrangianOptions
        max_iter: int
        def __init__(self) -> None: ...
        @property
        def find_lagrangian_options(self) -> pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions: ...

    class BinarySearchOptions:
        convergence_tol: float
        max_iter: int
        scale_max: float
        scale_min: float
        def __init__(self) -> None: ...
        @property
        def find_lagrangian_options(self) -> pydrake.geometry.optimization.CspaceFreePolytope.FindSeparationCertificateGivenPolytopeOptions: ...

    class EllipsoidMarginCost:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kGeometricMean: ClassVar[pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost] = ...
        kSum: ClassVar[pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FindPolytopeGivenLagrangianOptions:
        backoff_scale: Optional[float]
        ellipsoid_margin_cost: pydrake.geometry.optimization.CspaceFreePolytope.EllipsoidMarginCost
        ellipsoid_margin_epsilon: float
        s_inner_pts: Optional[numpy.ndarray[numpy.float64[m,n]]]
        search_s_bounds_lagrangians: bool
        solver_id: pydrake.solvers.SolverId
        solver_options: Optional[pydrake.solvers.SolverOptions]
        def __init__(self) -> None: ...

    class FindSeparationCertificateGivenPolytopeOptions(pydrake.geometry.optimization.FindSeparationCertificateOptions):
        ignore_redundant_C: bool
        def __init__(self) -> None: ...

    class SearchResult:
        def __init__(self) -> None: ...
        def C(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
        def a(self) -> Dict[int,numpy.ndarray[object[3,1]]]: ...
        def b(self) -> Dict[int,pydrake.symbolic.Polynomial]: ...
        def certified_polytope(self) -> pydrake.geometry.optimization.HPolyhedron: ...
        def d(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
        def num_iter(self) -> int: ...

    class SeparatingPlaneLagrangians:
        def __init__(self, C_rows: int, s_size: int) -> None: ...
        def GetSolution(self, result: pydrake.solvers.MathematicalProgramResult) -> pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians: ...
        def polytope(self) -> numpy.ndarray[object[m,1]]: ...
        def s_lower(self) -> numpy.ndarray[object[m,1]]: ...
        def s_upper(self) -> numpy.ndarray[object[m,1]]: ...

    class SeparationCertificate:
        negative_side_rational_lagrangians: List[pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians]
        positive_side_rational_lagrangians: List[pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians]
        def __init__(self, *args, **kwargs) -> None: ...
        def GetSolution(self, plane_index: int, a: numpy.ndarray[object[3,1]], b: pydrake.symbolic.Polynomial, plane_decision_vars: numpy.ndarray[object[m,1]], result: pydrake.solvers.MathematicalProgramResult) -> pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificateResult: ...

    class SeparationCertificateProgram(pydrake.geometry.optimization.SeparationCertificateProgramBase):
        def __init__(self) -> None: ...
        @property
        def certificate(self) -> pydrake.geometry.optimization.CspaceFreePolytope.SeparationCertificate: ...
        @property
        def plane_index(self) -> int: ...

    class SeparationCertificateResult:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def a(self) -> numpy.ndarray[object[3,1]]: ...
        @property
        def b(self) -> pydrake.symbolic.Polynomial: ...
        @property
        def negative_side_rational_lagrangians(self) -> List[pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians]: ...
        @property
        def plane_decision_var_vals(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
        @property
        def plane_index(self) -> int: ...
        @property
        def positive_side_rational_lagrangians(self) -> List[pydrake.geometry.optimization.CspaceFreePolytope.SeparatingPlaneLagrangians]: ...
        @property
        def result(self) -> pydrake.solvers.MathematicalProgramResult: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def BinarySearch(self, *args, **kwargs) -> Any: ...
    def FindSeparationCertificateGivenPolytope(self, *args, **kwargs) -> Any: ...
    def MakeIsGeometrySeparableProgram(self, *args, **kwargs) -> Any: ...
    def SearchWithBilinearAlternation(self, *args, **kwargs) -> Any: ...
    def SolveSeparationCertificateProgram(self, *args, **kwargs) -> Any: ...

class CspaceFreePolytopeBase:
    class Options:
        _pybind11_del_orig: ClassVar[None] = ...
        with_cross_y: bool
        def __init__(self) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def map_geometries_to_separating_planes(self) -> Dict[Tuple[pydrake.geometry.GeometryId],int]: ...
    def separating_planes(self) -> List[pydrake.geometry.optimization.CSpaceSeparatingPlane_𝓣Variable𝓤]: ...
    def y_slack(self) -> numpy.ndarray[object[3,1]]: ...

class Cylinder(pydrake.geometry.Shape):
    @overload
    def __init__(self, radius: float, length: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def length(self) -> float: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class DepthRange:
    @overload
    def __init__(self, other: pydrake.geometry.DepthRange) -> None: ...
    @overload
    def __init__(self, min_in: float, min_out: float) -> None: ...
    def max_depth(self) -> float: ...
    def min_depth(self) -> float: ...
    def __copy__(self) -> pydrake.geometry.DepthRange: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.DepthRange: ...

class DepthRenderCamera:
    def __init__(self, other: pydrake.geometry.DepthRenderCamera) -> None: ...
    def core(self, *args, **kwargs) -> Any: ...
    def depth_range(self) -> pydrake.geometry.DepthRange: ...
    def __copy__(self) -> pydrake.geometry.DepthRenderCamera: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.DepthRenderCamera: ...

class DrakeVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: pydrake.geometry.DrakeVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, scene_graph: pydrake.geometry.SceneGraph, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: pydrake.geometry.DrakeVisualizerParams = ...) -> pydrake.geometry.DrakeVisualizer: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: pydrake.geometry.SceneGraph, lcm: pydrake.lcm.DrakeLcmInterface, params: pydrake.geometry.DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort: ...

class DrakeVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: pydrake.geometry.Rgba
    publish_period: float
    role: pydrake.geometry.Role
    show_hydroelastic: bool
    use_role_channel_suffix: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.DrakeVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.DrakeVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class DrakeVisualizer_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: pydrake.geometry.DrakeVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_𝓣AutoDiffXd𝓤, scene_graph: pydrake.geometry.SceneGraph_𝓣AutoDiffXd𝓤, lcm: pydrake.lcm.DrakeLcmInterface = ..., params: pydrake.geometry.DrakeVisualizerParams = ...) -> pydrake.geometry.DrakeVisualizer_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def DispatchLoadMessage(cls, scene_graph: pydrake.geometry.SceneGraph_𝓣AutoDiffXd𝓤, lcm: pydrake.lcm.DrakeLcmInterface, params: pydrake.geometry.DrakeVisualizerParams = ...) -> None: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...

class Ellipsoid(pydrake.geometry.Shape):
    @overload
    def __init__(self, a: float, b: float, c: float) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def c(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class EnvironmentMap:
    __fields__: ClassVar[tuple] = ...  # read-only
    skybox: bool
    texture: Union[pydrake.geometry.NullTexture,pydrake.geometry.EquirectangularMap]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.EnvironmentMap: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.EnvironmentMap: ...

class EquirectangularMap:
    __fields__: ClassVar[tuple] = ...  # read-only
    path: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.EquirectangularMap: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.EquirectangularMap: ...

class FilterId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> pydrake.geometry.FilterId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: pydrake.geometry.FilterId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: pydrake.geometry.FilterId) -> bool: ...
    def __ne__(self, arg0: pydrake.geometry.FilterId) -> bool: ...

class FindSeparationCertificateOptions:
    num_threads: int
    solver_id: pydrake.solvers.SolverId
    solver_options: Optional[pydrake.solvers.SolverOptions]
    terminate_at_failure: bool
    verbose: bool
    def __init__(self) -> None: ...

class FrameId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> pydrake.geometry.FrameId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: pydrake.geometry.FrameId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: pydrake.geometry.FrameId) -> bool: ...
    def __ne__(self, arg0: pydrake.geometry.FrameId) -> bool: ...

class FramePoseVector:
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: pydrake.geometry.FrameId) -> bool: ...
    @overload
    def ids(self) -> List[pydrake.geometry.FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: pydrake.geometry.FrameId, value: pydrake.math.RigidTransform) -> None: ...
    def size(self) -> int: ...
    def value(self, id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform: ...

class FramePoseVector_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: pydrake.geometry.FrameId) -> bool: ...
    @overload
    def ids(self) -> List[pydrake.geometry.FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: pydrake.geometry.FrameId, value: pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...

class FramePoseVector_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def has_id(self, id: pydrake.geometry.FrameId) -> bool: ...
    @overload
    def ids(self) -> List[pydrake.geometry.FrameId]: ...
    @overload
    def ids(self) -> Any: ...
    def set_value(self, id: pydrake.geometry.FrameId, value: pydrake.math.RigidTransform_𝓣Expression𝓤) -> None: ...
    def size(self) -> int: ...
    def value(self, id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...

class GeometryFrame:
    def __init__(self, frame_name: str, frame_group_id: int = ...) -> None: ...
    def frame_group(self) -> int: ...
    def id(self, *args, **kwargs) -> Any: ...
    def name(self) -> str: ...
    def __copy__(self) -> pydrake.geometry.GeometryFrame: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.GeometryFrame: ...

class GeometryId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> pydrake.geometry.GeometryId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: pydrake.geometry.GeometryId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: pydrake.geometry.GeometryId) -> bool: ...
    def __ne__(self, arg0: pydrake.geometry.GeometryId) -> bool: ...

class GeometryInstance:
    def __init__(self, *args, **kwargs) -> None: ...
    def id(self, *args, **kwargs) -> Any: ...
    def illustration_properties(self, *args, **kwargs) -> Any: ...
    def mutable_illustration_properties(self, *args, **kwargs) -> Any: ...
    def mutable_perception_properties(self, *args, **kwargs) -> Any: ...
    def mutable_proximity_properties(self, *args, **kwargs) -> Any: ...
    def name(self) -> str: ...
    def perception_properties(self, *args, **kwargs) -> Any: ...
    def pose(self) -> pydrake.math.RigidTransform: ...
    def proximity_properties(self, *args, **kwargs) -> Any: ...
    def set_illustration_properties(self, *args, **kwargs) -> Any: ...
    def set_name(self, arg0: str) -> None: ...
    def set_perception_properties(self, *args, **kwargs) -> Any: ...
    def set_pose(self, X_PG: pydrake.math.RigidTransform) -> None: ...
    def set_proximity_properties(self, *args, **kwargs) -> Any: ...
    def shape(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> pydrake.geometry.GeometryInstance: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.GeometryInstance: ...

class GeometryProperties:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddProperty(self, group_name: str, name: str, value: object) -> None: ...
    def GetGroupNames(self) -> Set[str]: ...
    def GetPropertiesInGroup(self, group_name: str) -> dict: ...
    def GetProperty(self, group_name: str, name: str) -> object: ...
    def GetPropertyOrDefault(self, group_name: str, name: str, default_value: object) -> object: ...
    def HasGroup(self, group_name: str) -> bool: ...
    def HasProperty(self, group_name: str, name: str) -> bool: ...
    def RemoveProperty(self, group_name: str, name: str) -> bool: ...
    def UpdateProperty(self, group_name: str, name: str, value: object) -> None: ...
    @classmethod
    def default_group_name(cls) -> str: ...
    def num_groups(self) -> int: ...

class GeometrySet:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, geometry_ids) -> None: ...
    @overload
    def __init__(self, frame_ids) -> None: ...
    @overload
    def __init__(self, geometry_ids, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids) -> None: ...
    @overload
    def Add(self, frame_ids) -> None: ...
    @overload
    def Add(self, geometry_ids, frame_ids) -> None: ...

class GeometryVersion:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: pydrake.geometry.GeometryVersion) -> None: ...
    def IsSameAs(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> pydrake.geometry.GeometryVersion: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.GeometryVersion: ...

class GraphOfConvexSets:
    class Edge:
        def __init__(self, *args, **kwargs) -> None: ...
        @overload
        def AddConstraint(self, f: pydrake.symbolic.Formula) -> pydrake.solvers.Binding𝓣Constraint𝓤: ...
        @overload
        def AddConstraint(self, binding: pydrake.solvers.Binding𝓣Constraint𝓤) -> pydrake.solvers.Binding𝓣Constraint𝓤: ...
        @overload
        def AddCost(self, e: pydrake.symbolic.Expression) -> Tuple[pydrake.symbolic.Variable,pydrake.solvers.Binding𝓣Cost𝓤]: ...
        @overload
        def AddCost(self, binding: pydrake.solvers.Binding𝓣Cost𝓤) -> Tuple[pydrake.symbolic.Variable,pydrake.solvers.Binding𝓣Cost𝓤]: ...
        def AddPhiConstraint(self, phi_value: bool) -> None: ...
        def ClearPhiConstraints(self) -> None: ...
        def GetConstraints(self) -> List[pydrake.solvers.Binding𝓣Constraint𝓤]: ...
        def GetCosts(self) -> List[pydrake.solvers.Binding𝓣Cost𝓤]: ...
        def GetSolutionCost(self, result: pydrake.solvers.MathematicalProgramResult) -> float: ...
        def GetSolutionPhiXu(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m,1]]: ...
        def GetSolutionPhiXv(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m,1]]: ...
        def id(self) -> pydrake.geometry.optimization.GraphOfConvexSets.EdgeId: ...
        def name(self) -> str: ...
        @overload
        def phi(self) -> pydrake.symbolic.Variable: ...
        @overload
        def phi(self) -> Any: ...
        def u(self) -> pydrake.geometry.optimization.GraphOfConvexSets.Vertex: ...
        def v(self) -> pydrake.geometry.optimization.GraphOfConvexSets.Vertex: ...
        @overload
        def xu(self) -> numpy.ndarray[object[m,1]]: ...
        @overload
        def xu(self) -> Any: ...
        @overload
        def xv(self) -> numpy.ndarray[object[m,1]]: ...
        @overload
        def xv(self) -> Any: ...

    class EdgeId:
        def __init__(self, *args, **kwargs) -> None: ...
        @classmethod
        def get_new_id(cls) -> pydrake.geometry.optimization.GraphOfConvexSets.EdgeId: ...
        def get_value(self) -> int: ...
        def is_valid(self) -> bool: ...
        def __eq__(self, arg0: pydrake.geometry.optimization.GraphOfConvexSets.EdgeId) -> bool: ...
        def __hash__(self) -> int: ...
        def __lt__(self, arg0: pydrake.geometry.optimization.GraphOfConvexSets.EdgeId) -> bool: ...
        def __ne__(self, arg0: pydrake.geometry.optimization.GraphOfConvexSets.EdgeId) -> bool: ...

    class Vertex:
        def __init__(self, *args, **kwargs) -> None: ...
        @overload
        def AddConstraint(self, f: pydrake.symbolic.Formula) -> pydrake.solvers.Binding𝓣Constraint𝓤: ...
        @overload
        def AddConstraint(self, binding: pydrake.solvers.Binding𝓣Constraint𝓤) -> pydrake.solvers.Binding𝓣Constraint𝓤: ...
        @overload
        def AddCost(self, e: pydrake.symbolic.Expression) -> Tuple[pydrake.symbolic.Variable,pydrake.solvers.Binding𝓣Cost𝓤]: ...
        @overload
        def AddCost(self, binding: pydrake.solvers.Binding𝓣Cost𝓤) -> Tuple[pydrake.symbolic.Variable,pydrake.solvers.Binding𝓣Cost𝓤]: ...
        def GetConstraints(self) -> List[pydrake.solvers.Binding𝓣Constraint𝓤]: ...
        def GetCosts(self) -> List[pydrake.solvers.Binding𝓣Cost𝓤]: ...
        def GetSolution(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m,1]]: ...
        def GetSolutionCost(self, result: pydrake.solvers.MathematicalProgramResult) -> float: ...
        def ambient_dimension(self) -> int: ...
        def id(self) -> pydrake.geometry.optimization.GraphOfConvexSets.VertexId: ...
        def incoming_edges(self, *args, **kwargs) -> Any: ...
        def name(self) -> str: ...
        def outgoing_edges(self, *args, **kwargs) -> Any: ...
        def set(self) -> pydrake.geometry.optimization.ConvexSet: ...
        def x(self) -> numpy.ndarray[object[m,1]]: ...

    class VertexId:
        def __init__(self, *args, **kwargs) -> None: ...
        @classmethod
        def get_new_id(cls) -> pydrake.geometry.optimization.GraphOfConvexSets.VertexId: ...
        def get_value(self) -> int: ...
        def is_valid(self) -> bool: ...
        def __eq__(self, arg0: pydrake.geometry.optimization.GraphOfConvexSets.VertexId) -> bool: ...
        def __hash__(self) -> int: ...
        def __lt__(self, arg0: pydrake.geometry.optimization.GraphOfConvexSets.VertexId) -> bool: ...
        def __ne__(self, arg0: pydrake.geometry.optimization.GraphOfConvexSets.VertexId) -> bool: ...
    def __init__(self) -> None: ...
    def AddEdge(self, u: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, v: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, name: str = ...) -> pydrake.geometry.optimization.GraphOfConvexSets.Edge: ...
    def AddVertex(self, set: pydrake.geometry.optimization.ConvexSet, name: str = ...) -> pydrake.geometry.optimization.GraphOfConvexSets.Vertex: ...
    def ClearAllPhiConstraints(self) -> None: ...
    def Edges(self) -> List[pydrake.geometry.optimization.GraphOfConvexSets.Edge]: ...
    def GetGraphvizString(self, result: Optional[pydrake.solvers.MathematicalProgramResult] = ..., show_slacks: bool = ..., precision: int = ..., scientific: bool = ...) -> str: ...
    def GetSolutionPath(self, source: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, target: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, result: pydrake.solvers.MathematicalProgramResult, tolerance: float = ...) -> List[pydrake.geometry.optimization.GraphOfConvexSets.Edge]: ...
    def RemoveEdge(self, edge: pydrake.geometry.optimization.GraphOfConvexSets.Edge) -> None: ...
    def RemoveVertex(self, vertex: pydrake.geometry.optimization.GraphOfConvexSets.Vertex) -> None: ...
    def SolveConvexRestriction(self, active_edges: List[pydrake.geometry.optimization.GraphOfConvexSets.Edge], options: pydrake.geometry.optimization.GraphOfConvexSetsOptions = ...) -> pydrake.solvers.MathematicalProgramResult: ...
    def SolveShortestPath(self, source: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, target: pydrake.geometry.optimization.GraphOfConvexSets.Vertex, options: pydrake.geometry.optimization.GraphOfConvexSetsOptions = ...) -> pydrake.solvers.MathematicalProgramResult: ...
    def Vertices(self) -> List[pydrake.geometry.optimization.GraphOfConvexSets.Vertex]: ...

class GraphOfConvexSetsOptions:
    _pybind11_del_orig: ClassVar[None] = ...
    convex_relaxation: Optional[bool]
    flow_tolerance: float
    max_rounded_paths: Optional[int]
    max_rounding_trials: int
    preprocessing: Optional[bool]
    rounding_seed: int
    rounding_solver_options: Optional[pydrake.solvers.SolverOptions]
    solver: pydrake.solvers.SolverInterface
    solver_options: pydrake.solvers.SolverOptions
    def __init__(self) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class HPolyhedron(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], b: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    def A(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CartesianPower(self, n: int) -> pydrake.geometry.optimization.HPolyhedron: ...
    def CartesianProduct(self, other: pydrake.geometry.optimization.HPolyhedron) -> pydrake.geometry.optimization.HPolyhedron: ...
    def ChebyshevCenter(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def ContainedIn(self, other: pydrake.geometry.optimization.HPolyhedron, tol: float = ...) -> bool: ...
    def FindRedundant(self, tol: float = ...) -> Set[int]: ...
    def Intersection(self, other: pydrake.geometry.optimization.HPolyhedron, check_for_redundancy: bool = ..., tol: float = ...) -> pydrake.geometry.optimization.HPolyhedron: ...
    @classmethod
    def MakeBox(cls, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.geometry.optimization.HPolyhedron: ...
    @classmethod
    def MakeL1Ball(cls, dim: int) -> pydrake.geometry.optimization.HPolyhedron: ...
    @classmethod
    def MakeUnitBox(cls, dim: int) -> pydrake.geometry.optimization.HPolyhedron: ...
    def MaximumVolumeInscribedEllipsoid(self) -> pydrake.geometry.optimization.Hyperellipsoid: ...
    def PontryaginDifference(self, other: pydrake.geometry.optimization.HPolyhedron) -> pydrake.geometry.optimization.HPolyhedron: ...
    def ReduceInequalities(self, tol: float = ...) -> pydrake.geometry.optimization.HPolyhedron: ...
    def Scale(self, scale: float, center: Optional[numpy.ndarray[numpy.float64[m,1]]] = ...) -> pydrake.geometry.optimization.HPolyhedron: ...
    @overload
    def UniformSample(self, generator: pydrake.common.RandomGenerator, previous_sample: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def UniformSample(self, generator: pydrake.common.RandomGenerator) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def b(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def __getstate__(self) -> Tuple[numpy.ndarray[numpy.float64[m,n]],numpy.ndarray[numpy.float64[m,1]]]: ...
    def __setstate__(self, arg0: Tuple[numpy.ndarray[numpy.float64[m,n]],numpy.ndarray[numpy.float64[m,1]]]) -> None: ...

class HalfSpace(pydrake.geometry.Shape):
    def __init__(self) -> None: ...
    @classmethod
    def MakePose(cls, Hz_dir_F: numpy.ndarray[numpy.float64[3,1]], p_FB: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.math.RigidTransform: ...

class HydroelasticContactRepresentation:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kPolygon: ClassVar[pydrake.geometry.HydroelasticContactRepresentation] = ...
    kTriangle: ClassVar[pydrake.geometry.HydroelasticContactRepresentation] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Hyperellipsoid(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], center: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    @overload
    def __init__(self, ellipsoid: pydrake.geometry.optimization.AffineBall) -> None: ...
    def A(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @classmethod
    def MakeAxisAligned(cls, radius: numpy.ndarray[numpy.float64[m,1]], center: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.geometry.optimization.Hyperellipsoid: ...
    @classmethod
    def MakeHypersphere(cls, radius: float, center: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.geometry.optimization.Hyperellipsoid: ...
    @classmethod
    def MakeUnitBall(cls, dim: int) -> pydrake.geometry.optimization.Hyperellipsoid: ...
    def MinimumUniformScalingToTouch(self, other: pydrake.geometry.optimization.ConvexSet) -> Tuple[float,numpy.ndarray[numpy.float64[m,1]]]: ...
    @classmethod
    def MinimumVolumeCircumscribedEllipsoid(cls, points: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], rank_tol: float = ...) -> pydrake.geometry.optimization.Hyperellipsoid: ...
    def center(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def __getstate__(self) -> Tuple[numpy.ndarray[numpy.float64[m,n]],numpy.ndarray[numpy.float64[m,1]]]: ...
    def __setstate__(self, arg0: Tuple[numpy.ndarray[numpy.float64[m,n]],numpy.ndarray[numpy.float64[m,1]]]) -> None: ...

class IllustrationProperties(pydrake.geometry.GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: pydrake.geometry.IllustrationProperties) -> None: ...
    def __copy__(self) -> pydrake.geometry.IllustrationProperties: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.IllustrationProperties: ...

class Intersection(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sets: List[pydrake.geometry.optimization.ConvexSet]) -> None: ...
    @overload
    def __init__(self, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -> None: ...
    def element(self, index: int) -> pydrake.geometry.optimization.ConvexSet: ...
    def num_elements(self) -> int: ...

class IrisOptions:
    _pybind11_del_orig: ClassVar[None] = ...
    bounding_region: Optional[pydrake.geometry.optimization.HPolyhedron]
    configuration_obstacles: object
    configuration_space_margin: float
    iteration_limit: int
    num_additional_constraint_infeasible_samples: int
    num_collision_infeasible_samples: int
    prog_with_additional_constraints: pydrake.solvers.MathematicalProgram
    random_seed: int
    relative_termination_threshold: float
    require_sample_point_is_contained: bool
    starting_ellipse: Optional[pydrake.geometry.optimization.Hyperellipsoid]
    termination_threshold: float
    def __init__(self) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class LightParameter:
    __fields__: ClassVar[tuple] = ...  # read-only
    attenuation_values: numpy.ndarray[numpy.float64[3,1]]
    color: pydrake.geometry.Rgba
    cone_angle: float
    direction: numpy.ndarray[numpy.float64[3,1]]
    frame: str
    intensity: float
    position: numpy.ndarray[numpy.float64[3,1]]
    type: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.LightParameter: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.LightParameter: ...

class Mesh(pydrake.geometry.Shape):
    def __init__(self, filename: str, scale: float = ...) -> None: ...
    @overload
    def extension(self) -> str: ...
    @overload
    def extension(self) -> Any: ...
    def filename(self) -> str: ...
    def scale(self) -> float: ...
    def __getstate__(self) -> Tuple[str,float]: ...
    def __setstate__(self, arg0: Tuple[str,float]) -> None: ...

class Meshcat:
    class Gamepad:
        __fields__: ClassVar[tuple] = ...  # read-only
        axes: List[float]
        button_values: List[float]
        index: Optional[int]
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> pydrake.geometry.Meshcat.Gamepad: ...
        def __deepcopy__(self, arg0: dict) -> pydrake.geometry.Meshcat.Gamepad: ...

    class OrthographicCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        bottom: float
        far: float
        left: float
        near: float
        right: float
        top: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> pydrake.geometry.Meshcat.OrthographicCamera: ...
        def __deepcopy__(self, arg0: dict) -> pydrake.geometry.Meshcat.OrthographicCamera: ...

    class PerspectiveCamera:
        __fields__: ClassVar[tuple] = ...  # read-only
        aspect: float
        far: float
        fov: float
        near: float
        zoom: float
        def __init__(self, **kwargs) -> None: ...
        def __copy__(self) -> pydrake.geometry.Meshcat.PerspectiveCamera: ...
        def __deepcopy__(self, arg0: dict) -> pydrake.geometry.Meshcat.PerspectiveCamera: ...

    class SideOfFaceToRender:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kBackSide: ClassVar[pydrake.geometry.Meshcat.SideOfFaceToRender] = ...
        kDoubleSide: ClassVar[pydrake.geometry.Meshcat.SideOfFaceToRender] = ...
        kFrontSide: ClassVar[pydrake.geometry.Meshcat.SideOfFaceToRender] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    @overload
    def __init__(self, port: Optional[int] = ...) -> None: ...
    @overload
    def __init__(self, params: pydrake.geometry.MeshcatParams) -> None: ...
    def AddButton(self, name: str, keycode: str = ...) -> None: ...
    def AddSlider(self, name: str, min: float, max: float, step: float, value: float, decrement_keycode: str = ..., increment_keycode: str = ...) -> None: ...
    def Delete(self, path: str = ...) -> None: ...
    def DeleteAddedControls(self) -> None: ...
    def DeleteButton(self, name: str) -> None: ...
    def DeleteRecording(self) -> None: ...
    def DeleteSlider(self, name: str) -> None: ...
    def Flush(self) -> None: ...
    def GetButtonClicks(self, name: str) -> int: ...
    def GetGamepad(self, *args, **kwargs) -> Any: ...
    def GetNumActiveConnections(self) -> int: ...
    def GetRealtimeRate(self) -> float: ...
    def GetSliderNames(self) -> List[str]: ...
    def GetSliderValue(self, name: str) -> float: ...
    def HasPath(self, path: str) -> bool: ...
    def PlotSurface(self, path: str, X: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Y: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Z: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], rgba: pydrake.geometry.Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ...) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRenderMode(self) -> None: ...
    def Set2dRenderMode(self, X_WC: pydrake.math.RigidTransform = ..., xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ...) -> None: ...
    def SetAnimation(self) -> Any: ...
    def SetCamera(self, *args, **kwargs) -> Any: ...
    def SetCameraPose(self, camera_in_world: numpy.ndarray[numpy.float64[3,1]], target_in_world: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetCameraTarget(self, target_in_world: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetEnvironmentMap(self, image_path: os.PathLike) -> None: ...
    def SetLine(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], line_width: float = ..., rgba: pydrake.geometry.Rgba = ...) -> None: ...
    def SetLineSegments(self, path: str, start: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], end: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], line_width: float = ..., rgba: pydrake.geometry.Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, shape: pydrake.geometry.Shape, rgba: pydrake.geometry.Rgba = ...) -> None: ...
    @overload
    def SetObject(self, path: str, mesh: pydrake.geometry.TriangleSurfaceMesh, rgba: pydrake.geometry.Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ..., side: pydrake.geometry.Meshcat.SideOfFaceToRender = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: bool, time_in_recording: Optional[float] = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: float, time_in_recording: Optional[float] = ...) -> None: ...
    @overload
    def SetProperty(self, path: str, property: str, value: List[float], time_in_recording: Optional[float] = ...) -> None: ...
    def SetRealtimeRate(self, rate: float) -> None: ...
    def SetSliderValue(self, name: str, value: float) -> None: ...
    def SetTransform(self, path: str, X_ParentPath: pydrake.math.RigidTransform, time_in_recording: Optional[float] = ...) -> None: ...
    def SetTriangleColorMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3,n],flags.f_contiguous], colors: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], wireframe: bool = ..., wireframe_line_width: float = ..., side: pydrake.geometry.Meshcat.SideOfFaceToRender = ...) -> None: ...
    def SetTriangleMesh(self, path: str, vertices: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], faces: numpy.ndarray[numpy.int32[3,n],flags.f_contiguous], rgba: pydrake.geometry.Rgba = ..., wireframe: bool = ..., wireframe_line_width: float = ..., side: pydrake.geometry.Meshcat.SideOfFaceToRender = ...) -> None: ...
    def StartRecording(self, frames_per_second: float = ..., set_visualizations_while_recording: bool = ...) -> None: ...
    def StaticHtml(self) -> str: ...
    def StopRecording(self) -> None: ...
    def _GetPackedObject(self, path: str) -> bytes: ...
    def _GetPackedProperty(self, path: str, property: str) -> bytes: ...
    def _GetPackedTransform(self, path: str) -> bytes: ...
    def _InjectWebsocketMessage(self, message: bytes) -> None: ...
    def get_mutable_recording(self, *args, **kwargs) -> Any: ...
    def port(self) -> int: ...
    def web_url(self) -> str: ...
    def ws_url(self) -> str: ...

class MeshcatAnimation:
    class LoopMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kLoopOnce: ClassVar[pydrake.geometry.MeshcatAnimation.LoopMode] = ...
        kLoopPingPong: ClassVar[pydrake.geometry.MeshcatAnimation.LoopMode] = ...
        kLoopRepeat: ClassVar[pydrake.geometry.MeshcatAnimation.LoopMode] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, frames_per_second: float = ...) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: bool) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: float) -> None: ...
    @overload
    def SetProperty(self, frame: int, path: str, property: str, value: List[float]) -> None: ...
    def SetTransform(self, frame: int, path: str, X_ParentPath: pydrake.math.RigidTransform) -> None: ...
    def autoplay(self) -> bool: ...
    def clamp_when_finished(self) -> bool: ...
    def frame(self, time_from_start: float) -> int: ...
    def frames_per_second(self) -> float: ...
    def loop_mode(self, *args, **kwargs) -> Any: ...
    def repetitions(self) -> int: ...
    def set_autoplay(self, play: bool) -> None: ...
    def set_clamp_when_finished(self, clamp: bool) -> None: ...
    def set_loop_mode(self, *args, **kwargs) -> Any: ...
    def set_repetitions(self, repetitions: int) -> None: ...

class MeshcatCone(pydrake.geometry.Shape):
    @overload
    def __init__(self, height: float, a: float = ..., b: float = ...) -> None: ...
    @overload
    def __init__(self, measures: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def height(self) -> float: ...
    def __getstate__(self) -> Tuple[float,float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float,float]) -> None: ...

class MeshcatParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    host: str
    port: Optional[int]
    show_stats_plot: bool
    web_url_pattern: str
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.MeshcatParams: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.MeshcatParams: ...

class MeshcatPointCloudVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, meshcat: pydrake.geometry.Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort: ...
    def set_default_rgba(self, arg0: pydrake.geometry.Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatPointCloudVisualizer_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: pydrake.geometry.Meshcat, path: str, publish_period: float = ...) -> None: ...
    @overload
    def Delete(self) -> None: ...
    @overload
    def Delete(self, path) -> Any: ...
    def cloud_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def pose_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def set_default_rgba(self, arg0: pydrake.geometry.Rgba) -> None: ...
    def set_point_size(self, arg0: float) -> None: ...

class MeshcatVisualizer(pydrake.systems.framework.LeafSystem):
    def __init__(self, meshcat: pydrake.geometry.Meshcat, params: pydrake.geometry.MeshcatVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder, scene_graph: pydrake.geometry.SceneGraph, meshcat: pydrake.geometry.Meshcat, params: pydrake.geometry.MeshcatVisualizerParams = ...) -> pydrake.geometry.MeshcatVisualizer: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> pydrake.geometry.MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> pydrake.geometry.MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort: ...

class MeshcatVisualizerParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_color: pydrake.geometry.Rgba
    delete_on_initialization_event: bool
    enable_alpha_slider: bool
    include_unspecified_accepting: Any
    prefix: str
    publish_period: float
    role: pydrake.geometry.Role
    show_hydroelastic: bool
    visible_by_default: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.MeshcatVisualizerParams: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.MeshcatVisualizerParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class MeshcatVisualizer_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, meshcat: pydrake.geometry.Meshcat, params: pydrake.geometry.MeshcatVisualizerParams = ...) -> None: ...
    @classmethod
    def AddToBuilder(cls, builder: pydrake.systems.framework.DiagramBuilder_𝓣AutoDiffXd𝓤, scene_graph: pydrake.geometry.SceneGraph_𝓣AutoDiffXd𝓤, meshcat: pydrake.geometry.Meshcat, params: pydrake.geometry.MeshcatVisualizerParams = ...) -> pydrake.geometry.MeshcatVisualizer_𝓣AutoDiffXd𝓤: ...
    def Delete(self) -> None: ...
    def DeleteRecording(self) -> None: ...
    def PublishRecording(self) -> None: ...
    def ResetRealtimeRateCalculator(self) -> None: ...
    def StartRecording(self, set_transforms_while_recording: bool = ...) -> pydrake.geometry.MeshcatAnimation: ...
    def StopRecording(self) -> None: ...
    def get_mutable_recording(self) -> pydrake.geometry.MeshcatAnimation: ...
    def query_object_input_port(self) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...

class MinkowskiSum(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sets: List[pydrake.geometry.optimization.ConvexSet]) -> None: ...
    @overload
    def __init__(self, setA: pydrake.geometry.optimization.ConvexSet, setB: pydrake.geometry.optimization.ConvexSet) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    def num_terms(self) -> int: ...
    def term(self, index: int) -> pydrake.geometry.optimization.ConvexSet: ...

class NullTexture:
    __fields__: ClassVar[tuple] = ...  # read-only
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.NullTexture: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.NullTexture: ...

class PenetrationAsPointPair:
    depth: float
    id_A: pydrake.geometry.GeometryId
    id_B: pydrake.geometry.GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_WCa: numpy.ndarray[numpy.float64[3,1]]
    p_WCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.autodiffutils.AutoDiffXd
    id_A: pydrake.geometry.GeometryId
    id_B: pydrake.geometry.GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PenetrationAsPointPair_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    depth: pydrake.symbolic.Expression
    id_A: pydrake.geometry.GeometryId
    id_B: pydrake.geometry.GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_WCa: numpy.ndarray[object[3,1]]
    p_WCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class PerceptionProperties(pydrake.geometry.GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: pydrake.geometry.PerceptionProperties) -> None: ...
    def __copy__(self) -> pydrake.geometry.PerceptionProperties: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.PerceptionProperties: ...

class PlaneSide:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNegative: ClassVar[pydrake.geometry.optimization.PlaneSide] = ...
    kPositive: ClassVar[pydrake.geometry.optimization.PlaneSide] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Point(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ..., maximum_allowable_radius: float = ...) -> None: ...
    def set_x(self, x: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def x(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[m,1]]) -> None: ...

class PolygonSurfaceMesh:
    def __init__(self) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def Equal(self, mesh: pydrake.geometry.PolygonSurfaceMesh) -> bool: ...
    def area(self, f: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> pydrake.geometry.SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> pydrake.geometry.PolygonSurfaceMesh: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.PolygonSurfaceMesh: ...

class PolygonSurfaceMeshFieldLinear:
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[numpy.float64[3,1]]: ...

class PolygonSurfaceMeshFieldLinear_𝓣AutoDiffXd𝓬AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateGradient(self, e: int) -> numpy.ndarray[object[3,1]]: ...

class PolygonSurfaceMesh_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def Equal(self, mesh: pydrake.geometry.PolygonSurfaceMesh_𝓣AutoDiffXd𝓤) -> bool: ...
    def area(self, f: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> pydrake.geometry.SurfacePolygon: ...
    def element_centroid(self, e: int) -> numpy.ndarray[object[3,1]]: ...
    def face_data(self) -> List[int]: ...
    def face_normal(self, f: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_faces(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> pydrake.geometry.PolygonSurfaceMesh_𝓣AutoDiffXd𝓤: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.PolygonSurfaceMesh_𝓣AutoDiffXd𝓤: ...

class ProximityProperties(pydrake.geometry.GeometryProperties):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: pydrake.geometry.ProximityProperties) -> None: ...
    def __copy__(self) -> pydrake.geometry.ProximityProperties: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.ProximityProperties: ...

class QueryObject:
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform: ...
    @overload
    def GetPoseInWorld(self, frame_id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform: ...
    @overload
    def GetPoseInWorld(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.math.RigidTransform: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> pydrake.geometry.SceneGraphInspector: ...

class QueryObject_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputeContactSurfaces(self, *args, **kwargs) -> Any: ...
    def ComputeContactSurfacesWithFallback(self, *args, **kwargs) -> Any: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetPoseInWorld(self, frame_id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.math.RigidTransform_𝓣AutoDiffXd𝓤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> pydrake.geometry.SceneGraphInspector_𝓣AutoDiffXd𝓤: ...

class QueryObject_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def ComputePointPairPenetration(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistancePairwiseClosestPoints(self, *args, **kwargs) -> Any: ...
    def ComputeSignedDistanceToPoint(self, *args, **kwargs) -> Any: ...
    def FindCollisionCandidates(self, *args, **kwargs) -> Any: ...
    def GetPoseInParent(self, frame_id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetPoseInWorld(self, frame_id: pydrake.geometry.FrameId) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    @overload
    def GetPoseInWorld(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.math.RigidTransform_𝓣Expression𝓤: ...
    def HasCollisions(self) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def inspector(self) -> pydrake.geometry.SceneGraphInspector_𝓣Expression𝓤: ...

class RenderCameraCore:
    def __init__(self, other: pydrake.geometry.RenderCameraCore) -> None: ...
    def clipping(self) -> pydrake.geometry.ClippingRange: ...
    def intrinsics(self, *args, **kwargs) -> Any: ...
    def renderer_name(self) -> str: ...
    def sensor_pose_in_camera_body(self) -> pydrake.math.RigidTransform: ...
    def __copy__(self) -> pydrake.geometry.RenderCameraCore: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.RenderCameraCore: ...

class RenderEngine:
    def __init__(self) -> None: ...
    def Clone(self) -> pydrake.geometry.RenderEngine: ...
    @classmethod
    def GetColorDFromLabel(cls, *args, **kwargs) -> Any: ...
    @classmethod
    def GetColorIFromLabel(cls, *args, **kwargs) -> Any: ...
    def GetRenderLabelOrThrow(self, *args, **kwargs) -> Any: ...
    @classmethod
    def LabelFromColor(cls, *args, **kwargs) -> Any: ...
    def RegisterVisual(self, id: pydrake.geometry.GeometryId, shape: pydrake.geometry.Shape, properties: pydrake.geometry.PerceptionProperties, X_WG: pydrake.math.RigidTransform, needs_updates: bool = ...) -> bool: ...
    def RemoveGeometry(self, id: pydrake.geometry.GeometryId) -> bool: ...
    def RenderColorImage(self, *args, **kwargs) -> Any: ...
    def RenderDepthImage(self, *args, **kwargs) -> Any: ...
    def RenderLabelImage(self, *args, **kwargs) -> Any: ...
    def SetDefaultLightPosition(self, X_DL: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @classmethod
    def ThrowIfInvalid(cls, *args, **kwargs) -> Any: ...
    def UpdateViewpoint(self, X_WR: pydrake.math.RigidTransform) -> None: ...
    def default_render_label(self, *args, **kwargs) -> Any: ...
    def has_geometry(self, id: pydrake.geometry.GeometryId) -> bool: ...

class RenderEngineGlParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    default_clear_color: pydrake.geometry.Rgba
    default_diffuse: pydrake.geometry.Rgba
    default_label: pydrake.geometry.RenderLabel
    lights: List[pydrake.geometry.LightParameter]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.RenderEngineGlParams: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.RenderEngineGlParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class RenderEngineGltfClientParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    base_url: str
    cleanup: bool
    default_label: Optional[pydrake.geometry.RenderLabel]
    render_endpoint: Any
    verbose: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.RenderEngineGltfClientParams: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.RenderEngineGltfClientParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class RenderEngineVtkParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    default_clear_color: numpy.ndarray[numpy.float64[3,1]]
    default_diffuse: Optional[numpy.ndarray[numpy.float64[4,1]]]
    default_label: Optional[pydrake.geometry.RenderLabel]
    environment_map: Optional[pydrake.geometry.EnvironmentMap]
    lights: List[pydrake.geometry.LightParameter]
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> pydrake.geometry.RenderEngineVtkParams: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.RenderEngineVtkParams: ...

class RenderLabel:
    _pybind11_del_orig: ClassVar[None] = ...
    kDoNotRender: ClassVar[pydrake.geometry.RenderLabel] = ...
    kDontCare: ClassVar[pydrake.geometry.RenderLabel] = ...
    kEmpty: ClassVar[pydrake.geometry.RenderLabel] = ...
    kMaxUnreserved: ClassVar[int] = ...
    kUnspecified: ClassVar[pydrake.geometry.RenderLabel] = ...
    __hash__: ClassVar[None] = ...
    def __init__(self, value: int) -> None: ...
    def is_reserved(self) -> bool: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    @overload
    def __eq__(self, arg0: pydrake.geometry.RenderLabel) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, arg0: pydrake.geometry.RenderLabel) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...

class Rgba:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    __hash__: ClassVar[None] = ...
    rgba: numpy.ndarray[numpy.float64[4,1]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    def a(self) -> float: ...
    def b(self) -> float: ...
    def g(self) -> float: ...
    def r(self) -> float: ...
    def scale_rgb(self, scale: float) -> pydrake.geometry.Rgba: ...
    @overload
    def set(self, r: float, g: float, b: float, a: float = ...) -> None: ...
    @overload
    def set(self, rgba: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def update(self, r: Optional[float] = ..., g: Optional[float] = ..., b: Optional[float] = ..., a: Optional[float] = ...) -> None: ...
    def __copy__(self) -> pydrake.geometry.Rgba: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.Rgba: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, arg0: pydrake.geometry.Rgba) -> bool: ...
    def __mul__(self, arg0: pydrake.geometry.Rgba) -> pydrake.geometry.Rgba: ...
    def __ne__(self, arg0: pydrake.geometry.Rgba) -> bool: ...

class Role:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kIllustration: ClassVar[pydrake.geometry.Role] = ...
    kPerception: ClassVar[pydrake.geometry.Role] = ...
    kProximity: ClassVar[pydrake.geometry.Role] = ...
    kUnassigned: ClassVar[pydrake.geometry.Role] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RoleAssign:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNew: ClassVar[pydrake.geometry.RoleAssign] = ...
    kReplace: ClassVar[pydrake.geometry.RoleAssign] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SceneGraph(pydrake.systems.framework.LeafSystem):
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: pydrake.geometry.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, shape: pydrake.geometry.Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, shape: pydrake.geometry.Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: pydrake.geometry.SourceId, geometry: pydrake.geometry.GeometryInstance) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: pydrake.geometry.SourceId, frame: pydrake.geometry.GeometryFrame) -> pydrake.geometry.FrameId: ...
    @overload
    def RegisterFrame(self, source_id: pydrake.geometry.SourceId, parent_id: pydrake.geometry.FrameId, frame: pydrake.geometry.GeometryFrame) -> pydrake.geometry.FrameId: ...
    def RegisterGeometry(self, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, geometry: pydrake.geometry.GeometryInstance) -> pydrake.geometry.GeometryId: ...
    def RegisterSource(self, name: str = ...) -> pydrake.geometry.SourceId: ...
    def RemoveGeometry(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: pydrake.geometry.FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: pydrake.geometry.GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context) -> pydrake.geometry.CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> pydrake.geometry.CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort: ...
    def get_source_configuration_port(self, arg0: pydrake.geometry.SourceId) -> pydrake.systems.framework.InputPort: ...
    def get_source_pose_port(self, arg0: pydrake.geometry.SourceId) -> pydrake.systems.framework.InputPort: ...
    def model_inspector(self) -> pydrake.geometry.SceneGraphInspector: ...
    @classmethod
    def world_frame_id(cls) -> pydrake.geometry.FrameId: ...

class SceneGraphInspector:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: pydrake.geometry.FrameId, source_id: pydrake.geometry.SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: pydrake.geometry.GeometryId, source_id: pydrake.geometry.SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: pydrake.geometry.GeometryId, geometry_id2: pydrake.geometry.GeometryId) -> bool: ...
    def FramesForSource(self, source_id: pydrake.geometry.SourceId) -> Set[pydrake.geometry.FrameId]: ...
    def GetAllFrameIds(self) -> List[pydrake.geometry.FrameId]: ...
    def GetAllGeometryIds(self) -> List[pydrake.geometry.GeometryId]: ...
    def GetAllSourceIds(self) -> List[pydrake.geometry.SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[pydrake.geometry.GeometryId,pydrake.geometry.GeometryId]]: ...
    def GetFrameGroup(self, frame_id: pydrake.geometry.FrameId) -> int: ...
    def GetFrameId(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.FrameId: ...
    def GetGeometries(self, frame_id: pydrake.geometry.FrameId, role: Optional[pydrake.geometry.Role] = ...) -> List[pydrake.geometry.GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role, name: str) -> pydrake.geometry.GeometryId: ...
    def GetGeometryIds(self, geometry_set: pydrake.geometry.GeometrySet, role: Optional[pydrake.geometry.Role] = ...) -> Set[pydrake.geometry.GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.IllustrationProperties: ...
    @overload
    def GetName(self, source_id: pydrake.geometry.SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: pydrake.geometry.FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: pydrake.geometry.GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: pydrake.geometry.FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: pydrake.geometry.GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: pydrake.geometry.GeometryId, role: pydrake.geometry.Role) -> pydrake.geometry.GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.ProximityProperties: ...
    def GetShape(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: pydrake.geometry.SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: pydrake.geometry.FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    def NumGeometriesWithRole(self, role: pydrake.geometry.Role) -> int: ...
    def SourceIsRegistered(self, source_id: pydrake.geometry.SourceId) -> bool: ...
    def geometry_version(self) -> pydrake.geometry.GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: pydrake.geometry.GeometryId) -> Union[None,pydrake.geometry.TriangleSurfaceMesh,pydrake.geometry.VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> pydrake.geometry.FrameId: ...

class SceneGraphInspector_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: pydrake.geometry.FrameId, source_id: pydrake.geometry.SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: pydrake.geometry.GeometryId, source_id: pydrake.geometry.SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: pydrake.geometry.GeometryId, geometry_id2: pydrake.geometry.GeometryId) -> bool: ...
    def FramesForSource(self, source_id: pydrake.geometry.SourceId) -> Set[pydrake.geometry.FrameId]: ...
    def GetAllFrameIds(self) -> List[pydrake.geometry.FrameId]: ...
    def GetAllGeometryIds(self) -> List[pydrake.geometry.GeometryId]: ...
    def GetAllSourceIds(self) -> List[pydrake.geometry.SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[pydrake.geometry.GeometryId,pydrake.geometry.GeometryId]]: ...
    def GetFrameGroup(self, frame_id: pydrake.geometry.FrameId) -> int: ...
    def GetFrameId(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.FrameId: ...
    def GetGeometries(self, frame_id: pydrake.geometry.FrameId, role: Optional[pydrake.geometry.Role] = ...) -> List[pydrake.geometry.GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role, name: str) -> pydrake.geometry.GeometryId: ...
    def GetGeometryIds(self, geometry_set: pydrake.geometry.GeometrySet, role: Optional[pydrake.geometry.Role] = ...) -> Set[pydrake.geometry.GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.IllustrationProperties: ...
    @overload
    def GetName(self, source_id: pydrake.geometry.SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: pydrake.geometry.FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: pydrake.geometry.GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: pydrake.geometry.FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: pydrake.geometry.GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: pydrake.geometry.GeometryId, role: pydrake.geometry.Role) -> pydrake.geometry.GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.ProximityProperties: ...
    def GetShape(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: pydrake.geometry.SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: pydrake.geometry.FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    def NumGeometriesWithRole(self, role: pydrake.geometry.Role) -> int: ...
    def SourceIsRegistered(self, source_id: pydrake.geometry.SourceId) -> bool: ...
    def geometry_version(self) -> pydrake.geometry.GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: pydrake.geometry.GeometryId) -> Union[None,pydrake.geometry.TriangleSurfaceMesh,pydrake.geometry.VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> pydrake.geometry.FrameId: ...

class SceneGraphInspector_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def BelongsToSource(self, frame_id: pydrake.geometry.FrameId, source_id: pydrake.geometry.SourceId) -> bool: ...
    @overload
    def BelongsToSource(self, geometry_id: pydrake.geometry.GeometryId, source_id: pydrake.geometry.SourceId) -> bool: ...
    def CloneGeometryInstance(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.GeometryInstance: ...
    def CollisionFiltered(self, geometry_id1: pydrake.geometry.GeometryId, geometry_id2: pydrake.geometry.GeometryId) -> bool: ...
    def FramesForSource(self, source_id: pydrake.geometry.SourceId) -> Set[pydrake.geometry.FrameId]: ...
    def GetAllFrameIds(self) -> List[pydrake.geometry.FrameId]: ...
    def GetAllGeometryIds(self) -> List[pydrake.geometry.GeometryId]: ...
    def GetAllSourceIds(self) -> List[pydrake.geometry.SourceId]: ...
    def GetCollisionCandidates(self) -> Set[Tuple[pydrake.geometry.GeometryId,pydrake.geometry.GeometryId]]: ...
    def GetFrameGroup(self, frame_id: pydrake.geometry.FrameId) -> int: ...
    def GetFrameId(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.FrameId: ...
    def GetGeometries(self, frame_id: pydrake.geometry.FrameId, role: Optional[pydrake.geometry.Role] = ...) -> List[pydrake.geometry.GeometryId]: ...
    def GetGeometryIdByName(self, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role, name: str) -> pydrake.geometry.GeometryId: ...
    def GetGeometryIds(self, geometry_set: pydrake.geometry.GeometrySet, role: Optional[pydrake.geometry.Role] = ...) -> Set[pydrake.geometry.GeometryId]: ...
    def GetIllustrationProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.IllustrationProperties: ...
    @overload
    def GetName(self, source_id: pydrake.geometry.SourceId) -> str: ...
    @overload
    def GetName(self, frame_id: pydrake.geometry.FrameId) -> str: ...
    @overload
    def GetName(self, geometry_id: pydrake.geometry.GeometryId) -> str: ...
    @overload
    def GetOwningSourceName(self, frame_id: pydrake.geometry.FrameId) -> str: ...
    @overload
    def GetOwningSourceName(self, geometry_id: pydrake.geometry.GeometryId) -> str: ...
    def GetPerceptionProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.PerceptionProperties: ...
    def GetPoseInFrame(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.math.RigidTransform: ...
    def GetProperties(self, geometry_id: pydrake.geometry.GeometryId, role: pydrake.geometry.Role) -> pydrake.geometry.GeometryProperties: ...
    def GetProximityProperties(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.ProximityProperties: ...
    def GetShape(self, geometry_id: pydrake.geometry.GeometryId) -> pydrake.geometry.Shape: ...
    def NumAnchoredGeometries(self) -> int: ...
    def NumDynamicGeometries(self) -> int: ...
    def NumFramesForSource(self, source_id: pydrake.geometry.SourceId) -> int: ...
    def NumGeometriesForFrame(self, frame_id: pydrake.geometry.FrameId) -> int: ...
    def NumGeometriesForFrameWithRole(self, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    def NumGeometriesWithRole(self, role: pydrake.geometry.Role) -> int: ...
    def SourceIsRegistered(self, source_id: pydrake.geometry.SourceId) -> bool: ...
    def geometry_version(self) -> pydrake.geometry.GeometryVersion: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, geometry_id: pydrake.geometry.GeometryId) -> Union[None,pydrake.geometry.TriangleSurfaceMesh,pydrake.geometry.VolumeMesh]: ...
    @overload
    def maybe_get_hydroelastic_mesh(self, id) -> Any: ...
    def num_frames(self) -> int: ...
    def num_geometries(self) -> int: ...
    def num_sources(self) -> int: ...
    def world_frame_id(self) -> pydrake.geometry.FrameId: ...

class SceneGraph_𝓣AutoDiffXd𝓤(pydrake.systems.framework.LeafSystem_𝓣AutoDiffXd𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: pydrake.geometry.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, shape: pydrake.geometry.Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, shape: pydrake.geometry.Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: pydrake.geometry.SourceId, geometry: pydrake.geometry.GeometryInstance) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: pydrake.geometry.SourceId, frame: pydrake.geometry.GeometryFrame) -> pydrake.geometry.FrameId: ...
    @overload
    def RegisterFrame(self, source_id: pydrake.geometry.SourceId, parent_id: pydrake.geometry.FrameId, frame: pydrake.geometry.GeometryFrame) -> pydrake.geometry.FrameId: ...
    def RegisterGeometry(self, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, geometry: pydrake.geometry.GeometryInstance) -> pydrake.geometry.GeometryId: ...
    def RegisterSource(self, name: str = ...) -> pydrake.geometry.SourceId: ...
    def RemoveGeometry(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: pydrake.geometry.FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: pydrake.geometry.GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_𝓣AutoDiffXd𝓤) -> pydrake.geometry.CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> pydrake.geometry.CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣AutoDiffXd𝓤: ...
    def get_source_configuration_port(self, arg0: pydrake.geometry.SourceId) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def get_source_pose_port(self, arg0: pydrake.geometry.SourceId) -> pydrake.systems.framework.InputPort_𝓣AutoDiffXd𝓤: ...
    def model_inspector(self) -> pydrake.geometry.SceneGraphInspector_𝓣AutoDiffXd𝓤: ...
    @classmethod
    def world_frame_id(cls) -> pydrake.geometry.FrameId: ...

class SceneGraph_𝓣Expression𝓤(pydrake.systems.framework.LeafSystem_𝓣Expression𝓤):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def AddRenderer(self, name: str, renderer: pydrake.geometry.RenderEngine) -> None: ...
    @overload
    def AssignRole(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = ...) -> None: ...
    @overload
    def AssignRole(self, SourceId, GeometryId, ProximityProperties) -> Any: ...
    @overload
    def ChangeShape(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, shape: pydrake.geometry.Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, shape: pydrake.geometry.Shape, X_FG: Optional[pydrake.math.RigidTransform] = ...) -> None: ...
    @overload
    def ChangeShape(self) -> Any: ...
    def GetRendererTypeName(self, name: str) -> str: ...
    @overload
    def HasRenderer(self, name: str) -> bool: ...
    @overload
    def HasRenderer(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, name: str) -> bool: ...
    @overload
    def HasRenderer(self) -> Any: ...
    def RegisterAnchoredGeometry(self, source_id: pydrake.geometry.SourceId, geometry: pydrake.geometry.GeometryInstance) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterFrame(self, source_id: pydrake.geometry.SourceId, frame: pydrake.geometry.GeometryFrame) -> pydrake.geometry.FrameId: ...
    @overload
    def RegisterFrame(self, source_id: pydrake.geometry.SourceId, parent_id: pydrake.geometry.FrameId, frame: pydrake.geometry.GeometryFrame) -> pydrake.geometry.FrameId: ...
    def RegisterGeometry(self, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, geometry: pydrake.geometry.GeometryInstance) -> pydrake.geometry.GeometryId: ...
    def RegisterSource(self, name: str = ...) -> pydrake.geometry.SourceId: ...
    def RemoveGeometry(self, source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId) -> None: ...
    def RemoveRenderer(self, name: str) -> None: ...
    @overload
    def RemoveRole(self, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    @overload
    def RemoveRole(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤, source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role) -> int: ...
    @overload
    def RemoveRole(self, SourceId, FrameId, Role) -> Any: ...
    def RenameFrame(self, frame_id: pydrake.geometry.FrameId, name: str) -> None: ...
    def RenameGeometry(self, geometry_id: pydrake.geometry.GeometryId, name: str) -> None: ...
    @overload
    def RendererCount(self) -> int: ...
    @overload
    def RendererCount(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> int: ...
    @overload
    def RendererCount(self) -> Any: ...
    @overload
    def collision_filter_manager(self, context: pydrake.systems.framework.Context_𝓣Expression𝓤) -> pydrake.geometry.CollisionFilterManager: ...
    @overload
    def collision_filter_manager(self) -> pydrake.geometry.CollisionFilterManager: ...
    def get_query_output_port(self) -> pydrake.systems.framework.OutputPort_𝓣Expression𝓤: ...
    def get_source_configuration_port(self, arg0: pydrake.geometry.SourceId) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def get_source_pose_port(self, arg0: pydrake.geometry.SourceId) -> pydrake.systems.framework.InputPort_𝓣Expression𝓤: ...
    def model_inspector(self) -> pydrake.geometry.SceneGraphInspector_𝓣Expression𝓤: ...
    @classmethod
    def world_frame_id(cls) -> pydrake.geometry.FrameId: ...

class SeparatingPlaneOrder:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kAffine: ClassVar[pydrake.geometry.optimization.SeparatingPlaneOrder] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SeparationCertificateProgramBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...
    @property
    def plane_index(self) -> int: ...

class SeparationCertificateResultBase:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def a(self) -> numpy.ndarray[object[3,1]]: ...
    @property
    def b(self) -> pydrake.symbolic.Polynomial: ...
    @property
    def plane_decision_var_vals(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def result(self) -> pydrake.solvers.MathematicalProgramResult: ...

class Shape:
    def __init__(self, *args, **kwargs) -> None: ...
    def Clone(self) -> pydrake.geometry.Shape: ...
    def __copy__(self) -> pydrake.geometry.Shape: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.Shape: ...

class SignedDistancePair:
    distance: float
    id_A: pydrake.geometry.GeometryId
    id_B: pydrake.geometry.GeometryId
    nhat_BA_W: numpy.ndarray[numpy.float64[3,1]]
    p_ACa: numpy.ndarray[numpy.float64[3,1]]
    p_BCb: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    id_A: pydrake.geometry.GeometryId
    id_B: pydrake.geometry.GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistancePair_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    id_A: pydrake.geometry.GeometryId
    id_B: pydrake.geometry.GeometryId
    nhat_BA_W: numpy.ndarray[object[3,1]]
    p_ACa: numpy.ndarray[object[3,1]]
    p_BCb: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint:
    distance: float
    grad_W: numpy.ndarray[numpy.float64[3,1]]
    id_G: pydrake.geometry.GeometryId
    p_GN: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.autodiffutils.AutoDiffXd
    grad_W: numpy.ndarray[object[3,1]]
    id_G: pydrake.geometry.GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SignedDistanceToPoint_𝓣Expression𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    distance: pydrake.symbolic.Expression
    grad_W: numpy.ndarray[object[3,1]]
    id_G: pydrake.geometry.GeometryId
    p_GN: numpy.ndarray[object[3,1]]
    def __init__(self, **kwargs) -> None: ...

class SourceId:
    def __init__(self, *args, **kwargs) -> None: ...
    @classmethod
    def get_new_id(cls) -> pydrake.geometry.SourceId: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: pydrake.geometry.SourceId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: pydrake.geometry.SourceId) -> bool: ...
    def __ne__(self, arg0: pydrake.geometry.SourceId) -> bool: ...

class Spectrahedron(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, prog: pydrake.solvers.MathematicalProgram) -> None: ...

class Sphere(pydrake.geometry.Shape):
    def __init__(self, radius: float) -> None: ...
    def radius(self) -> float: ...
    def __getstate__(self) -> float: ...
    def __setstate__(self, arg0: float) -> None: ...

class SurfacePolygon:
    def __init__(self, *args, **kwargs) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...

class SurfaceTriangle:
    def __init__(self, v0: int, v1: int, v2: int) -> None: ...
    def num_vertices(self) -> int: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> pydrake.geometry.SurfaceTriangle: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.SurfaceTriangle: ...

class TriangleSurfaceMesh:
    def __init__(self, triangles: List[pydrake.geometry.SurfaceTriangle], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def Equal(self, mesh: pydrake.geometry.TriangleSurfaceMesh) -> bool: ...
    def area(self, t: int) -> float: ...
    def centroid(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def element(self, e: int) -> pydrake.geometry.SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> float: ...
    def triangles(self) -> List[pydrake.geometry.SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class TriangleSurfaceMeshFieldLinear:
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[numpy.float64[3,1]]) -> float: ...
    def EvaluateAtVertex(self, v: int) -> float: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[numpy.float64[3,1]]) -> float: ...

class TriangleSurfaceMeshFieldLinear_𝓣AutoDiffXd𝓬AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def Evaluate(self, e: int, b: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateAtVertex(self, v: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def EvaluateCartesian(self, e: int, p_MQ: numpy.ndarray[object[3,1]]) -> pydrake.autodiffutils.AutoDiffXd: ...

class TriangleSurfaceMesh_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, triangles: List[pydrake.geometry.SurfaceTriangle], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], t: int) -> numpy.ndarray[object[3,1]]: ...
    def CalcBoundingBox(self) -> Tuple[numpy.ndarray[object[3,1]],numpy.ndarray[object[3,1]]]: ...
    def CalcCartesianFromBarycentric(self, element_index: int, b_Q: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def Equal(self, mesh: pydrake.geometry.TriangleSurfaceMesh_𝓣AutoDiffXd𝓤) -> bool: ...
    def area(self, t: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def centroid(self) -> numpy.ndarray[object[3,1]]: ...
    def element(self, e: int) -> pydrake.geometry.SurfaceTriangle: ...
    def element_centroid(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def face_normal(self, t: int) -> numpy.ndarray[object[3,1]]: ...
    def num_elements(self) -> int: ...
    def num_triangles(self) -> int: ...
    def num_vertices(self) -> int: ...
    def total_area(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def triangles(self) -> List[pydrake.geometry.SurfaceTriangle]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

class VPolytope(pydrake.geometry.optimization.ConvexSet):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, vertices: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, H: pydrake.geometry.optimization.HPolyhedron) -> None: ...
    @overload
    def __init__(self, query_object: pydrake.geometry.QueryObject, geometry_id: pydrake.geometry.GeometryId, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> None: ...
    def GetMinimalRepresentation(self) -> pydrake.geometry.optimization.VPolytope: ...
    @classmethod
    def MakeBox(cls, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.geometry.optimization.VPolytope: ...
    @classmethod
    def MakeUnitBox(cls, dim: int) -> pydrake.geometry.optimization.VPolytope: ...
    def WriteObj(self, filename: os.PathLike) -> None: ...
    def vertices(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[m,n]]) -> None: ...

class VolumeElement:
    def __init__(self, v0: int, v1: int, v2: int, v3: int) -> None: ...
    def vertex(self, i: int) -> int: ...
    def __copy__(self) -> pydrake.geometry.VolumeElement: ...
    def __deepcopy__(self, arg0: dict) -> pydrake.geometry.VolumeElement: ...

class VolumeMesh:
    def __init__(self, elements: List[pydrake.geometry.VolumeElement], vertices: List[numpy.ndarray[numpy.float64[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[numpy.float64[3,1]], e: int) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> float: ...
    def CalcVolume(self) -> float: ...
    def Equal(self, mesh: pydrake.geometry.VolumeMesh, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> pydrake.geometry.VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[pydrake.geometry.VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[numpy.float64[3,1]]]: ...

class VolumeMesh_𝓣AutoDiffXd𝓤:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, elements: List[pydrake.geometry.VolumeElement], vertices: List[numpy.ndarray[object[3,1]]]) -> None: ...
    def CalcBarycentric(self, p_MQ: numpy.ndarray[object[3,1]], e: int) -> numpy.ndarray[object[4,1]]: ...
    def CalcTetrahedronVolume(self, e: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcVolume(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def Equal(self, mesh: pydrake.geometry.VolumeMesh_𝓣AutoDiffXd𝓤, vertex_tolerance: float = ...) -> bool: ...
    def element(self, e: int) -> pydrake.geometry.VolumeElement: ...
    def num_elements(self) -> int: ...
    def num_vertices(self) -> int: ...
    def tetrahedra(self) -> List[pydrake.geometry.VolumeElement]: ...
    def vertex(self, v: int) -> numpy.ndarray[object[3,1]]: ...
    def vertices(self) -> List[numpy.ndarray[object[3,1]]]: ...

def AddCompliantHydroelasticProperties(resolution_hint: float, hydroelastic_modulus: float, properties: pydrake.geometry.ProximityProperties) -> None: ...
def AddCompliantHydroelasticPropertiesForHalfSpace(slab_thickness: float, hydroelastic_modulus: float, properties: pydrake.geometry.ProximityProperties) -> None: ...
@overload
def AddContactMaterial(dissipation: Optional[float], point_stiffness: Optional[float], friction, properties: pydrake.geometry.ProximityProperties) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
@overload
def AddContactMaterial(properties: pydrake.geometry.ProximityProperties, dissipation: Optional[float] = ..., point_stiffness: Optional[float] = ..., friction = ...) -> None: ...
@overload
def AddContactMaterial() -> Any: ...
def AddRigidHydroelasticProperties(resolution_hint: float, properties: pydrake.geometry.ProximityProperties) -> None: ...
def CalcVolume(shape: pydrake.geometry.Shape) -> float: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: pydrake.geometry.VolumeMesh) -> pydrake.geometry.TriangleSurfaceMesh: ...
@overload
def ConvertVolumeToSurfaceMesh(volume: pydrake.geometry.VolumeMesh_𝓣AutoDiffXd𝓤) -> pydrake.geometry.TriangleSurfaceMesh_𝓣AutoDiffXd𝓤: ...
def FindResourceOrThrow(resource_path: str) -> str: ...
def Iris(obstacles: List[pydrake.geometry.optimization.ConvexSet], sample: numpy.ndarray[numpy.float64[m,1]], domain: pydrake.geometry.optimization.HPolyhedron, options: pydrake.geometry.optimization.IrisOptions = ...) -> pydrake.geometry.optimization.HPolyhedron: ...
def IrisInConfigurationSpace(*args, **kwargs) -> Any: ...
def LoadIrisRegionsYamlFile(filename: os.PathLike, child_name: Optional[str] = ...) -> Dict[str,pydrake.geometry.optimization.HPolyhedron]: ...
def MakeIrisObstacles(query_object: pydrake.geometry.QueryObject, reference_frame: Optional[pydrake.geometry.FrameId] = ...) -> List[pydrake.geometry.optimization.ConvexSet]: ...
def MakePhongIllustrationProperties(diffuse: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.IllustrationProperties: ...
def MakeRenderEngineGl(params: pydrake.geometry.RenderEngineGlParams = ...) -> pydrake.geometry.RenderEngine: ...
@overload
def MakeRenderEngineGltfClient(params: pydrake.geometry.RenderEngineGltfClientParams = ...) -> pydrake.geometry.RenderEngine: ...
@overload
def MakeRenderEngineGltfClient(params) -> Any: ...
@overload
def MakeRenderEngineGltfClient() -> Any: ...
def MakeRenderEngineVtk(params: pydrake.geometry.RenderEngineVtkParams) -> pydrake.geometry.RenderEngine: ...
def ReadObjToTriangleSurfaceMesh(*args, **kwargs) -> Any: ...
def SaveIrisRegionsYamlFile(filename: os.PathLike, regions: Dict[str,pydrake.geometry.optimization.HPolyhedron], child_name: Optional[str] = ...) -> None: ...
