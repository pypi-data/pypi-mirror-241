
# for package testing with pytest call
# in upper directory "$ python setup.py pytest"
# or in this directory "$ py.test test_memocell_[...].py"
# or after pip installation $py.test --pyargs memocell$

import pytest
import memocell as me
import numpy as np

class TestGillespieSimClass(object):
    ### single method tests
    def test_exact_interpolation(self):
        time_array_gill = np.array([0.0, 0.12, 4.67, 8.01, 10.00])
        nodes_array_gill = np.array([[1.0, 2.0, 3.0, 4.0, 5.0]])
        simulation = [time_array_gill, nodes_array_gill]

        time_array_explicit = np.array([0.0, 2.0, 4.0, 6.0, 8.0, 10.0])
        res = [np.array([ 0.,  2.,  4.,  6.,  8., 10.]), np.array([[1., 2., 2., 3., 3., 5.]])]

        np.testing.assert_allclose(res[0], me.simulation_lib.sim_gillespie.GillespieSim.exact_interpolation(simulation, time_array_explicit)[0])
        np.testing.assert_allclose(res[1], me.simulation_lib.sim_gillespie.GillespieSim.exact_interpolation(simulation, time_array_explicit)[1])

    ### NOTE: here we test more the symbolic attributes that are generated by the
    ### preparation methods; whole-simulations are tested in test_memocell_simulation.py
    def test_sim_gill_net_diff_markov(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'k_xy', 'type': 'S -> E', 'reaction_steps': 1}
        ]
        net = me.Network('net_diff_exp')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',), 'Y_t': ('Y_t',)})
        assert(sim.sim_variables_order == [[('V_0',), ('V_1',)], [('V_0', 'V_0'), ('V_0', 'V_1'), ('V_1', 'V_1')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',)), 'V_1': ('Y_t', ('Y_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0', 'Z_1'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric', 'Z_1__centric'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n1.0 * theta_0 * nodes_state[0]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 1)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0,), (1,)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,), (1,)])

    def test_sim_gill_net_diff_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'k_xy', 'type': 'S -> E', 'reaction_steps': 3}
        ]
        net = me.Network('net_diff_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t', )}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',), 'Y_t': ('Y_t',)})
        assert(sim.sim_variables_order == [[('V_0',), ('V_1',)], [('V_0', 'V_0'), ('V_0', 'V_1'), ('V_1', 'V_1')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',)), 'V_1': ('Y_t', ('Y_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0', 'Z_1'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric', 'Z_0__module_0__0', 'Z_0__module_0__1', 'Z_1__centric'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n3.0 * theta_0 * nodes_state[0],\n3.0 * theta_0 * nodes_state[1],\n3.0 * theta_0 * nodes_state[2]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 3)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\tif reac_ind==1:\n\t\tnodes_state[1] -= 1\n\t\tnodes_state[2] += 1\n\tif reac_ind==2:\n\t\tnodes_state[2] -= 1\n\t\tnodes_state[3] += 1\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0, 1, 2), (3,)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,), (1,)])

    def test_sim_gill_net_sym_div_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'X_t', 'rate_symbol': 'l', 'type': 'S -> S + S', 'reaction_steps': 3}
        ]
        net = me.Network('net_sym_div_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',)}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',)})
        assert(sim.sim_variables_order == [[('V_0',)], [('V_0', 'V_0')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric', 'Z_0__module_0__0', 'Z_0__module_0__1'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n3.0 * theta_0 * nodes_state[0],\n3.0 * theta_0 * nodes_state[1],\n3.0 * theta_0 * nodes_state[2]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 3)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\tif reac_ind==1:\n\t\tnodes_state[1] -= 1\n\t\tnodes_state[2] += 1\n\tif reac_ind==2:\n\t\tnodes_state[2] -= 1\n\t\tnodes_state[0] += 2\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0, 1, 2)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,)])

    def test_sim_gill_net_asym_div_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'l', 'type': 'S -> S + E', 'reaction_steps': 3}
        ]
        net = me.Network('net_asym_div_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t',)}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',), 'Y_t': ('Y_t',)})
        assert(sim.sim_variables_order == [[('V_0',), ('V_1',)], [('V_0', 'V_0'), ('V_0', 'V_1'), ('V_1', 'V_1')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',)), 'V_1': ('Y_t', ('Y_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0', 'Z_1'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric', 'Z_0__module_0__0', 'Z_0__module_0__1', 'Z_1__centric'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n3.0 * theta_0 * nodes_state[0],\n3.0 * theta_0 * nodes_state[1],\n3.0 * theta_0 * nodes_state[2]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 3)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\tif reac_ind==1:\n\t\tnodes_state[1] -= 1\n\t\tnodes_state[2] += 1\n\tif reac_ind==2:\n\t\tnodes_state[2] -= 1\n\t\tnodes_state[0] += 1\n\t\tnodes_state[3] += 1\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0, 1, 2), (3,)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,), (1,)])

    def test_sim_gill_net_diff_div_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'dl', 'type': 'S -> E + E', 'reaction_steps': 3}
        ]
        net = me.Network('net_diff_div_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t',)}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',), 'Y_t': ('Y_t',)})
        assert(sim.sim_variables_order == [[('V_0',), ('V_1',)], [('V_0', 'V_0'), ('V_0', 'V_1'), ('V_1', 'V_1')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',)), 'V_1': ('Y_t', ('Y_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0', 'Z_1'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric', 'Z_0__module_0__0', 'Z_0__module_0__1', 'Z_1__centric'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n3.0 * theta_0 * nodes_state[0],\n3.0 * theta_0 * nodes_state[1],\n3.0 * theta_0 * nodes_state[2]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 3)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\tif reac_ind==1:\n\t\tnodes_state[1] -= 1\n\t\tnodes_state[2] += 1\n\tif reac_ind==2:\n\t\tnodes_state[2] -= 1\n\t\tnodes_state[3] += 2\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0, 1, 2), (3,)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,), (1,)])

    def test_sim_gill_net_influx_markov(self):
        t = [
        {'start': 'env', 'end': 'Y_t', 'rate_symbol': 'din', 'type': '-> E', 'reaction_steps': 1}
        ]
        net = me.Network('net_influx_exp')
        net.structure(t)

        simulation_variables = {'Y_t': ('Y_t',)}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'Y_t': ('Y_t',)})
        assert(sim.sim_variables_order == [[('V_0',)], [('V_0', 'V_0')]])
        assert(sim.sim_variables_identifier == {'V_0': ('Y_t', ('Y_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n1.0 * theta_0 * 1.0\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 1)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] += 1\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0,)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,)])

    def test_sim_gill_net_efflux_erl3(self):
        t = [
        {'start': 'X_t', 'end': 'env', 'rate_symbol': 'dout', 'type': 'S ->', 'reaction_steps': 3}
        ]
        net = me.Network('net_efflux_erl3')
        net.structure(t)

        simulation_variables = {'X_t': ('X_t',)}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',)})
        assert(sim.sim_variables_order == [[('V_0',)], [('V_0', 'V_0')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric', 'Z_0__module_0__0', 'Z_0__module_0__1'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n3.0 * theta_0 * nodes_state[0],\n3.0 * theta_0 * nodes_state[1],\n3.0 * theta_0 * nodes_state[2]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 3)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\tif reac_ind==1:\n\t\tnodes_state[1] -= 1\n\t\tnodes_state[2] += 1\n\tif reac_ind==2:\n\t\tnodes_state[2] -= 1\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0, 1, 2)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,)])

    def test_sim_gill_net_min_2_4(self):
        net = me.Network('net_min_2_4')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t',
             'rate_symbol': 'd',
             'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t',
             'rate_symbol': 'l',
             'type': 'S -> S + S', 'reaction_steps': 4}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t',)}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',), 'Y_t': ('Y_t',)})
        assert(sim.sim_variables_order == [[('V_0',), ('V_1',)], [('V_0', 'V_0'), ('V_0', 'V_1'), ('V_1', 'V_1')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',)), 'V_1': ('Y_t', ('Y_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0', 'Z_1'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric',
                                                                         'Z_0__module_0__0',
                                                                         'Z_1__centric',
                                                                         'Z_1__module_1__0',
                                                                         'Z_1__module_1__1',
                                                                         'Z_1__module_1__2'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n2.0 * theta_0 * nodes_state[0],\n2.0 * theta_0 * nodes_state[1],\n4.0 * theta_1 * nodes_state[2],\n4.0 * theta_1 * nodes_state[3],\n4.0 * theta_1 * nodes_state[4],\n4.0 * theta_1 * nodes_state[5]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 6)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\tif reac_ind==1:\n\t\tnodes_state[1] -= 1\n\t\tnodes_state[2] += 1\n\tif reac_ind==2:\n\t\tnodes_state[2] -= 1\n\t\tnodes_state[3] += 1\n\tif reac_ind==3:\n\t\tnodes_state[3] -= 1\n\t\tnodes_state[4] += 1\n\tif reac_ind==4:\n\t\tnodes_state[4] -= 1\n\t\tnodes_state[5] += 1\n\tif reac_ind==5:\n\t\tnodes_state[5] -= 1\n\t\tnodes_state[2] += 2\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0, 1), (2, 3, 4, 5)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,), (1,)])

    def test_sim_gill_net_par2(self):
        net = me.Network('net_par2')
        net.structure([
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd4', 'type': 'S -> E', 'reaction_steps': 4},
            {'start': 'X_t', 'end': 'Y_t', 'rate_symbol': 'd2', 'type': 'S -> E', 'reaction_steps': 2},
            {'start': 'Y_t', 'end': 'Y_t', 'rate_symbol': 'l', 'type': 'S -> S + S', 'reaction_steps': 3}
            ])

        simulation_variables = {'X_t': ('X_t',), 'Y_t': ('Y_t',)}
        sim = me.Simulation(net)

        # to generate symbolic attributes we call some methods manually
        sim.prepare_simulation_variables(simulation_variables)
        sim.sim_gillespie.prepare_gillespie_simulation(sim.sim_variables_order, sim.sim_variables_identifier)

        # check all testable attributes for the simulation of this network
        assert(sim.sim_variables == {'X_t': ('X_t',), 'Y_t': ('Y_t',)})
        assert(sim.sim_variables_order == [[('V_0',), ('V_1',)], [('V_0', 'V_0'), ('V_0', 'V_1'), ('V_1', 'V_1')]])
        assert(sim.sim_variables_identifier == {'V_0': ('X_t', ('X_t',)), 'V_1': ('Y_t', ('Y_t',))})
        assert(sim.sim_gillespie.net_main_node_order_without_env == ['Z_0', 'Z_1'])
        assert(sim.sim_gillespie.net_hidden_node_order_without_env == ['Z_0__centric',
                                                                         'Z_0__module_0__0',
                                                                         'Z_0__module_0__1',
                                                                         'Z_0__module_0__2',
                                                                         'Z_0__module_1__0',
                                                                         'Z_1__centric',
                                                                         'Z_1__module_2__0',
                                                                         'Z_1__module_2__1'])
        assert(sim.sim_gillespie.sim_gill_propensities_eval == 'np.array([\n4.0 * theta_1 * nodes_state[0],\n2.0 * theta_0 * nodes_state[0],\n4.0 * theta_1 * nodes_state[1],\n4.0 * theta_1 * nodes_state[2],\n4.0 * theta_1 * nodes_state[3],\n2.0 * theta_0 * nodes_state[4],\n3.0 * theta_2 * nodes_state[5],\n3.0 * theta_2 * nodes_state[6],\n3.0 * theta_2 * nodes_state[7]\n])')
        assert(sim.sim_gillespie.sim_gill_reaction_number == 9)
        assert(sim.sim_gillespie.sim_gill_reaction_update_str == 'def reac_event_fct(nodes_state, reac_ind):\n\tif reac_ind==0:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[1] += 1\n\tif reac_ind==1:\n\t\tnodes_state[0] -= 1\n\t\tnodes_state[4] += 1\n\tif reac_ind==2:\n\t\tnodes_state[1] -= 1\n\t\tnodes_state[2] += 1\n\tif reac_ind==3:\n\t\tnodes_state[2] -= 1\n\t\tnodes_state[3] += 1\n\tif reac_ind==4:\n\t\tnodes_state[3] -= 1\n\t\tnodes_state[5] += 1\n\tif reac_ind==5:\n\t\tnodes_state[4] -= 1\n\t\tnodes_state[5] += 1\n\tif reac_ind==6:\n\t\tnodes_state[5] -= 1\n\t\tnodes_state[6] += 1\n\tif reac_ind==7:\n\t\tnodes_state[6] -= 1\n\t\tnodes_state[7] += 1\n\tif reac_ind==8:\n\t\tnodes_state[7] -= 1\n\t\tnodes_state[5] += 2\n\treturn nodes_state')
        assert(sim.sim_gillespie.summation_indices_nodes == [(0, 1, 2, 3, 4), (5, 6, 7)])
        assert(sim.sim_gillespie.summation_indices_variables == [(0,), (1,)])
