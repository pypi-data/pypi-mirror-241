"""
-------------------------------------------------
MHub - RT-Struct Conversion Module
       Converting DICOMSEG to RT Struct
-------------------------------------------------

-------------------------------------------------
Author: Leonard NÃ¼rnberg
Email:  leonard.nuernberg@maastrichtuniversity.nl
-------------------------------------------------
"""

from mhubio.core import Module, Instance, InstanceData, DataType, IO

from rt_utils import RTStructBuilder
import pydicom
import pydicom_seg
import colorspacious as cs

@IO.ConfigInput('source_seg', 'dicomseg:mod=seg', the="target segmentation files to convert to dicomseg")
@IO.ConfigInput('target_dicom', 'dicom:mod=ct', the="dicom data all segmentations align to")
@IO.Config('converted_file_name', str, 'seg.dcm', the='name of the converted file')
@IO.Config('bundle_name', str, None, the="bundle name converted data will be added to")
@IO.Config('use_pin_hole', bool, False, the='flag for pin holes. If set to true, lines will be erased through your mask such that each separate region within your image can be encapsulated via a single contour instead of contours nested within one another. Use this if your RT Struct viewer of choice does not support nested contours / contours with holes.')
@IO.Config('approximate_contours', bool, True, the='flag defines whether or not approximations are made when extracting contours from the input mask. Setting this to false will lead to much larger contour data within your RT Struct so only use this if as much precision as possible is required.')
class RTStructConverter_DSEG(Module):

    source_seg: DataType
    target_dicom: DataType
    skip_empty_slices: bool
    converted_file_name: str
    bundle_name: str
    model_name: str
    segment_id_meta_key: str
    body_part_examined: str
    use_pin_hole: bool
    approximate_contours: bool

    @IO.Instance()
    @IO.Input('source_seg', the="data to be converted")
    @IO.Input('target_dicom', the="dicom used as reference for the conversion")
    @IO.Output('out_data', path=IO.C('converted_file_name'), dtype='rtstruct:mod=seg', data='target_dicom', bundle=IO.C('bundle_name'), auto_increment=True, the="converted data")
    def task(self, instance: Instance, source_seg: InstanceData, target_dicom: InstanceData, out_data: InstanceData) -> None:
        

        # Create new RT Struct. Requires the DICOM series path for the RT Struct.
        rtstruct = RTStructBuilder.create_new(dicom_series_path=target_dicom.abspath)

        # read dicomseg
        dcmseg = pydicom.dcmread(source_seg.abspath)
        reader = pydicom_seg.SegmentReader()
        segs = reader.read(dcmseg)

        # Example segment info from DICOMSEG generated by MHub TotalSegmentator
        """
            (0008, 0100) Code Value                          SH: '123037004'
            (0008, 0102) Coding Scheme Designator            SH: 'SCT'
            (0008, 0104) Code Meaning                        LO: 'Body structure'
        ---------
        (0062, 0004) Segment Number                      US: 1
        (0062, 0005) Segment Label                       LO: 'Splenic structure'
        (0062, 0006) Segment Description                 ST: 'Spleen'
        (0062, 0008) Segment Algorithm Type              CS: 'AUTOMATIC'
        (0062, 0009) Segment Algorithm Name              LO: 'TotalSegmentator'
        (0062, 000d) Recommended Display CIELab Value    US: [34340, 40315, 27407]
        (0062, 000f)  Segmented Property Type Code Sequence  1 item(s) ---- 
            (0008, 0100) Code Value                          SH: '78961009'
            (0008, 0102) Coding Scheme Designator            SH: 'SCT'
            (0008, 0104) Code Meaning                        LO: 'Splenic structure'
        """


        for segment_number in segs.available_segments:

            # get segment data
            seg_image = segs.segment_image(segment_number)
            seg_data = segs.segment_data(segment_number)

            # get segment info
            info = segs.segment_infos[segment_number]

            # extract label, description and color
            label = info[0x0062, 0x0005].value
            desc = info[0x0062, 0x0006].value
            color_lab = info[0x0062, 0x000d].value
            color_lab = getLAB(*color_lab)
            color_rgb = cs.cspace_convert(color_lab, "CIELab", "sRGB255")

            # get mask
            print("segmentation image shape: ", seg_image.GetSize())
            print("segmentation shape: ", seg_data.shape)
            mask = seg_data.transpose(1, 2, 0).astype(bool)
            print("mask shape:         ", mask.shape)

            # add to rt struct
            rtstruct.add_roi(
                mask=mask,
                color=getRGB(*color_rgb), 
                name=label,
                description=desc,
                use_pin_hole=self.use_pin_hole,
                approximate_contours=self.approximate_contours
            )

        # save rt struct
        rtstruct.save(out_data.abspath)


def getRGB(r, g, b):
    r = max(0, min(255, round(r)))
    g = max(0, min(255, round(g)))
    b = max(0, min(255, round(b)))

    return [r, g, b]

def getLAB(L, a, b):
    L = L / 65535 * 100
    a = a / 65535 * 256 - 128
    b = b / 65535 * 256 - 128

    return L, a, b
