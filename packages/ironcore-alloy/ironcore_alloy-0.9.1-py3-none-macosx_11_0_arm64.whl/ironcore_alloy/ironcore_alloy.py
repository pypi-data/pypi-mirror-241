# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_ironcore_alloy_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_ironcore_alloy_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_ironcore_alloy_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)
class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.write_unchecked(cls.check(value), buf)

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("ironcore_alloy")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 24
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_ironcore_alloy_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_ironcore_alloy_checksum_method_saasshield_deterministic() != 47324:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshield_standard() != 56234:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshield_vector() != 46177:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt() != 30641:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt() != 34877:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_generate_query_field_values() != 9468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_get_in_rotation_prefix() != 52955:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt() != 27575:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt() != 50129:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_get_searchable_edek_prefix() != 52298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt() != 43265:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt() != 63039:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_generate_query_vectors() != 9358:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_get_in_rotation_prefix() != 65051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalone_deterministic() != 38390:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalone_standard() != 33373:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalone_vector() != 58660:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt() != 31880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt() != 27354:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_generate_query_field_values() != 4438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_get_in_rotation_prefix() != 16747:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt() != 59910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt() != 23420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_get_searchable_edek_prefix() != 26411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt() != 10461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt() != 32660:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_generate_query_vectors() != 54094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_get_in_rotation_prefix() != 19879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new() != 1512:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new_simple() != 14039:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_rotatablesecret_new() != 34169:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_saasshield_new() != 5586:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_saasshieldconfiguration_new() != 26856:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_secret_new() != 63251:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standalone_new() != 39855:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standaloneconfiguration_new() != 58783:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standalonesecret_new() != 63148:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_standardsecrets_new() != 953:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ironcore_alloy_checksum_constructor_vectorsecret_new() != 10315:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_ironcore_alloy_fn_free_alloymetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_alloymetadata.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new_simple.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new_simple.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_rotatablesecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_rotatablesecret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_rotatablesecret_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_rotatablesecret_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshield.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshield.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshield_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshield_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_deterministic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_deterministic.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_vector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_vector.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldconfiguration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldconfiguration.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshieldconfiguration_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshieldconfiguration_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshielddeterministicclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshielddeterministicclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_generate_query_field_values.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_generate_query_field_values.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_get_in_rotation_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_get_searchable_edek_prefix.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_get_searchable_edek_prefix.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldvectorclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldvectorclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_generate_query_vectors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_generate_query_vectors.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_get_in_rotation_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_secret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_secret_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_secret_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalone.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalone.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalone_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalone_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_deterministic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_deterministic.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_vector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_vector.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standaloneconfiguration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standaloneconfiguration.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standaloneconfiguration_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standaloneconfiguration_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonedeterministicclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonedeterministicclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_generate_query_field_values.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_generate_query_field_values.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_get_in_rotation_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonesecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonesecret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalonesecret_new.argtypes = (
    ctypes.c_int32,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalonesecret_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_get_searchable_edek_prefix.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_get_searchable_edek_prefix.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonevectorclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonevectorclient.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_generate_query_vectors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_generate_query_vectors.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_get_in_rotation_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_get_in_rotation_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_standardsecrets.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_standardsecrets.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standardsecrets_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standardsecrets_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ironcore_alloy_fn_free_vectorsecret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_free_vectorsecret.restype = None
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_vectorsecret_new.argtypes = (
    ctypes.c_float,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ironcore_alloy_fn_constructor_vectorsecret_new.restype = ctypes.c_void_p
_UniffiLib.ffi_ironcore_alloy_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_free.restype = None
_UniffiLib.ffi_ironcore_alloy_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rust_future_continuation_callback_set.argtypes = (
    _UNIFFI_FUTURE_CONTINUATION_T,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_continuation_callback_set.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i8.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i16.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_u64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_u64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_i64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_i64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f32.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_f64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_f64.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_pointer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    ctypes.c_size_t,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_poll_void.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_cancel_void.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_ironcore_alloy_rust_future_free_void.restype = None
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ironcore_alloy_rust_future_complete_void.restype = None
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_deterministic.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_deterministic.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_standard.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_standard.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_vector.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshield_vector.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_generate_query_field_values.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_generate_query_field_values.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshielddeterministicclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_get_searchable_edek_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldstandardclient_get_searchable_edek_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_generate_query_vectors.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_generate_query_vectors.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_saasshieldvectorclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_deterministic.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_deterministic.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_standard.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_standard.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_vector.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalone_vector.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_generate_query_field_values.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_generate_query_field_values.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonedeterministicclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_get_searchable_edek_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonestandardclient_get_searchable_edek_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_decrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_encrypt.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_generate_query_vectors.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_generate_query_vectors.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_get_in_rotation_prefix.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_method_standalonevectorclient_get_in_rotation_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new_simple.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_alloymetadata_new_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_rotatablesecret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_rotatablesecret_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshield_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshield_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshieldconfiguration_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_saasshieldconfiguration_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_secret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_secret_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalone_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalone_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standaloneconfiguration_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standaloneconfiguration_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalonesecret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standalonesecret_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standardsecrets_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_standardsecrets_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_vectorsecret_new.argtypes = (
)
_UniffiLib.uniffi_ironcore_alloy_checksum_constructor_vectorsecret_new.restype = ctypes.c_uint16
_UniffiLib.ffi_ironcore_alloy_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_ironcore_alloy_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationPointerManager = _UniffiPointerManager()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_FUTURE_CONTINUATION_T
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationPointerManager.release_pointer(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = asyncio.get_running_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _UniffiContinuationPointerManager.new_pointer((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

_UniffiLib.ffi_ironcore_alloy_rust_future_continuation_callback_set(_uniffi_continuation_callback)

# Public interface members begin here.


class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i32(value)

class _UniffiConverterFloat(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_float()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_float(value)

class _UniffiConverterBool(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write_unchecked(cls, value, buf):
        buf.write_u8(value)

    @staticmethod
    def lift(value):
        return value != 0

class _UniffiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = _UniffiConverterString.check(value)
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = _UniffiConverterString.check(value)
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def write(value, buf):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))
        buf.write_i32(len(value))
        buf.write(value)



class AlloyMetadata: 
    """
    Holds metadata fields as part of an SDK call. Each encrypted value will have metadata that associates
    it to a tenant ID as well as optional fields for other arbitrary key/value pairs and a request ID to send to the Tenant Security Proxy.
    Only the tenant ID will be used in Standalone SDKs, which can be created easily with `new_simple()`.
    """
  
    _pointer: ctypes.c_void_p
    def __init__(self, tenant_id: "TenantId",requesting_user_or_service_id: "typing.Optional[str]",data_label: "typing.Optional[str]",source_ip: "typing.Optional[str]",object_id: "typing.Optional[str]",request_id: "typing.Optional[str]",timestamp: "typing.Optional[str]",other_data: "dict"):
        """
        Constructor for AlloyMetadata which contains the tenant's ID and other metadata to send to the 
        Tenant Security Proxy. 

    
        Parameters:

        - `tenant_id`: Unique ID of tenant that is performing the operation.
        - `requesting_user_or_service_id`: Unique ID of user/service that is processing data. Must be nonempty.
        - `data_label`: Classification of data being processed.
        - `source_ip`: IP address of the initiator of this document request.
        - `object_id`: ID of the object/document being acted on in the host system.
        - `request_id`: Unique ID that ties host application request ID to tenant.
        - `timestamp`: An ISO 8601 timestamp of when the associated action took place. Most useful for
        - `other_data`: Additional String key/value pairs to add to metadata.
        """
  
        
        
        
        
        
        
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new,
        _UniffiConverterTypeTenantId.lower(tenant_id),
        _UniffiConverterOptionalString.lower(requesting_user_or_service_id),
        _UniffiConverterOptionalString.lower(data_label),
        _UniffiConverterOptionalString.lower(source_ip),
        _UniffiConverterOptionalString.lower(object_id),
        _UniffiConverterOptionalString.lower(request_id),
        _UniffiConverterOptionalString.lower(timestamp),
        _UniffiConverterMapStringString.lower(other_data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_alloymetadata, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_simple(cls, tenant_id: "TenantId"):
        """
        Simplified constructor for AlloyMetadata that only takes the tenant's ID and the 
        ID of the user/service that is processing data. 

    
        Parameters:

        - `tenant_id`: Unique ID of tenant that is performing the operation.
        """
  
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_alloymetadata_new_simple,
        _UniffiConverterTypeTenantId.lower(tenant_id))
        return cls._make_instance_(pointer)



class _UniffiConverterTypeAlloyMetadata:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, AlloyMetadata):
            raise TypeError("Expected AlloyMetadata instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return AlloyMetadata._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class RotatableSecret: 
    """
    A single secret that allows for rotation within a secret path.
    Used for Deterministic and Vector operations.
    """
  
    _pointer: ctypes.c_void_p
    def __init__(self, current_secret: "typing.Optional[StandaloneSecret]",in_rotation_secret: "typing.Optional[StandaloneSecret]"):
        """
        Create a rotating secret. This will error if both secrets are unset. If no secret for a path is desired, leave 
        that path out of the configuration entirely instead. 
        """
  
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_rotatablesecret_new,
        _UniffiConverterOptionalTypeStandaloneSecret.lower(current_secret),
        _UniffiConverterOptionalTypeStandaloneSecret.lower(in_rotation_secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_rotatablesecret, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeRotatableSecret:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, RotatableSecret):
            raise TypeError("Expected RotatableSecret instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return RotatableSecret._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SaasShield: 
    _pointer: ctypes.c_void_p
    def __init__(self, config: "SaasShieldConfiguration"):
        
        self._pointer = _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshield_new,
        _UniffiConverterTypeSaasShieldConfiguration.lower(config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshield, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def deterministic(self, ) -> "SaasShieldDeterministicClient":
        return _UniffiConverterTypeSaasShieldDeterministicClient.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_deterministic,self._pointer,)
        )






    def standard(self, ) -> "SaasShieldStandardClient":
        return _UniffiConverterTypeSaasShieldStandardClient.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_standard,self._pointer,)
        )






    def vector(self, ) -> "SaasShieldVectorClient":
        return _UniffiConverterTypeSaasShieldVectorClient.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshield_vector,self._pointer,)
        )






class _UniffiConverterTypeSaasShield:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SaasShield):
            raise TypeError("Expected SaasShield instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SaasShield._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SaasShieldConfiguration: 
    """
    Configuration for the SaaS Shield SDKs. Sets the TSP domain/URI and API key to be used for SaaS Shield operations.
    """
  
    _pointer: ctypes.c_void_p
    def __init__(self, tsp_uri: "str",api_key: "str",accept_invalid_certs: "bool",approximation_factor: "typing.Optional[float]"):
        
        
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_saasshieldconfiguration_new,
        _UniffiConverterString.lower(tsp_uri),
        _UniffiConverterString.lower(api_key),
        _UniffiConverterBool.lower(accept_invalid_certs),
        _UniffiConverterOptionalFloat.lower(approximation_factor))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldconfiguration, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeSaasShieldConfiguration:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SaasShieldConfiguration):
            raise TypeError("Expected SaasShieldConfiguration instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SaasShieldConfiguration._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SaasShieldDeterministicClient: 
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshielddeterministicclient, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, encrypted_field: "EncryptedField",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_decrypt(
                self._pointer, 
        _UniffiConverterTypeEncryptedField.lower(encrypted_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextField.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def encrypt(self, plaintext_field: "PlaintextField",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_encrypt(
                self._pointer, 
        _UniffiConverterTypePlaintextField.lower(plaintext_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedField.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def generate_query_field_values(self, fields_to_query: "dict",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_generate_query_field_values(
                self._pointer, 
        _UniffiConverterMapStringTypePlaintextField.lower(fields_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringSequenceTypeEncryptedField.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshielddeterministicclient_get_in_rotation_prefix(
                self._pointer, 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





class _UniffiConverterTypeSaasShieldDeterministicClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SaasShieldDeterministicClient):
            raise TypeError("Expected SaasShieldDeterministicClient instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SaasShieldDeterministicClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SaasShieldStandardClient: 
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldstandardclient, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, encrypted_document: "EncryptedDocument",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_decrypt(
                self._pointer, 
        _UniffiConverterTypeEncryptedDocument.lower(encrypted_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def encrypt(self, plaintext_document: "dict",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_encrypt(
                self._pointer, 
        _UniffiConverterMapStringBytes.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedDocument.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def get_searchable_edek_prefix(self, id: "int") -> "bytes":
        
        return _UniffiConverterBytes.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldstandardclient_get_searchable_edek_prefix,self._pointer,
        _UniffiConverterInt32.lower(id))
        )






class _UniffiConverterTypeSaasShieldStandardClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SaasShieldStandardClient):
            raise TypeError("Expected SaasShieldStandardClient instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SaasShieldStandardClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SaasShieldVectorClient: 
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_saasshieldvectorclient, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, encrypted_vector: "EncryptedVector",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_decrypt(
                self._pointer, 
        _UniffiConverterTypeEncryptedVector.lower(encrypted_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextVector.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def encrypt(self, plaintext_vector: "PlaintextVector",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_encrypt(
                self._pointer, 
        _UniffiConverterTypePlaintextVector.lower(plaintext_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedVector.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def generate_query_vectors(self, vectors_to_query: "dict",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_generate_query_vectors(
                self._pointer, 
        _UniffiConverterMapStringTypePlaintextVector.lower(vectors_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringSequenceTypeEncryptedVector.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_saasshieldvectorclient_get_in_rotation_prefix(
                self._pointer, 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





class _UniffiConverterTypeSaasShieldVectorClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SaasShieldVectorClient):
            raise TypeError("Expected SaasShieldVectorClient instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SaasShieldVectorClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Secret: 
    _pointer: ctypes.c_void_p
    def __init__(self, secret: "bytes"):
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_secret_new,
        _UniffiConverterBytes.lower(secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_secret, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeSecret:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Secret):
            raise TypeError("Expected Secret instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Secret._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Standalone: 
    _pointer: ctypes.c_void_p
    def __init__(self, config: "StandaloneConfiguration"):
        
        self._pointer = _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalone_new,
        _UniffiConverterTypeStandaloneConfiguration.lower(config))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalone, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def deterministic(self, ) -> "StandaloneDeterministicClient":
        return _UniffiConverterTypeStandaloneDeterministicClient.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_deterministic,self._pointer,)
        )






    def standard(self, ) -> "StandaloneStandardClient":
        return _UniffiConverterTypeStandaloneStandardClient.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_standard,self._pointer,)
        )






    def vector(self, ) -> "StandaloneVectorClient":
        return _UniffiConverterTypeStandaloneVectorClient.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalone_vector,self._pointer,)
        )






class _UniffiConverterTypeStandalone:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Standalone):
            raise TypeError("Expected Standalone instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Standalone._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StandaloneConfiguration: 
    """
    Configuration for the standalone SDKs. Sets secrets and secret paths for the different SDK operations.
    If usage of only one set of SDK operations is desired the others can be left as empty objects, and will error if
    called in that state.
    """
  
    _pointer: ctypes.c_void_p
    def __init__(self, standard: "StandardSecrets",deterministic: "dict",vector: "dict"):
        
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standaloneconfiguration_new,
        _UniffiConverterTypeStandardSecrets.lower(standard),
        _UniffiConverterMapTypeSecretPathTypeRotatableSecret.lower(deterministic),
        _UniffiConverterMapTypeSecretPathTypeVectorSecret.lower(vector))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standaloneconfiguration, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeStandaloneConfiguration:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StandaloneConfiguration):
            raise TypeError("Expected StandaloneConfiguration instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StandaloneConfiguration._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StandaloneDeterministicClient: 
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonedeterministicclient, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, encrypted_field: "EncryptedField",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_decrypt(
                self._pointer, 
        _UniffiConverterTypeEncryptedField.lower(encrypted_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextField.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def encrypt(self, plaintext_field: "PlaintextField",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_encrypt(
                self._pointer, 
        _UniffiConverterTypePlaintextField.lower(plaintext_field),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedField.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def generate_query_field_values(self, fields_to_query: "dict",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_generate_query_field_values(
                self._pointer, 
        _UniffiConverterMapStringTypePlaintextField.lower(fields_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringSequenceTypeEncryptedField.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonedeterministicclient_get_in_rotation_prefix(
                self._pointer, 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





class _UniffiConverterTypeStandaloneDeterministicClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StandaloneDeterministicClient):
            raise TypeError("Expected StandaloneDeterministicClient instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StandaloneDeterministicClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StandaloneSecret: 
    """
    A secret used by standalone mode to derive encryption keys.
    """
  
    _pointer: ctypes.c_void_p
    def __init__(self, id: "int",secret: "Secret"):
        """
        Create a standalone secret. The secret needs to be cryptographically random bytes. 
        """
  
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standalonesecret_new,
        _UniffiConverterInt32.lower(id),
        _UniffiConverterTypeSecret.lower(secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonesecret, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeStandaloneSecret:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StandaloneSecret):
            raise TypeError("Expected StandaloneSecret instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StandaloneSecret._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StandaloneStandardClient: 
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonestandardclient, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, encrypted_document: "EncryptedDocument",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_decrypt(
                self._pointer, 
        _UniffiConverterTypeEncryptedDocument.lower(encrypted_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def encrypt(self, plaintext_document: "dict",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_encrypt(
                self._pointer, 
        _UniffiConverterMapStringBytes.lower(plaintext_document),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedDocument.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def get_searchable_edek_prefix(self, id: "int") -> "bytes":
        
        return _UniffiConverterBytes.lift(
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_method_standalonestandardclient_get_searchable_edek_prefix,self._pointer,
        _UniffiConverterInt32.lower(id))
        )






class _UniffiConverterTypeStandaloneStandardClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StandaloneStandardClient):
            raise TypeError("Expected StandaloneStandardClient instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StandaloneStandardClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StandaloneVectorClient: 
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standalonevectorclient, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def decrypt(self, encrypted_vector: "EncryptedVector",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_decrypt(
                self._pointer, 
        _UniffiConverterTypeEncryptedVector.lower(encrypted_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePlaintextVector.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def encrypt(self, plaintext_vector: "PlaintextVector",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_encrypt(
                self._pointer, 
        _UniffiConverterTypePlaintextVector.lower(plaintext_vector),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEncryptedVector.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def generate_query_vectors(self, vectors_to_query: "dict",metadata: "AlloyMetadata"):
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_generate_query_vectors(
                self._pointer, 
        _UniffiConverterMapStringTypePlaintextVector.lower(vectors_to_query),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringSequenceTypeEncryptedVector.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





    def get_in_rotation_prefix(self, secret_path: "SecretPath",derivation_path: "DerivationPath",metadata: "AlloyMetadata"):
        
        
        
        return _uniffi_rust_call_async(
            _UniffiLib.uniffi_ironcore_alloy_fn_method_standalonevectorclient_get_in_rotation_prefix(
                self._pointer, 
        _UniffiConverterTypeSecretPath.lower(secret_path),
        _UniffiConverterTypeDerivationPath.lower(derivation_path),
        _UniffiConverterTypeAlloyMetadata.lower(metadata)
            ),
            _UniffiLib.ffi_ironcore_alloy_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ironcore_alloy_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            # Error FFI converter
            _UniffiConverterTypeAlloyError,
        )





class _UniffiConverterTypeStandaloneVectorClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StandaloneVectorClient):
            raise TypeError("Expected StandaloneVectorClient instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StandaloneVectorClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class StandardSecrets: 
    """
    A collection of secrets for standalone standard mode used to derive encryption keys.
    The primary secret id is used to look up the primary secret, which will be used for encrypting new documents.
    The rest of the secrets will only be used to decrypt existing documents when encountered.
    """
  
    _pointer: ctypes.c_void_p
    def __init__(self, primary_secret_id: "typing.Optional[int]",secrets: "typing.List[StandaloneSecret]"):
        """
        Create a collection of standard secrets. 
        This will error if secret ids aren't unique or the primary secret id isn't in the secrets list. 
        """
  
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeAlloyError,_UniffiLib.uniffi_ironcore_alloy_fn_constructor_standardsecrets_new,
        _UniffiConverterOptionalInt32.lower(primary_secret_id),
        _UniffiConverterSequenceTypeStandaloneSecret.lower(secrets))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_standardsecrets, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeStandardSecrets:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, StandardSecrets):
            raise TypeError("Expected StandardSecrets instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return StandardSecrets._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class VectorSecret: 
    _pointer: ctypes.c_void_p
    def __init__(self, approximation_factor: "float",secret: "RotatableSecret"):
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_constructor_vectorsecret_new,
        _UniffiConverterFloat.lower(approximation_factor),
        _UniffiConverterTypeRotatableSecret.lower(secret))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_ironcore_alloy_fn_free_vectorsecret, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class _UniffiConverterTypeVectorSecret:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, VectorSecret):
            raise TypeError("Expected VectorSecret instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return VectorSecret._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class EncryptedDocument: 
    """
    Document and EDEK (encrypted document encryption key) generated by `document_encrypt`/`documentEncrypt`.
    Note that `document_encrypt_deterministic`/`documentEncryptDeterministic` doesn't use this type
    as it prefixes an encryption header to the encrypted document map instead of using a separate EDEK.

    Attributes
    ----------
    edek : 
        Encrypted Document Encryption Key used when the document was encrypted
    document : 
        Map from field name to encrypted document bytes
    """

    edek: "EdekWithKeyIdHeader";document: "dict";

    @typing.no_type_check
    def __init__(self, edek: "EdekWithKeyIdHeader", document: "dict"):
        self.edek = edek
        self.document = document

    def __str__(self):
        return "EncryptedDocument(edek={}, document={})".format(self.edek, self.document)

    def __eq__(self, other):
        if self.edek != other.edek:
            return False
        if self.document != other.document:
            return False
        return True

class _UniffiConverterTypeEncryptedDocument(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedDocument(
            edek=_UniffiConverterTypeEdekWithKeyIdHeader.read(buf),
            document=_UniffiConverterMapStringBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEdekWithKeyIdHeader.write(value.edek, buf)
        _UniffiConverterMapStringBytes.write(value.document, buf)


class EncryptedField: 
    encrypted_field: "bytes";secret_path: "SecretPath";derivation_path: "DerivationPath";

    @typing.no_type_check
    def __init__(self, encrypted_field: "bytes", secret_path: "SecretPath", derivation_path: "DerivationPath"):
        self.encrypted_field = encrypted_field
        self.secret_path = secret_path
        self.derivation_path = derivation_path

    def __str__(self):
        return "EncryptedField(encrypted_field={}, secret_path={}, derivation_path={})".format(self.encrypted_field, self.secret_path, self.derivation_path)

    def __eq__(self, other):
        if self.encrypted_field != other.encrypted_field:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        return True

class _UniffiConverterTypeEncryptedField(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedField(
            encrypted_field=_UniffiConverterBytes.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.encrypted_field, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)


class EncryptedVector: 
    encrypted_vector: "typing.List[float]";secret_path: "SecretPath";derivation_path: "DerivationPath";paired_icl_info: "bytes";

    @typing.no_type_check
    def __init__(self, encrypted_vector: "typing.List[float]", secret_path: "SecretPath", derivation_path: "DerivationPath", paired_icl_info: "bytes"):
        self.encrypted_vector = encrypted_vector
        self.secret_path = secret_path
        self.derivation_path = derivation_path
        self.paired_icl_info = paired_icl_info

    def __str__(self):
        return "EncryptedVector(encrypted_vector={}, secret_path={}, derivation_path={}, paired_icl_info={})".format(self.encrypted_vector, self.secret_path, self.derivation_path, self.paired_icl_info)

    def __eq__(self, other):
        if self.encrypted_vector != other.encrypted_vector:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        if self.paired_icl_info != other.paired_icl_info:
            return False
        return True

class _UniffiConverterTypeEncryptedVector(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedVector(
            encrypted_vector=_UniffiConverterSequenceFloat.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
            paired_icl_info=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceFloat.write(value.encrypted_vector, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)
        _UniffiConverterBytes.write(value.paired_icl_info, buf)


class PlaintextField: 
    plaintext_field: "bytes";secret_path: "SecretPath";derivation_path: "DerivationPath";

    @typing.no_type_check
    def __init__(self, plaintext_field: "bytes", secret_path: "SecretPath", derivation_path: "DerivationPath"):
        self.plaintext_field = plaintext_field
        self.secret_path = secret_path
        self.derivation_path = derivation_path

    def __str__(self):
        return "PlaintextField(plaintext_field={}, secret_path={}, derivation_path={})".format(self.plaintext_field, self.secret_path, self.derivation_path)

    def __eq__(self, other):
        if self.plaintext_field != other.plaintext_field:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        return True

class _UniffiConverterTypePlaintextField(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlaintextField(
            plaintext_field=_UniffiConverterBytes.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.plaintext_field, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)


class PlaintextVector: 
    plaintext_vector: "typing.List[float]";secret_path: "SecretPath";derivation_path: "DerivationPath";

    @typing.no_type_check
    def __init__(self, plaintext_vector: "typing.List[float]", secret_path: "SecretPath", derivation_path: "DerivationPath"):
        self.plaintext_vector = plaintext_vector
        self.secret_path = secret_path
        self.derivation_path = derivation_path

    def __str__(self):
        return "PlaintextVector(plaintext_vector={}, secret_path={}, derivation_path={})".format(self.plaintext_vector, self.secret_path, self.derivation_path)

    def __eq__(self, other):
        if self.plaintext_vector != other.plaintext_vector:
            return False
        if self.secret_path != other.secret_path:
            return False
        if self.derivation_path != other.derivation_path:
            return False
        return True

class _UniffiConverterTypePlaintextVector(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlaintextVector(
            plaintext_vector=_UniffiConverterSequenceFloat.read(buf),
            secret_path=_UniffiConverterTypeSecretPath.read(buf),
            derivation_path=_UniffiConverterTypeDerivationPath.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceFloat.write(value.plaintext_vector, buf)
        _UniffiConverterTypeSecretPath.write(value.secret_path, buf)
        _UniffiConverterTypeDerivationPath.write(value.derivation_path, buf)


# AlloyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AlloyError(Exception):
    pass

_UniffiTempAlloyError = AlloyError

class AlloyError:  # type: ignore
    """
    Errors related to IronCore Alloy SDK
    """
  
    class InvalidConfiguration(_UniffiTempAlloyError):
        """
        Error while loading configuration. 
        """
        def __repr__(self):
            return "AlloyError.InvalidConfiguration({})".format(repr(str(self)))
    _UniffiTempAlloyError.InvalidConfiguration = InvalidConfiguration # type: ignore
    class InvalidKey(_UniffiTempAlloyError):
        """
        Error with key used 
        """
        def __repr__(self):
            return "AlloyError.InvalidKey({})".format(repr(str(self)))
    _UniffiTempAlloyError.InvalidKey = InvalidKey # type: ignore
    class InvalidInput(_UniffiTempAlloyError):
        """
        Error with user input 
        """
        def __repr__(self):
            return "AlloyError.InvalidInput({})".format(repr(str(self)))
    _UniffiTempAlloyError.InvalidInput = InvalidInput # type: ignore
    class EncryptError(_UniffiTempAlloyError):
        """
        Errors while encrypting 
        """
        def __repr__(self):
            return "AlloyError.EncryptError({})".format(repr(str(self)))
    _UniffiTempAlloyError.EncryptError = EncryptError # type: ignore
    class DecryptError(_UniffiTempAlloyError):
        """
        Errors while decrypting 
        """
        def __repr__(self):
            return "AlloyError.DecryptError({})".format(repr(str(self)))
    _UniffiTempAlloyError.DecryptError = DecryptError # type: ignore
    class ProtobufError(_UniffiTempAlloyError):
        """
        Error when parsing encryption headers/metadata 
        """
        def __repr__(self):
            return "AlloyError.ProtobufError({})".format(repr(str(self)))
    _UniffiTempAlloyError.ProtobufError = ProtobufError # type: ignore
    class TenantSecurityError(_UniffiTempAlloyError):
        """
        Error with requests to TSC 
        """
        def __repr__(self):
            return "AlloyError.TenantSecurityError({})".format(repr(str(self)))
    _UniffiTempAlloyError.TenantSecurityError = TenantSecurityError # type: ignore
    class IronCoreDocumentsError(_UniffiTempAlloyError):
        """
        Error with IronCore Documents 
        """
        def __repr__(self):
            return "AlloyError.IronCoreDocumentsError({})".format(repr(str(self)))
    _UniffiTempAlloyError.IronCoreDocumentsError = IronCoreDocumentsError # type: ignore

AlloyError = _UniffiTempAlloyError # type: ignore
del _UniffiTempAlloyError


class _UniffiConverterTypeAlloyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AlloyError.InvalidConfiguration(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return AlloyError.InvalidKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return AlloyError.InvalidInput(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return AlloyError.EncryptError(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return AlloyError.DecryptError(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return AlloyError.ProtobufError(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return AlloyError.TenantSecurityError(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return AlloyError.IronCoreDocumentsError(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, AlloyError.InvalidConfiguration):
            buf.write_i32(1)
        if isinstance(value, AlloyError.InvalidKey):
            buf.write_i32(2)
        if isinstance(value, AlloyError.InvalidInput):
            buf.write_i32(3)
        if isinstance(value, AlloyError.EncryptError):
            buf.write_i32(4)
        if isinstance(value, AlloyError.DecryptError):
            buf.write_i32(5)
        if isinstance(value, AlloyError.ProtobufError):
            buf.write_i32(6)
        if isinstance(value, AlloyError.TenantSecurityError):
            buf.write_i32(7)
        if isinstance(value, AlloyError.IronCoreDocumentsError):
            buf.write_i32(8)



class _UniffiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalFloat(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterFloat.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterFloat.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeStandaloneSecret(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeStandaloneSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeStandaloneSecret.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceFloat(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterFloat.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterFloat.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeStandaloneSecret(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeStandaloneSecret.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeStandaloneSecret.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEncryptedField(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEncryptedField.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEncryptedField.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEncryptedVector(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEncryptedVector.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEncryptedVector.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterString.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringBytes(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterBytes.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypePlaintextField(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypePlaintextField.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypePlaintextField.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypePlaintextVector(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypePlaintextVector.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypePlaintextVector.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringSequenceTypeEncryptedField(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceTypeEncryptedField.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceTypeEncryptedField.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringSequenceTypeEncryptedVector(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceTypeEncryptedVector.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceTypeEncryptedVector.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeSecretPathTypeRotatableSecret(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeSecretPath.write(key, buf)
            _UniffiConverterTypeRotatableSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeSecretPath.read(buf)
            val = _UniffiConverterTypeRotatableSecret.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeSecretPathTypeVectorSecret(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeSecretPath.write(key, buf)
            _UniffiConverterTypeVectorSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeSecretPath.read(buf)
            val = _UniffiConverterTypeVectorSecret.read(buf)
            d[key] = val
        return d


# Type alias
DerivationPath = str

class _UniffiConverterTypeDerivationPath:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


# Type alias
EdekWithKeyIdHeader = bytes

class _UniffiConverterTypeEdekWithKeyIdHeader:
    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterBytes.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterBytes.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterBytes.lower(value)


# Type alias
SecretPath = str

class _UniffiConverterTypeSecretPath:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


# Type alias
TenantId = str

class _UniffiConverterTypeTenantId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)

__all__ = [
    "InternalError",
    "AlloyError",
    "EncryptedDocument",
    "EncryptedField",
    "EncryptedVector",
    "PlaintextField",
    "PlaintextVector",
    "AlloyMetadata",
    "RotatableSecret",
    "SaasShield",
    "SaasShieldConfiguration",
    "SaasShieldDeterministicClient",
    "SaasShieldStandardClient",
    "SaasShieldVectorClient",
    "Secret",
    "Standalone",
    "StandaloneConfiguration",
    "StandaloneDeterministicClient",
    "StandaloneSecret",
    "StandaloneStandardClient",
    "StandaloneVectorClient",
    "StandardSecrets",
    "VectorSecret",
]

