import os

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List, Optional, Tuple, Union

from gretel_client.gretel.artifact_fetching import ReportType
from gretel_client.gretel.exceptions import BaseConfigError, ConfigSettingError
from gretel_client.projects.exceptions import ModelConfigError
from gretel_client.projects.models import read_model_config


class ModelName(str, Enum):
    """Name of the model parameter dict in the config.

    Note: The values are the names used in the model configs.
    """

    # tabular
    ACTGAN = "actgan"
    AMPLIFY = "amplify"
    LSTM = "synthetics"
    TABULAR_DP = "tabular_dp"

    # text
    GPT_X = "gpt_x"

    # time series
    DGAN = "timeseries_dgan"


@dataclass(frozen=True)
class ModelConfigSections:
    """Config sections for each model type.

    Args:
        model_name: Model name used in the url of the model docs.
        config_sections: List of nested config sections (e.g., `params`).
        data_source_optional: If True, the `data_source` config parameter is optional.
        report_type: The type of quality report generated by the model.
        extra_kwargs: List of non-nested config sections.
    """

    model_name: str
    config_sections: List[str]
    data_source_optional: bool
    report_type: Optional[ReportType] = None
    extra_kwargs: Optional[List[str]] = None


CONFIG_SETUP_DICT = {
    ModelName.ACTGAN: ModelConfigSections(
        model_name="actgan",
        config_sections=["params", "generate", "privacy_filters", "evaluate"],
        data_source_optional=False,
        report_type=ReportType.SQS,
        extra_kwargs=["ref_data"],
    ),
    ModelName.AMPLIFY: ModelConfigSections(
        model_name="amplify",
        config_sections=["params", "evaluate"],
        data_source_optional=False,
        report_type=ReportType.SQS,
        extra_kwargs=["ref_data"],
    ),
    ModelName.LSTM: ModelConfigSections(
        model_name="lstm",
        config_sections=[
            "params",
            "generate",
            "validators",
            "fallback",
            "data_checks",
            "privacy_filters",
            "evaluate",
        ],
        data_source_optional=False,
        report_type=ReportType.SQS,
        extra_kwargs=["ref_data"],
    ),
    ModelName.TABULAR_DP: ModelConfigSections(
        model_name="tabular_dp",
        config_sections=["params", "generate", "evaluate"],
        data_source_optional=False,
        report_type=ReportType.SQS,
        extra_kwargs=["ref_data"],
    ),
    ModelName.GPT_X: ModelConfigSections(
        model_name="gpt",
        config_sections=["params", "generate"],
        data_source_optional=True,
        report_type=ReportType.TEXT,
        extra_kwargs=["pretrained_model", "column_name", "validation", "ref_data"],
    ),
    ModelName.DGAN: ModelConfigSections(
        model_name="dgan",
        config_sections=["params", "generate"],
        data_source_optional=False,
        report_type=None,
        extra_kwargs=[
            "attribute_columns",
            "df_style",
            "discrete_columns",
            "example_id_column",
            "feature_columns",
            "ref_data",
            "time_column",
        ],
    ),
}


def _backwards_compat_transform_config(
    config: dict, non_default_settings: dict
) -> dict:
    """
    If the base config is in old format *and* the user passes in a params dict, move the
    non-default params to the base (non-nested) config level to be consistent with old format.
    """
    model_type, model_config_section = extract_model_config_section(config)
    if (
        model_type == ModelName.GPT_X.value
        and "params" in non_default_settings
        and "params" not in model_config_section
    ):
        params = non_default_settings.pop("params")
        model_config_section.update(params)
    return config


def create_model_config_from_base(
    base_config: Union[str, Path],
    job_label: Optional[str] = None,
    **non_default_settings,
) -> dict:
    """Create a Gretel model config by updating a base config.

    To update the base config, pass in keyword arguments, where the keys
    are config section names and the values are dicts of non-default settings.
    If the parameter is not nested within a section, pass it directly as
    a keyword argument.

    The base config can be given as a yaml file path or the name of one of
    the Gretel template files (without the extension) listed here:
    https://github.com/gretelai/gretel-blueprints/tree/main/config_templates/gretel/synthetics

    Examples::

        # Create an ACTGAN config with 10 epochs.
        from gretel_client.gretel.config_setup import create_model_config_from_base
        config = create_model_config_from_base(
            base_config="tabular-actgan",
            params={"epochs": 10},
        )

        # Create a GPT config with a custom column name and 100 epochs.
        from gretel_client.gretel.config_setup import create_model_config_from_base
        config = create_model_config_from_base(
            base_config="natural-language",
            column_name="custom_name", # not nested in a config section
            params={"epochs": 100},    # nested in the `params` section
        )


    The model configs are documented at
    https://docs.gretel.ai/reference/synthetics/models. For ACTGAN, the
    available config sections are `params`, `generate`, and `privacy_filters`.

    Args:
        base_config: Base config name or yaml config path.
        job_label: Descriptive label to append to job the name.

    Raises:
        BaseConfigError: If the base config is an invalid name or path.
        ConfigSettingError: If the config section or setting format is invalid.

    Returns:
        The model config derived from the base template and non-default settings.
    """
    if not os.path.isfile(base_config):
        base_config = (
            base_config
            if base_config.startswith("synthetics/")
            else f"synthetics/{base_config}"
        )

    try:
        config = read_model_config(base_config)
    except ModelConfigError as e:
        raise BaseConfigError(
            f"`{base_config}` is not a valid base config. You must either "
            "pass a local yaml file path or use the name of a template yaml file "
            "(without the extension) listed here: https://github.com/gretelai/"
            "gretel-blueprints/tree/main/config_templates/gretel/synthetics"
        ) from e

    model_type, model_config_section = extract_model_config_section(config)
    setup = CONFIG_SETUP_DICT[ModelName(model_type)]

    config = _backwards_compat_transform_config(config, non_default_settings)

    if job_label is not None:
        config["name"] = f"{config['name']}-{job_label}"

    for section, settings in non_default_settings.items():
        if not isinstance(settings, dict):
            extra_kwargs = setup.extra_kwargs or []
            if section in extra_kwargs:
                model_config_section[section] = settings
            else:
                raise ConfigSettingError(
                    f"`{section}` is an invalid keyword argument. Valid options "
                    f"include {setup.config_sections + extra_kwargs}."
                )
        elif section not in setup.config_sections:
            raise ConfigSettingError(
                f"`{section}` is not a valid `{setup.model_name}` config section. "
                f"Must be one of [{setup.config_sections}]."
            )
        else:
            model_config_section.setdefault(section, {}).update(settings)
    return config


def extract_model_config_section(config: dict) -> Tuple[str, dict]:
    """Extract the model type and config dict from a Gretel model config.

    Args:
        config: The full Gretel config.

    Returns:
        A tuple of the model type and the model section from the config.
    """
    return next(iter(config["models"][0].items()))
