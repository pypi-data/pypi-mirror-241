# coding: utf-8

"""
    Snowflake Warehouse API

    The Snowflake Warehouse API is a REST API that you can use to access, customize and manage virtual warehouse in a Snowflake account.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Contact: support@snowflake.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import annotations
from inspect import getfullargspec
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, Dict, Optional
from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator

class Warehouse(BaseModel):
    name: constr(strict=True) = ...
    warehouse_type: Optional[StrictStr] = Field(None, description="Type of warehouse, possible types: STANDARD, SNOWPARK-OPTIMIZED")
    warehouse_size: Optional[StrictStr] = Field(None, description="Size of warehouse, possible sizes: XSMALL, SMALL, MEDIUM, LARGE, XLARGE, XXLARGE, XXXLARGE, X4LARGE, X5LARGE, X6LARGE")
    wait_for_completion: Optional[StrictStr] = None
    max_cluster_count: Optional[StrictInt] = None
    min_cluster_count: Optional[StrictInt] = None
    scaling_policy: Optional[StrictStr] = Field(None, description="Scaling policy of warehouse, possible scaling policies: STANDARD, ECONOMY")
    auto_suspend: Optional[StrictInt] = Field(None, description="time in seconds before auto suspend")
    auto_resume: Optional[StrictStr] = None
    initially_suspended: Optional[StrictStr] = None
    resource_monitor: Optional[constr(strict=True)] = None
    comment: Optional[StrictStr] = None
    enable_query_acceleration: Optional[StrictStr] = None
    query_acceleration_max_scale_factor: Optional[StrictInt] = None
    max_concurrency_level: Optional[StrictInt] = None
    statement_queued_timeout_in_seconds: Optional[StrictInt] = None
    statement_timeout_in_seconds: Optional[StrictInt] = None
    tags: Optional[Dict[str, StrictStr]] = Field(None, description="<tag_name> = '<tag_value>' , ...")
    type: Optional[StrictStr] = Field(None, description="Type of warehouse, possible types: STANDARD, SNOWPARK-OPTIMIZED")
    size: Optional[StrictStr] = Field(None, description="names of size: X-Small, Small, Medium, Large, X-Large, 2X-Large, 3X-Large, 4X-Large, 5X-Large, 6X-Large")
    state: Optional[StrictStr] = Field(None, description="The state of warehouse, possible states: STARTED, STARTING, DYNAMIC, SUSPENDED, RESIZING, RESUMING, SUSPENDING")
    started_clusters: Optional[StrictInt] = Field(None, description="Number of clusters currently started.")
    running: Optional[StrictInt] = Field(None, description="Number of SQL statements that are being executed by the warehouse.")
    queued: Optional[StrictInt] = Field(None, description="Number of SQL statements that are queued for the warehouse.")
    is_default: Optional[StrictStr] = Field(None, description="Whether the warehouse is the default for the current user.")
    is_current: Optional[StrictStr] = Field(None, description="Whether the warehouse is in use for the session. Only one warehouse can be in use at a time for a session. To specify or change the warehouse for a session, use the USE WAREHOUSE command.")
    available: Optional[StrictStr] = Field(None, description="Percentage of the warehouse compute resources that are provisioned and available.")
    provisioning: Optional[StrictStr] = Field(None, description="Percentage of the warehouse compute resources that are in the process of provisioning.")
    quiescing: Optional[StrictStr] = Field(None, description="Percentage of the warehouse compute resources that are executing SQL statements, but will be shut down once the queries complete.")
    other: Optional[StrictStr] = Field(None, description="Percentage of the warehouse compute resources that are in a state other than available, provisioning, or quiescing.")
    created_on: Optional[datetime] = Field(None, description="Date and time when the warehouse was created.")
    resumed_on: Optional[datetime] = Field(None, description="Date and time when the warehouse was last started or restarted.")
    updated_on: Optional[datetime] = Field(None, description="Date and time when the warehouse was last updated, which includes changing any of the properties of the warehouse or changing the state (STARTED, SUSPENDED, RESIZING) of the warehouse.")
    owner: Optional[StrictStr] = Field(None, description="Role that owns the warehouse.")
    kind: Optional[StrictStr] = None
    tag: Optional[Any] = None
    __properties = ["name", "warehouse_type", "warehouse_size", "wait_for_completion", "max_cluster_count", "min_cluster_count", "scaling_policy", "auto_suspend", "auto_resume", "initially_suspended", "resource_monitor", "comment", "enable_query_acceleration", "query_acceleration_max_scale_factor", "max_concurrency_level", "statement_queued_timeout_in_seconds", "statement_timeout_in_seconds", "tags", "type", "size", "state", "started_clusters", "running", "queued", "is_default", "is_current", "available", "provisioning", "quiescing", "other", "created_on", "resumed_on", "updated_on", "owner", "kind", "tag"]

    @validator('name')
    def name_validate_regular_expression(cls, v):
        if not re.match(r"""^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/""")
        return v

    @validator('wait_for_completion')
    def wait_for_completion_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    @validator('auto_resume')
    def auto_resume_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    @validator('initially_suspended')
    def initially_suspended_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    @validator('resource_monitor')
    def resource_monitor_validate_regular_expression(cls, v):
        if v is None:
            return v
        if not re.match(r"""^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/""")
        return v

    @validator('enable_query_acceleration')
    def enable_query_acceleration_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    @validator('is_default')
    def is_default_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('N', 'Y'):
            raise ValueError("must validate the enum values ('N', 'Y')")
        return v

    @validator('is_current')
    def is_current_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('N', 'Y'):
            raise ValueError("must validate the enum values ('N', 'Y')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Warehouse:
        """Create an instance of Warehouse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "state",
                            "started_clusters",
                            "running",
                            "queued",
                            "is_default",
                            "is_current",
                            "available",
                            "provisioning",
                            "quiescing",
                            "other",
                            "created_on",
                            "resumed_on",
                            "updated_on",
                            "owner",
                            "kind",
                          },
                          exclude_none=True)
        # set to None if tag (nullable) is None
        if self.tag is None:
            _dict['tag'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Warehouse:
        """Create an instance of Warehouse from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return Warehouse.parse_obj(obj)

        _obj = Warehouse.parse_obj({
            "name": obj.get("name"),
            "warehouse_type": obj.get("warehouse_type"),
            "warehouse_size": obj.get("warehouse_size"),
            "wait_for_completion": obj.get("wait_for_completion"),
            "max_cluster_count": obj.get("max_cluster_count"),
            "min_cluster_count": obj.get("min_cluster_count"),
            "scaling_policy": obj.get("scaling_policy"),
            "auto_suspend": obj.get("auto_suspend"),
            "auto_resume": obj.get("auto_resume"),
            "initially_suspended": obj.get("initially_suspended"),
            "resource_monitor": obj.get("resource_monitor"),
            "comment": obj.get("comment"),
            "enable_query_acceleration": obj.get("enable_query_acceleration"),
            "query_acceleration_max_scale_factor": obj.get("query_acceleration_max_scale_factor"),
            "max_concurrency_level": obj.get("max_concurrency_level"),
            "statement_queued_timeout_in_seconds": obj.get("statement_queued_timeout_in_seconds"),
            "statement_timeout_in_seconds": obj.get("statement_timeout_in_seconds"),
            "tags": obj.get("tags"),
            "type": obj.get("type"),
            "size": obj.get("size"),
            "state": obj.get("state"),
            "started_clusters": obj.get("started_clusters"),
            "running": obj.get("running"),
            "queued": obj.get("queued"),
            "is_default": obj.get("is_default"),
            "is_current": obj.get("is_current"),
            "available": obj.get("available"),
            "provisioning": obj.get("provisioning"),
            "quiescing": obj.get("quiescing"),
            "other": obj.get("other"),
            "created_on": obj.get("created_on"),
            "resumed_on": obj.get("resumed_on"),
            "updated_on": obj.get("updated_on"),
            "owner": obj.get("owner"),
            "kind": obj.get("kind"),
            "tag": obj.get("tag")
        })
        return _obj

