# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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X7WOk4HfVJvLxPZCVSoz8DeGlrchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchlLchBIgQytsQytsQytsQytsQytsQytsQytsQytsQytsQytsQytsQytsQytsQytsQytuQHfI6rGA78K/807xcsP1bhMEIwmAEYTCCMBhBGIwgDEYQBiMIgxGEwQjCYARhMIIwGEEYjCAMRhAGIwiDEYTBCMJgBGEwgjAYQRiMIAxGEAYjCIMRhMEIwmAEYTCCMBhBGIwgDEYQBiMIgxGEwQjCYARhMIIwGEEYjCAMRhAGIwiDEYTBCMJgBGEwgjAYQRiMIAxGEAYjCIMRhMEIwmAEYTCCMBhBGIwgDEYQBiMIgxGEwQjCYARhMIIwGEEYjCAMRhAGIwiDEYTBCMJgBGEwgjAYQRiMIAxGEAYjCIMRhMEIwmAEYTCCMBhBGIwgDEYQBiMIgxGEwQjCYARhMIIwGEEYjCAMRhAGIwiDEYTBCMJgxA6Dj1ph0Dp5wP8aZkXAv7O4O8sXDYv/y5CMdI+RC5JbDC2milBMFaGYKkIxVYRiqgjFVBGKqSIUU0UopopQTBWhmCpCMVWEYqoIxVQRiqkiFFNFKKaKUEwVoZgqQjFVhGKqCMVUEYqpIhRTRSimilBMFaGYKkIxVYRiqgjFVBGKqSIUU0UopopQTBWhmCpCMVWEYqoIxVQRiqkiFFNFKKaKUEwVoZgqQjFVhGKqCMVUEYqpIhRTRXYx9b8Nmcv9L8u4tHG74iHFaMUUxRJFneJuxWzFWMXDCocipqhUzFdsUaxR1CqSimWKiYqFik2K4YpHFC2KIsX9insVGxTNigcUNYpHFZsVfkW1wqlYpMhTtCtGKcYrvIqVioBilmKjYrLCpWhVVCjGKBoU0xTrFEsVCcUKxVRFp2KColgxTzFJsVXRpFirmKtoVIxTdChKFFUK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NZ8IusVuBC0//mZ+4BOQfyzW1xbGStRLrJEISCyTcEs0SAyTmCqxVmKmhC4Rk2iVCEl0SYyXmCMxUuJRicck/BKzBdr137Quplu/nh+p+PdNPWT+sE8aP/ynPXmr5/KC+VsYObSEGlpC/RyXUGrFMy7/0dye8JKh98rQe+V8bjc47xHVAq24f6FvllEo0XdhjM5SP7QR2gFthzToMNQDdUDHoNPQcamB2s56chXkxktdeOlApbcLs52WTkAroRp0EloONeMbevgNl0JzoYPQCqgJWg2dkmrXm4ai4HkVBdV7fTKGIofC4XlTMvwWFjk1ucipyUVOTS5yanKRU5OLnJpc5NTkIqcmFzk1ucipyUVOTS5yanKRU5OLnJpc5NTkIqcmFzk1ucipyUVOTS5yanKRU5OLnJpc5NTkIqcmFzk1ucipmVHofzu3wf6qO3+W22C/gED2BQS5L1iB7LeRofqQofqQofqQofqQofqQofqQofqQofqQofqQofqQofqQofqQofqYofqQofqQofqYofqYofqQofqQofqQofqQofqQofqQofqQofqYofqQofqQofqQofqQofrwy+vDL7YPGarP+sX+ztu1jj+TH2odfzxbxz8yT47fte88GOZRjZHR5r0Gv67+Pa5fMs/5upZF+YFx4CPq/NolkZN4XOIJid0S6yT2SGgST0rslXhKYr1EWWK4xEaJTRI1iX0SmyX2S3RJLJd4WiIq0SMxX2KrRL9Ep8RiiVESByR6JUZIhCW2SWyXOCzRITFR4qjEIokmiSMSjRJeiecldkhMlnhDYqdAuz5Gdvr+zer0XXpm/6M6/S/deWvq6Ktu9eLfUy+23wuLzNd+1nztW27Q7URQFRMftAvms8fEwRt1n3vYc8KcHfecEDBoW247oNlxzNmF2w5o9m7c1sbZXZ6zxbRzCWX68LcPYW+1+bZPRi5zr3L9054z4e2X33UMs+N2u36Z+auyi44tKDMs1UEd0EloJdQkNZCtt6Ai2YIaZAvqky3I61uQ17cgr29BXt/CSmYLKpktqGS2sJLZwkpmCyqZLahktqB22YLiYQtqly0oJbagktliFRafw82/DeZLkpAPugPSoGugqdBV0A3QOOhC6E6oDspDo6CboMXQXCgM3Q3dDjVCk6H7oHqoCs2GLoJug26E7oFyUAK6HHoAuh9qgS6DLoBu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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
