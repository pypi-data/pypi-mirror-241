# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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0AZoI7QJikOboUZoC3QvdB90P7QV2gY9AG2HRqAHoR1QO7QT8kBNUD9UDiWgXdBuaA+0F9oHJaFaqB5qhVLQfqgPOgANQAehQ9BhKA1loCNQM9QCZaGj0EPQ09DD0DPQI9Cj0LPQc9Bj0OPQE9CT0FPQKGSDFKgEckBOqAxyQdVQBVQJ1UB1ULGUph5Wfvy7wT5ubNz6brBCsb21Dhd6K+N8su+it/pFvRnsi/rGw8bvKdTov9A3Hv/lvj2s0GQVCvZP9fawW9+b85v99rC0ftAYOznwv40TdjNvcQhtR+P2Nt5Q+CZvIyy0cre257ceS7f26W/noCo07Lc0gG/nmCq06YWDq9CmGy3vKuM7P197+BbvShxrGH/hh9/beY/YL+84vPXwKxyZN4/DI+gdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvegdvej6vOgkvegkvegkvegPvegPvegPveg5veg5vegdvegWvegPvegBvegBvejlvOhAveg5vegyvegyvegkvegkvegkvegkvVbvmDXjd2yJw4HT3x04/d2B098dOP3dgdPfHTj93YHT3x04qd2BE9cdOFXdgRPQHTgB3YET0B045dyB08MdmLF08FRZB87zduB8bQdPo3XgpGwHTsp24KRsB07DduB8WwdOrnbg5GoHTqd24HRqB06nduB0agdOp3bglGkHTm924PRmB05vduCEZgdOTHbgxGQHTky2dCd0NzQDOg5FoKVQNXQS6oVmQ9OgcdBpSIWGoR7ICeWgM9BZaDw0E1oodfMcbAfeieDAew8ceO+BA+89cOC9Bw6828CBdxs48G4DB95D4MC7Bhx414AD7xpw4F0DDrwzwIFz+h04p9+Bs/gdOIvfgbP4HTgb3YFz+h04p9+Bc/odOFPfwfPfHThV34FT9R04Vd+BU/Ud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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
