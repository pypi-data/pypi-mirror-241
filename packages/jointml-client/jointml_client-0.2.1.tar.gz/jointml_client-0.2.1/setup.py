# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['joint_ml']

package_data = \
{'': ['*']}

install_requires = \
['clint>=0.5.1,<0.6.0',
 'colorama>=0.4.6,<0.5.0',
 'pandas>=2.1.0,<3.0.0',
 'pyfiglet>=1.0.2,<2.0.0',
 'torch>=2.0.1,<3.0.0']

setup_kwargs = {
    'name': 'jointml-client',
    'version': '0.2.1',
    'description': 'The package provides an interface for working with the https://jointml.ru/ platform.',
    'long_description': '# Joint-ml\n \nДанный пакет помогает реализовать удобный интрерфейс для использования вашей модели\nв федеративном обучении на нашей платформе. \n\n## Установка \n\nУстанавливаем joint-ml с помощью pip:\n```sh\npip install jointml-client\n```\n\n## Создание клиента\n\n### Требования\nДля установки и запуска проекта, необходим Python>=3.8.0\n\n\n### Шаг 1: Создаем модуль\nСоздайте python файл, который называется "client_methods.py" в корневом каталоге вашего git репозитория:\n```sh\nclient_methods.py\n```\n\n### Шаг 2: В файле client_methods.py необходимо реализовать методы: load_model, get_dataset, train, test: \n\n#### Метод 1: load_model: \n*Метод для генерации модели*.   \nНа вход будут подаваться параметры, указанные на сервисе как Init Parameters.\nОбязательные параметры, которые необходимо учитывать разработчику ML:  \n**init_parameters** - параметры, которые разработчик ML указывает на сайте в разделе Init Parameters  \n*Возвращает: (nn.Module) - модель*.\n\n```python\ndef load_model(n_features, hidden_dim) -> nn.Module:\n    model = Net(n_features, hidden_dim)\n    return model\n```\n\n#### Метод 2: get_dataset: \n*Метод для чтения, предобработки и разбития датасета(with_split=True).*  \nНа вход будут подаваться dataset_path, with_split,\nа также параметры, которые разработчик ML укажет в коде как необходимые(специфические для каждого отдельного пользователя)\nТут описывается вся логика предобработки датасета.\nОбязательные параметры, которые необходимо учитывать разработчику ML:  \n- **dataset_path(str)** - путь до csv-файла с датасетом;\n- **with_split(bool)** - булева переменная, говорящая о необходимости разбития датасета на выборки(train, valid, test). \nЕсли True, тогда следует после предобработки данных разбить их на одну из следующих выборок - (train, test), (train, valid, test). \nЕсли False, тогда требуется лишь предобработка данных и возвращение лишь подготовленного датасета (\nв дальнейшем будет использоваться для получения предсказаний модели на данных пользователя).\n\n*Возвращает один из следующих кортежей:*  \n- *(torch.utils.data.Dataset, torch.utils.data.Dataset, torch.utils.data.Dataset) - возвращается при with_split=True. В будущем используется как train_set, valid_set и test_set*  \n- *(torch.utils.data.Dataset, torch.utils.data.Dataset) - возвращается при with_split=True. В будущем используется как train_set и test_set*  \n- *(torch.utils.data.Dataset) - возвращается при with_split=False. В будущем используется как test_set(выборка для тестирования модели на весах)*  \n\n```python\ndef get_dataset(dataset_path: str, with_split: bool, test_size: float, shuffle: bool) -> Union[\n    Tuple[torch.utils.data.Dataset, torch.utils.data.Dataset, torch.utils.data.Dataset],\n    Tuple[torch.utils.data.Dataset, torch.utils.data.Dataset], Tuple[torch.utils.data.Dataset]]:\n    transactions, labels = load_dataset(dataset_path)\n    if with_split:\n        x_train, x_test, y_train, y_test = train_test_split(transactions, labels, test_size=test_size, shuffle=shuffle)\n        x_train, x_test = preprocess_data(x_train, x_test)\n\n        train_set = TransactionsDataset(x_train, y_train)\n        test_set = TransactionsDataset(x_test, y_test)\n\n        return train_set, test_set\n    else:\n        x_test = preprocess_set(transactions)\n        test_set = TransactionsDataset(x_test, labels)\n        return test_set\n```\n\n#### Метод 3: train:\n*Метод для тренировки модели, полученной из метода load_model.*  \nНа вход будут подаваться: модель, сгенерированная методом load_model, train_set полученный из метода get_dataset, valid_set(опционально) полученный из\nметода get_dataset(если возврат выборки предусмотрен разработчиком ML в методе get_dataset), а также\nпараметры, которые разработчик ML укажет в коде как необходимые(специфические для каждого отдельного пользователя).  \nОбязательные параметры, которые необходимо учитывать разработчику ML:\n- **model(nn.Module)** - модель, полученная из метода load_model;\n- **train_set(torch.utils.data.Dataset)** - тренировочная выборка, полученная из метода get_dataset;\n- **valid_set(torch.utils.data.Dataset)** - валидационная выборка, полученная из метода get_dataset; Подается на вход только если в методе\n- **get_dataset предусмотрено получение** валидационной выборки и ее возврата;\n- **train_parameters** - параметры, которые разработчик ML указывает на сайте в разделе Train Parameters.\n\n*Возвращает (List[Metric], nn.Module) - кортеж состоящий из:*  \n*1. Список метрик полученных в ходе обучения;*  \n*2. Обученной модели.*\n\n```python\ndef get_dataset(dataset_path: str, with_split: bool, test_size: float, shuffle: bool) -> Union[\n    Tuple[torch.utils.data.Dataset, torch.utils.data.Dataset, torch.utils.data.Dataset],\n    Tuple[torch.utils.data.Dataset, torch.utils.data.Dataset], Tuple[torch.utils.data.Dataset]]:\n    transactions, labels = load_dataset(dataset_path)\n    if with_split:\n        x_train, x_test, y_train, y_test = train_test_split(transactions, labels, test_size=test_size, shuffle=shuffle)\n        x_train, x_test = preprocess_data(x_train, x_test)\n\n        train_set = TransactionsDataset(x_train, y_train)\n        test_set = TransactionsDataset(x_test, y_test)\n\n        return train_set, test_set\n    else:\n        x_test = preprocess_set(transactions)\n        test_set = TransactionsDataset(x_test, labels)\n        return test_set\n```\n\n#### Метод 4: test:\n*Метод для тестирования модели на данных.*  \nНа вход подается model, полученная из load_model; return_output и булева переменная,\nговорящая о необходимости возврата выхода из модели на данных;\ntest_set - тестировочная выборка, полученная из get_dataset, \nа также параметры, которые разработчик ML укажет в коде как необходимые(специфические для каждого отдельного пользователя).\nОбязательные параметры, которые необходимо учитывать разработчику ML:\n- **model(nn.Module)** - модель, полученный из метода load_model\n- **test_set(torch.utils.data.Dataset)** - тестировочная выборка, полученная из метода get_dataset\n- **return_output(bool)** - булева переменная, говорящая о необходимости возвращать ответы модели\n- **test_parameters** - параметры, которые разработчик ML указывает на сайте в разделе Test Parameters\n\n*Возвращает один из следующих кортежей:*  \n- *(List[Metric]) - метрики полученные в ходе тестирования модели на данных;*\n- *(List[Metric], list) - метрики и ответы модели полученные в ходе тестирования модели на данных(только если return_output=True).*\n\n```python\ndef test(model: torch.nn.Module, test_set: torch.utils.data.Dataset, return_output: bool) -> Union[\n    Tuple[List[Metric]], Tuple[List[Metric], list]]:\n    test_loss = 0.0\n    model.eval()\n    loss_fn = BCELoss()\n\n    test_dataloader = DataLoader(test_set)\n\n    outputs = []\n    labels = np.array([])\n\n    for i, data in enumerate(test_dataloader):\n        transactions, label = data[\'transaction\'], data[\'label\']\n\n        transactions = transactions.reshape(transactions.shape[0], 1, transactions.shape[1])\n        output = model(transactions)\n\n        loss = loss_fn(output, label)\n\n        test_loss += loss.item()\n\n        outputs.append(output.cpu().detach().numpy().reshape(-1))\n        labels = np.hstack([labels, label.cpu().reshape(-1)])\n\n    test_loss /= len(test_dataloader)\n\n    test_loss_metric = Metric(name="test_loss")\n    test_loss_metric.log_value(test_loss)\n\n    test_roc_auc_score = roc_auc_score(labels, np.array(outputs))\n\n    test_roc_auc_score_metric = Metric(name="test_roc_auc_score")\n    test_roc_auc_score_metric.log_value(test_roc_auc_score)\n\n\n    if return_output:\n        return ([test_loss_metric, test_roc_auc_score_metric], outputs)\n    else:\n        return ([test_loss_metric, test_roc_auc_score_metric])\n\n```\n\n## Выкладываем код с реализованным классом Сlient в GitHub\nНеобходимо выложить готовый клиент в открытый GitHub репозиторий в ветку с именем master\n',
    'author': 'None',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/joint-ml/client_package',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9',
}


setup(**setup_kwargs)
